
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Difficulty
 * 
 */
export type Difficulty = $Result.DefaultSelection<Prisma.$DifficultyPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Answer
 * 
 */
export type Answer = $Result.DefaultSelection<Prisma.$AnswerPayload>
/**
 * Model QuizSession
 * 
 */
export type QuizSession = $Result.DefaultSelection<Prisma.$QuizSessionPayload>
/**
 * Model SessionAnswer
 * 
 */
export type SessionAnswer = $Result.DefaultSelection<Prisma.$SessionAnswerPayload>
/**
 * Model PlayerProgress
 * 
 */
export type PlayerProgress = $Result.DefaultSelection<Prisma.$PlayerProgressPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model PlayerBadge
 * 
 */
export type PlayerBadge = $Result.DefaultSelection<Prisma.$PlayerBadgePayload>
/**
 * Model CategoryStat
 * 
 */
export type CategoryStat = $Result.DefaultSelection<Prisma.$CategoryStatPayload>
/**
 * Model StreakProtection
 * 
 */
export type StreakProtection = $Result.DefaultSelection<Prisma.$StreakProtectionPayload>
/**
 * Model PlayerRanking
 * 
 */
export type PlayerRanking = $Result.DefaultSelection<Prisma.$PlayerRankingPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model ShopItem
 * 
 */
export type ShopItem = $Result.DefaultSelection<Prisma.$ShopItemPayload>
/**
 * Model Lives
 * 
 */
export type Lives = $Result.DefaultSelection<Prisma.$LivesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  PLAYER: 'PLAYER',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const QuestionStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type QuestionStatus = (typeof QuestionStatus)[keyof typeof QuestionStatus]


export const SessionStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ABANDONED: 'ABANDONED'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const BadgeRarity: {
  COMMON: 'COMMON',
  RARE: 'RARE',
  EPIC: 'EPIC',
  LEGENDARY: 'LEGENDARY'
};

export type BadgeRarity = (typeof BadgeRarity)[keyof typeof BadgeRarity]


export const TransactionType: {
  EARNED: 'EARNED',
  SPENT: 'SPENT'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const ShopItemType: {
  POWERUP_FIFTY_FIFTY: 'POWERUP_FIFTY_FIFTY',
  POWERUP_EXTRA_TIME: 'POWERUP_EXTRA_TIME',
  POWERUP_SKIP: 'POWERUP_SKIP',
  LIFE: 'LIFE',
  STREAK_FREEZE: 'STREAK_FREEZE'
};

export type ShopItemType = (typeof ShopItemType)[keyof typeof ShopItemType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type QuestionStatus = $Enums.QuestionStatus

export const QuestionStatus: typeof $Enums.QuestionStatus

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type BadgeRarity = $Enums.BadgeRarity

export const BadgeRarity: typeof $Enums.BadgeRarity

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type ShopItemType = $Enums.ShopItemType

export const ShopItemType: typeof $Enums.ShopItemType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.difficulty`: Exposes CRUD operations for the **Difficulty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Difficulties
    * const difficulties = await prisma.difficulty.findMany()
    * ```
    */
  get difficulty(): Prisma.DifficultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **Answer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answer.findMany()
    * ```
    */
  get answer(): Prisma.AnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizSession`: Exposes CRUD operations for the **QuizSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizSessions
    * const quizSessions = await prisma.quizSession.findMany()
    * ```
    */
  get quizSession(): Prisma.QuizSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionAnswer`: Exposes CRUD operations for the **SessionAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionAnswers
    * const sessionAnswers = await prisma.sessionAnswer.findMany()
    * ```
    */
  get sessionAnswer(): Prisma.SessionAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerProgress`: Exposes CRUD operations for the **PlayerProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerProgresses
    * const playerProgresses = await prisma.playerProgress.findMany()
    * ```
    */
  get playerProgress(): Prisma.PlayerProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerBadge`: Exposes CRUD operations for the **PlayerBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerBadges
    * const playerBadges = await prisma.playerBadge.findMany()
    * ```
    */
  get playerBadge(): Prisma.PlayerBadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoryStat`: Exposes CRUD operations for the **CategoryStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryStats
    * const categoryStats = await prisma.categoryStat.findMany()
    * ```
    */
  get categoryStat(): Prisma.CategoryStatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.streakProtection`: Exposes CRUD operations for the **StreakProtection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StreakProtections
    * const streakProtections = await prisma.streakProtection.findMany()
    * ```
    */
  get streakProtection(): Prisma.StreakProtectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerRanking`: Exposes CRUD operations for the **PlayerRanking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerRankings
    * const playerRankings = await prisma.playerRanking.findMany()
    * ```
    */
  get playerRanking(): Prisma.PlayerRankingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopItem`: Exposes CRUD operations for the **ShopItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopItems
    * const shopItems = await prisma.shopItem.findMany()
    * ```
    */
  get shopItem(): Prisma.ShopItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lives`: Exposes CRUD operations for the **Lives** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lives
    * const lives = await prisma.lives.findMany()
    * ```
    */
  get lives(): Prisma.LivesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.0.0
   * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RefreshToken: 'RefreshToken',
    Category: 'Category',
    Difficulty: 'Difficulty',
    Question: 'Question',
    Answer: 'Answer',
    QuizSession: 'QuizSession',
    SessionAnswer: 'SessionAnswer',
    PlayerProgress: 'PlayerProgress',
    Badge: 'Badge',
    PlayerBadge: 'PlayerBadge',
    CategoryStat: 'CategoryStat',
    StreakProtection: 'StreakProtection',
    PlayerRanking: 'PlayerRanking',
    Wallet: 'Wallet',
    Transaction: 'Transaction',
    ShopItem: 'ShopItem',
    Lives: 'Lives'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "refreshToken" | "category" | "difficulty" | "question" | "answer" | "quizSession" | "sessionAnswer" | "playerProgress" | "badge" | "playerBadge" | "categoryStat" | "streakProtection" | "playerRanking" | "wallet" | "transaction" | "shopItem" | "lives"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Difficulty: {
        payload: Prisma.$DifficultyPayload<ExtArgs>
        fields: Prisma.DifficultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DifficultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DifficultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload>
          }
          findFirst: {
            args: Prisma.DifficultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DifficultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload>
          }
          findMany: {
            args: Prisma.DifficultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload>[]
          }
          create: {
            args: Prisma.DifficultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload>
          }
          createMany: {
            args: Prisma.DifficultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DifficultyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload>[]
          }
          delete: {
            args: Prisma.DifficultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload>
          }
          update: {
            args: Prisma.DifficultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload>
          }
          deleteMany: {
            args: Prisma.DifficultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DifficultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DifficultyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload>[]
          }
          upsert: {
            args: Prisma.DifficultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyPayload>
          }
          aggregate: {
            args: Prisma.DifficultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDifficulty>
          }
          groupBy: {
            args: Prisma.DifficultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DifficultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DifficultyCountArgs<ExtArgs>
            result: $Utils.Optional<DifficultyCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Answer: {
        payload: Prisma.$AnswerPayload<ExtArgs>
        fields: Prisma.AnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findFirst: {
            args: Prisma.AnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findMany: {
            args: Prisma.AnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          create: {
            args: Prisma.AnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          createMany: {
            args: Prisma.AnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          delete: {
            args: Prisma.AnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          update: {
            args: Prisma.AnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          deleteMany: {
            args: Prisma.AnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          upsert: {
            args: Prisma.AnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          aggregate: {
            args: Prisma.AnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswer>
          }
          groupBy: {
            args: Prisma.AnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnswerCountArgs<ExtArgs>
            result: $Utils.Optional<AnswerCountAggregateOutputType> | number
          }
        }
      }
      QuizSession: {
        payload: Prisma.$QuizSessionPayload<ExtArgs>
        fields: Prisma.QuizSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          findFirst: {
            args: Prisma.QuizSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          findMany: {
            args: Prisma.QuizSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>[]
          }
          create: {
            args: Prisma.QuizSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          createMany: {
            args: Prisma.QuizSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>[]
          }
          delete: {
            args: Prisma.QuizSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          update: {
            args: Prisma.QuizSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          deleteMany: {
            args: Prisma.QuizSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>[]
          }
          upsert: {
            args: Prisma.QuizSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          aggregate: {
            args: Prisma.QuizSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizSession>
          }
          groupBy: {
            args: Prisma.QuizSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizSessionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizSessionCountAggregateOutputType> | number
          }
        }
      }
      SessionAnswer: {
        payload: Prisma.$SessionAnswerPayload<ExtArgs>
        fields: Prisma.SessionAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload>
          }
          findFirst: {
            args: Prisma.SessionAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload>
          }
          findMany: {
            args: Prisma.SessionAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload>[]
          }
          create: {
            args: Prisma.SessionAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload>
          }
          createMany: {
            args: Prisma.SessionAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload>[]
          }
          delete: {
            args: Prisma.SessionAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload>
          }
          update: {
            args: Prisma.SessionAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload>
          }
          deleteMany: {
            args: Prisma.SessionAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload>[]
          }
          upsert: {
            args: Prisma.SessionAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAnswerPayload>
          }
          aggregate: {
            args: Prisma.SessionAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionAnswer>
          }
          groupBy: {
            args: Prisma.SessionAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<SessionAnswerCountAggregateOutputType> | number
          }
        }
      }
      PlayerProgress: {
        payload: Prisma.$PlayerProgressPayload<ExtArgs>
        fields: Prisma.PlayerProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload>
          }
          findFirst: {
            args: Prisma.PlayerProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload>
          }
          findMany: {
            args: Prisma.PlayerProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload>[]
          }
          create: {
            args: Prisma.PlayerProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload>
          }
          createMany: {
            args: Prisma.PlayerProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload>[]
          }
          delete: {
            args: Prisma.PlayerProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload>
          }
          update: {
            args: Prisma.PlayerProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload>
          }
          deleteMany: {
            args: Prisma.PlayerProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload>[]
          }
          upsert: {
            args: Prisma.PlayerProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProgressPayload>
          }
          aggregate: {
            args: Prisma.PlayerProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerProgress>
          }
          groupBy: {
            args: Prisma.PlayerProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerProgressCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerProgressCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      PlayerBadge: {
        payload: Prisma.$PlayerBadgePayload<ExtArgs>
        fields: Prisma.PlayerBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload>
          }
          findFirst: {
            args: Prisma.PlayerBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload>
          }
          findMany: {
            args: Prisma.PlayerBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload>[]
          }
          create: {
            args: Prisma.PlayerBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload>
          }
          createMany: {
            args: Prisma.PlayerBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload>[]
          }
          delete: {
            args: Prisma.PlayerBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload>
          }
          update: {
            args: Prisma.PlayerBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload>
          }
          deleteMany: {
            args: Prisma.PlayerBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerBadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload>[]
          }
          upsert: {
            args: Prisma.PlayerBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerBadgePayload>
          }
          aggregate: {
            args: Prisma.PlayerBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerBadge>
          }
          groupBy: {
            args: Prisma.PlayerBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerBadgeCountAggregateOutputType> | number
          }
        }
      }
      CategoryStat: {
        payload: Prisma.$CategoryStatPayload<ExtArgs>
        fields: Prisma.CategoryStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryStatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryStatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload>
          }
          findFirst: {
            args: Prisma.CategoryStatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryStatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload>
          }
          findMany: {
            args: Prisma.CategoryStatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload>[]
          }
          create: {
            args: Prisma.CategoryStatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload>
          }
          createMany: {
            args: Prisma.CategoryStatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryStatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload>[]
          }
          delete: {
            args: Prisma.CategoryStatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload>
          }
          update: {
            args: Prisma.CategoryStatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload>
          }
          deleteMany: {
            args: Prisma.CategoryStatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryStatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryStatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload>[]
          }
          upsert: {
            args: Prisma.CategoryStatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryStatPayload>
          }
          aggregate: {
            args: Prisma.CategoryStatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoryStat>
          }
          groupBy: {
            args: Prisma.CategoryStatGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryStatCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryStatCountAggregateOutputType> | number
          }
        }
      }
      StreakProtection: {
        payload: Prisma.$StreakProtectionPayload<ExtArgs>
        fields: Prisma.StreakProtectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StreakProtectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StreakProtectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload>
          }
          findFirst: {
            args: Prisma.StreakProtectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StreakProtectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload>
          }
          findMany: {
            args: Prisma.StreakProtectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload>[]
          }
          create: {
            args: Prisma.StreakProtectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload>
          }
          createMany: {
            args: Prisma.StreakProtectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StreakProtectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload>[]
          }
          delete: {
            args: Prisma.StreakProtectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload>
          }
          update: {
            args: Prisma.StreakProtectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload>
          }
          deleteMany: {
            args: Prisma.StreakProtectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StreakProtectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StreakProtectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload>[]
          }
          upsert: {
            args: Prisma.StreakProtectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakProtectionPayload>
          }
          aggregate: {
            args: Prisma.StreakProtectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStreakProtection>
          }
          groupBy: {
            args: Prisma.StreakProtectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StreakProtectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StreakProtectionCountArgs<ExtArgs>
            result: $Utils.Optional<StreakProtectionCountAggregateOutputType> | number
          }
        }
      }
      PlayerRanking: {
        payload: Prisma.$PlayerRankingPayload<ExtArgs>
        fields: Prisma.PlayerRankingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerRankingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerRankingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload>
          }
          findFirst: {
            args: Prisma.PlayerRankingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerRankingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload>
          }
          findMany: {
            args: Prisma.PlayerRankingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload>[]
          }
          create: {
            args: Prisma.PlayerRankingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload>
          }
          createMany: {
            args: Prisma.PlayerRankingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerRankingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload>[]
          }
          delete: {
            args: Prisma.PlayerRankingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload>
          }
          update: {
            args: Prisma.PlayerRankingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload>
          }
          deleteMany: {
            args: Prisma.PlayerRankingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerRankingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerRankingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload>[]
          }
          upsert: {
            args: Prisma.PlayerRankingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRankingPayload>
          }
          aggregate: {
            args: Prisma.PlayerRankingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerRanking>
          }
          groupBy: {
            args: Prisma.PlayerRankingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerRankingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerRankingCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerRankingCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      ShopItem: {
        payload: Prisma.$ShopItemPayload<ExtArgs>
        fields: Prisma.ShopItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          findFirst: {
            args: Prisma.ShopItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          findMany: {
            args: Prisma.ShopItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>[]
          }
          create: {
            args: Prisma.ShopItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          createMany: {
            args: Prisma.ShopItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>[]
          }
          delete: {
            args: Prisma.ShopItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          update: {
            args: Prisma.ShopItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          deleteMany: {
            args: Prisma.ShopItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>[]
          }
          upsert: {
            args: Prisma.ShopItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          aggregate: {
            args: Prisma.ShopItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopItem>
          }
          groupBy: {
            args: Prisma.ShopItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopItemCountArgs<ExtArgs>
            result: $Utils.Optional<ShopItemCountAggregateOutputType> | number
          }
        }
      }
      Lives: {
        payload: Prisma.$LivesPayload<ExtArgs>
        fields: Prisma.LivesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LivesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LivesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload>
          }
          findFirst: {
            args: Prisma.LivesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LivesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload>
          }
          findMany: {
            args: Prisma.LivesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload>[]
          }
          create: {
            args: Prisma.LivesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload>
          }
          createMany: {
            args: Prisma.LivesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LivesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload>[]
          }
          delete: {
            args: Prisma.LivesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload>
          }
          update: {
            args: Prisma.LivesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload>
          }
          deleteMany: {
            args: Prisma.LivesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LivesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LivesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload>[]
          }
          upsert: {
            args: Prisma.LivesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivesPayload>
          }
          aggregate: {
            args: Prisma.LivesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLives>
          }
          groupBy: {
            args: Prisma.LivesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LivesGroupByOutputType>[]
          }
          count: {
            args: Prisma.LivesCountArgs<ExtArgs>
            result: $Utils.Optional<LivesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    category?: CategoryOmit
    difficulty?: DifficultyOmit
    question?: QuestionOmit
    answer?: AnswerOmit
    quizSession?: QuizSessionOmit
    sessionAnswer?: SessionAnswerOmit
    playerProgress?: PlayerProgressOmit
    badge?: BadgeOmit
    playerBadge?: PlayerBadgeOmit
    categoryStat?: CategoryStatOmit
    streakProtection?: StreakProtectionOmit
    playerRanking?: PlayerRankingOmit
    wallet?: WalletOmit
    transaction?: TransactionOmit
    shopItem?: ShopItemOmit
    lives?: LivesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number
    quizSessions: number
    transactions: number
    createdQuestions: number
    playerBadges: number
    streakProtections: number
    categoryStats: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    quizSessions?: boolean | UserCountOutputTypeCountQuizSessionsArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    createdQuestions?: boolean | UserCountOutputTypeCountCreatedQuestionsArgs
    playerBadges?: boolean | UserCountOutputTypeCountPlayerBadgesArgs
    streakProtections?: boolean | UserCountOutputTypeCountStreakProtectionsArgs
    categoryStats?: boolean | UserCountOutputTypeCountCategoryStatsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlayerBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerBadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStreakProtectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreakProtectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCategoryStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryStatWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    questions: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | CategoryCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }


  /**
   * Count Type DifficultyCountOutputType
   */

  export type DifficultyCountOutputType = {
    questions: number
    quizSessions: number
  }

  export type DifficultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | DifficultyCountOutputTypeCountQuestionsArgs
    quizSessions?: boolean | DifficultyCountOutputTypeCountQuizSessionsArgs
  }

  // Custom InputTypes
  /**
   * DifficultyCountOutputType without action
   */
  export type DifficultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyCountOutputType
     */
    select?: DifficultyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DifficultyCountOutputType without action
   */
  export type DifficultyCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * DifficultyCountOutputType without action
   */
  export type DifficultyCountOutputTypeCountQuizSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSessionWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    answers: number
    sessionAnswers: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuestionCountOutputTypeCountAnswersArgs
    sessionAnswers?: boolean | QuestionCountOutputTypeCountSessionAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountSessionAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionAnswerWhereInput
  }


  /**
   * Count Type AnswerCountOutputType
   */

  export type AnswerCountOutputType = {
    sessionAnswers: number
  }

  export type AnswerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessionAnswers?: boolean | AnswerCountOutputTypeCountSessionAnswersArgs
  }

  // Custom InputTypes
  /**
   * AnswerCountOutputType without action
   */
  export type AnswerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerCountOutputType
     */
    select?: AnswerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnswerCountOutputType without action
   */
  export type AnswerCountOutputTypeCountSessionAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionAnswerWhereInput
  }


  /**
   * Count Type QuizSessionCountOutputType
   */

  export type QuizSessionCountOutputType = {
    answers: number
  }

  export type QuizSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuizSessionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuizSessionCountOutputType without action
   */
  export type QuizSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSessionCountOutputType
     */
    select?: QuizSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizSessionCountOutputType without action
   */
  export type QuizSessionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionAnswerWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    playerBadges: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerBadges?: boolean | BadgeCountOutputTypeCountPlayerBadgesArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountPlayerBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerBadgeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    name: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    name: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    username: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    username: string
    name: string
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    quizSessions?: boolean | User$quizSessionsArgs<ExtArgs>
    playerProgress?: boolean | User$playerProgressArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    lives?: boolean | User$livesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    playerRanking?: boolean | User$playerRankingArgs<ExtArgs>
    createdQuestions?: boolean | User$createdQuestionsArgs<ExtArgs>
    playerBadges?: boolean | User$playerBadgesArgs<ExtArgs>
    streakProtections?: boolean | User$streakProtectionsArgs<ExtArgs>
    categoryStats?: boolean | User$categoryStatsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "username" | "name" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    quizSessions?: boolean | User$quizSessionsArgs<ExtArgs>
    playerProgress?: boolean | User$playerProgressArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    lives?: boolean | User$livesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    playerRanking?: boolean | User$playerRankingArgs<ExtArgs>
    createdQuestions?: boolean | User$createdQuestionsArgs<ExtArgs>
    playerBadges?: boolean | User$playerBadgesArgs<ExtArgs>
    streakProtections?: boolean | User$streakProtectionsArgs<ExtArgs>
    categoryStats?: boolean | User$categoryStatsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      quizSessions: Prisma.$QuizSessionPayload<ExtArgs>[]
      playerProgress: Prisma.$PlayerProgressPayload<ExtArgs> | null
      wallet: Prisma.$WalletPayload<ExtArgs> | null
      lives: Prisma.$LivesPayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      playerRanking: Prisma.$PlayerRankingPayload<ExtArgs> | null
      createdQuestions: Prisma.$QuestionPayload<ExtArgs>[]
      playerBadges: Prisma.$PlayerBadgePayload<ExtArgs>[]
      streakProtections: Prisma.$StreakProtectionPayload<ExtArgs>[]
      categoryStats: Prisma.$CategoryStatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      username: string
      name: string
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizSessions<T extends User$quizSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$quizSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playerProgress<T extends User$playerProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$playerProgressArgs<ExtArgs>>): Prisma__PlayerProgressClient<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wallet<T extends User$walletArgs<ExtArgs> = {}>(args?: Subset<T, User$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lives<T extends User$livesArgs<ExtArgs> = {}>(args?: Subset<T, User$livesArgs<ExtArgs>>): Prisma__LivesClient<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playerRanking<T extends User$playerRankingArgs<ExtArgs> = {}>(args?: Subset<T, User$playerRankingArgs<ExtArgs>>): Prisma__PlayerRankingClient<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdQuestions<T extends User$createdQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playerBadges<T extends User$playerBadgesArgs<ExtArgs> = {}>(args?: Subset<T, User$playerBadgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    streakProtections<T extends User$streakProtectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$streakProtectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categoryStats<T extends User$categoryStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$categoryStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.quizSessions
   */
  export type User$quizSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    where?: QuizSessionWhereInput
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    cursor?: QuizSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * User.playerProgress
   */
  export type User$playerProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
    where?: PlayerProgressWhereInput
  }

  /**
   * User.wallet
   */
  export type User$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * User.lives
   */
  export type User$livesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
    where?: LivesWhereInput
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.playerRanking
   */
  export type User$playerRankingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
    where?: PlayerRankingWhereInput
  }

  /**
   * User.createdQuestions
   */
  export type User$createdQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * User.playerBadges
   */
  export type User$playerBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    where?: PlayerBadgeWhereInput
    orderBy?: PlayerBadgeOrderByWithRelationInput | PlayerBadgeOrderByWithRelationInput[]
    cursor?: PlayerBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerBadgeScalarFieldEnum | PlayerBadgeScalarFieldEnum[]
  }

  /**
   * User.streakProtections
   */
  export type User$streakProtectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
    where?: StreakProtectionWhereInput
    orderBy?: StreakProtectionOrderByWithRelationInput | StreakProtectionOrderByWithRelationInput[]
    cursor?: StreakProtectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StreakProtectionScalarFieldEnum | StreakProtectionScalarFieldEnum[]
  }

  /**
   * User.categoryStats
   */
  export type User$categoryStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
    where?: CategoryStatWhereInput
    orderBy?: CategoryStatOrderByWithRelationInput | CategoryStatOrderByWithRelationInput[]
    cursor?: CategoryStatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryStatScalarFieldEnum | CategoryStatScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "createdAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    icon: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    icon: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    icon: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    icon: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | Category$questionsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "icon" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Category$questionsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      questions: Prisma.$QuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      icon: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends Category$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Category$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.questions
   */
  export type Category$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Difficulty
   */

  export type AggregateDifficulty = {
    _count: DifficultyCountAggregateOutputType | null
    _avg: DifficultyAvgAggregateOutputType | null
    _sum: DifficultySumAggregateOutputType | null
    _min: DifficultyMinAggregateOutputType | null
    _max: DifficultyMaxAggregateOutputType | null
  }

  export type DifficultyAvgAggregateOutputType = {
    timePerQuestion: number | null
    xpMultiplier: number | null
  }

  export type DifficultySumAggregateOutputType = {
    timePerQuestion: number | null
    xpMultiplier: number | null
  }

  export type DifficultyMinAggregateOutputType = {
    id: string | null
    level: string | null
    name: string | null
    timePerQuestion: number | null
    xpMultiplier: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DifficultyMaxAggregateOutputType = {
    id: string | null
    level: string | null
    name: string | null
    timePerQuestion: number | null
    xpMultiplier: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DifficultyCountAggregateOutputType = {
    id: number
    level: number
    name: number
    timePerQuestion: number
    xpMultiplier: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DifficultyAvgAggregateInputType = {
    timePerQuestion?: true
    xpMultiplier?: true
  }

  export type DifficultySumAggregateInputType = {
    timePerQuestion?: true
    xpMultiplier?: true
  }

  export type DifficultyMinAggregateInputType = {
    id?: true
    level?: true
    name?: true
    timePerQuestion?: true
    xpMultiplier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DifficultyMaxAggregateInputType = {
    id?: true
    level?: true
    name?: true
    timePerQuestion?: true
    xpMultiplier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DifficultyCountAggregateInputType = {
    id?: true
    level?: true
    name?: true
    timePerQuestion?: true
    xpMultiplier?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DifficultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Difficulty to aggregate.
     */
    where?: DifficultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Difficulties to fetch.
     */
    orderBy?: DifficultyOrderByWithRelationInput | DifficultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DifficultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Difficulties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Difficulties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Difficulties
    **/
    _count?: true | DifficultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DifficultyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DifficultySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DifficultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DifficultyMaxAggregateInputType
  }

  export type GetDifficultyAggregateType<T extends DifficultyAggregateArgs> = {
        [P in keyof T & keyof AggregateDifficulty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDifficulty[P]>
      : GetScalarType<T[P], AggregateDifficulty[P]>
  }




  export type DifficultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DifficultyWhereInput
    orderBy?: DifficultyOrderByWithAggregationInput | DifficultyOrderByWithAggregationInput[]
    by: DifficultyScalarFieldEnum[] | DifficultyScalarFieldEnum
    having?: DifficultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DifficultyCountAggregateInputType | true
    _avg?: DifficultyAvgAggregateInputType
    _sum?: DifficultySumAggregateInputType
    _min?: DifficultyMinAggregateInputType
    _max?: DifficultyMaxAggregateInputType
  }

  export type DifficultyGroupByOutputType = {
    id: string
    level: string
    name: string
    timePerQuestion: number
    xpMultiplier: number
    createdAt: Date
    updatedAt: Date
    _count: DifficultyCountAggregateOutputType | null
    _avg: DifficultyAvgAggregateOutputType | null
    _sum: DifficultySumAggregateOutputType | null
    _min: DifficultyMinAggregateOutputType | null
    _max: DifficultyMaxAggregateOutputType | null
  }

  type GetDifficultyGroupByPayload<T extends DifficultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DifficultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DifficultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DifficultyGroupByOutputType[P]>
            : GetScalarType<T[P], DifficultyGroupByOutputType[P]>
        }
      >
    >


  export type DifficultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    name?: boolean
    timePerQuestion?: boolean
    xpMultiplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | Difficulty$questionsArgs<ExtArgs>
    quizSessions?: boolean | Difficulty$quizSessionsArgs<ExtArgs>
    _count?: boolean | DifficultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["difficulty"]>

  export type DifficultySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    name?: boolean
    timePerQuestion?: boolean
    xpMultiplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["difficulty"]>

  export type DifficultySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    name?: boolean
    timePerQuestion?: boolean
    xpMultiplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["difficulty"]>

  export type DifficultySelectScalar = {
    id?: boolean
    level?: boolean
    name?: boolean
    timePerQuestion?: boolean
    xpMultiplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DifficultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level" | "name" | "timePerQuestion" | "xpMultiplier" | "createdAt" | "updatedAt", ExtArgs["result"]["difficulty"]>
  export type DifficultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Difficulty$questionsArgs<ExtArgs>
    quizSessions?: boolean | Difficulty$quizSessionsArgs<ExtArgs>
    _count?: boolean | DifficultyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DifficultyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DifficultyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DifficultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Difficulty"
    objects: {
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      quizSessions: Prisma.$QuizSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: string
      name: string
      timePerQuestion: number
      xpMultiplier: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["difficulty"]>
    composites: {}
  }

  type DifficultyGetPayload<S extends boolean | null | undefined | DifficultyDefaultArgs> = $Result.GetResult<Prisma.$DifficultyPayload, S>

  type DifficultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DifficultyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DifficultyCountAggregateInputType | true
    }

  export interface DifficultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Difficulty'], meta: { name: 'Difficulty' } }
    /**
     * Find zero or one Difficulty that matches the filter.
     * @param {DifficultyFindUniqueArgs} args - Arguments to find a Difficulty
     * @example
     * // Get one Difficulty
     * const difficulty = await prisma.difficulty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DifficultyFindUniqueArgs>(args: SelectSubset<T, DifficultyFindUniqueArgs<ExtArgs>>): Prisma__DifficultyClient<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Difficulty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DifficultyFindUniqueOrThrowArgs} args - Arguments to find a Difficulty
     * @example
     * // Get one Difficulty
     * const difficulty = await prisma.difficulty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DifficultyFindUniqueOrThrowArgs>(args: SelectSubset<T, DifficultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DifficultyClient<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Difficulty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyFindFirstArgs} args - Arguments to find a Difficulty
     * @example
     * // Get one Difficulty
     * const difficulty = await prisma.difficulty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DifficultyFindFirstArgs>(args?: SelectSubset<T, DifficultyFindFirstArgs<ExtArgs>>): Prisma__DifficultyClient<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Difficulty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyFindFirstOrThrowArgs} args - Arguments to find a Difficulty
     * @example
     * // Get one Difficulty
     * const difficulty = await prisma.difficulty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DifficultyFindFirstOrThrowArgs>(args?: SelectSubset<T, DifficultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DifficultyClient<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Difficulties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Difficulties
     * const difficulties = await prisma.difficulty.findMany()
     * 
     * // Get first 10 Difficulties
     * const difficulties = await prisma.difficulty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const difficultyWithIdOnly = await prisma.difficulty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DifficultyFindManyArgs>(args?: SelectSubset<T, DifficultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Difficulty.
     * @param {DifficultyCreateArgs} args - Arguments to create a Difficulty.
     * @example
     * // Create one Difficulty
     * const Difficulty = await prisma.difficulty.create({
     *   data: {
     *     // ... data to create a Difficulty
     *   }
     * })
     * 
     */
    create<T extends DifficultyCreateArgs>(args: SelectSubset<T, DifficultyCreateArgs<ExtArgs>>): Prisma__DifficultyClient<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Difficulties.
     * @param {DifficultyCreateManyArgs} args - Arguments to create many Difficulties.
     * @example
     * // Create many Difficulties
     * const difficulty = await prisma.difficulty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DifficultyCreateManyArgs>(args?: SelectSubset<T, DifficultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Difficulties and returns the data saved in the database.
     * @param {DifficultyCreateManyAndReturnArgs} args - Arguments to create many Difficulties.
     * @example
     * // Create many Difficulties
     * const difficulty = await prisma.difficulty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Difficulties and only return the `id`
     * const difficultyWithIdOnly = await prisma.difficulty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DifficultyCreateManyAndReturnArgs>(args?: SelectSubset<T, DifficultyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Difficulty.
     * @param {DifficultyDeleteArgs} args - Arguments to delete one Difficulty.
     * @example
     * // Delete one Difficulty
     * const Difficulty = await prisma.difficulty.delete({
     *   where: {
     *     // ... filter to delete one Difficulty
     *   }
     * })
     * 
     */
    delete<T extends DifficultyDeleteArgs>(args: SelectSubset<T, DifficultyDeleteArgs<ExtArgs>>): Prisma__DifficultyClient<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Difficulty.
     * @param {DifficultyUpdateArgs} args - Arguments to update one Difficulty.
     * @example
     * // Update one Difficulty
     * const difficulty = await prisma.difficulty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DifficultyUpdateArgs>(args: SelectSubset<T, DifficultyUpdateArgs<ExtArgs>>): Prisma__DifficultyClient<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Difficulties.
     * @param {DifficultyDeleteManyArgs} args - Arguments to filter Difficulties to delete.
     * @example
     * // Delete a few Difficulties
     * const { count } = await prisma.difficulty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DifficultyDeleteManyArgs>(args?: SelectSubset<T, DifficultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Difficulties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Difficulties
     * const difficulty = await prisma.difficulty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DifficultyUpdateManyArgs>(args: SelectSubset<T, DifficultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Difficulties and returns the data updated in the database.
     * @param {DifficultyUpdateManyAndReturnArgs} args - Arguments to update many Difficulties.
     * @example
     * // Update many Difficulties
     * const difficulty = await prisma.difficulty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Difficulties and only return the `id`
     * const difficultyWithIdOnly = await prisma.difficulty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DifficultyUpdateManyAndReturnArgs>(args: SelectSubset<T, DifficultyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Difficulty.
     * @param {DifficultyUpsertArgs} args - Arguments to update or create a Difficulty.
     * @example
     * // Update or create a Difficulty
     * const difficulty = await prisma.difficulty.upsert({
     *   create: {
     *     // ... data to create a Difficulty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Difficulty we want to update
     *   }
     * })
     */
    upsert<T extends DifficultyUpsertArgs>(args: SelectSubset<T, DifficultyUpsertArgs<ExtArgs>>): Prisma__DifficultyClient<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Difficulties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyCountArgs} args - Arguments to filter Difficulties to count.
     * @example
     * // Count the number of Difficulties
     * const count = await prisma.difficulty.count({
     *   where: {
     *     // ... the filter for the Difficulties we want to count
     *   }
     * })
    **/
    count<T extends DifficultyCountArgs>(
      args?: Subset<T, DifficultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DifficultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Difficulty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DifficultyAggregateArgs>(args: Subset<T, DifficultyAggregateArgs>): Prisma.PrismaPromise<GetDifficultyAggregateType<T>>

    /**
     * Group by Difficulty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DifficultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DifficultyGroupByArgs['orderBy'] }
        : { orderBy?: DifficultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DifficultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDifficultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Difficulty model
   */
  readonly fields: DifficultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Difficulty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DifficultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends Difficulty$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Difficulty$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizSessions<T extends Difficulty$quizSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Difficulty$quizSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Difficulty model
   */
  interface DifficultyFieldRefs {
    readonly id: FieldRef<"Difficulty", 'String'>
    readonly level: FieldRef<"Difficulty", 'String'>
    readonly name: FieldRef<"Difficulty", 'String'>
    readonly timePerQuestion: FieldRef<"Difficulty", 'Int'>
    readonly xpMultiplier: FieldRef<"Difficulty", 'Float'>
    readonly createdAt: FieldRef<"Difficulty", 'DateTime'>
    readonly updatedAt: FieldRef<"Difficulty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Difficulty findUnique
   */
  export type DifficultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifficultyInclude<ExtArgs> | null
    /**
     * Filter, which Difficulty to fetch.
     */
    where: DifficultyWhereUniqueInput
  }

  /**
   * Difficulty findUniqueOrThrow
   */
  export type DifficultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifficultyInclude<ExtArgs> | null
    /**
     * Filter, which Difficulty to fetch.
     */
    where: DifficultyWhereUniqueInput
  }

  /**
   * Difficulty findFirst
   */
  export type DifficultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifficultyInclude<ExtArgs> | null
    /**
     * Filter, which Difficulty to fetch.
     */
    where?: DifficultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Difficulties to fetch.
     */
    orderBy?: DifficultyOrderByWithRelationInput | DifficultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Difficulties.
     */
    cursor?: DifficultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Difficulties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Difficulties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Difficulties.
     */
    distinct?: DifficultyScalarFieldEnum | DifficultyScalarFieldEnum[]
  }

  /**
   * Difficulty findFirstOrThrow
   */
  export type DifficultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifficultyInclude<ExtArgs> | null
    /**
     * Filter, which Difficulty to fetch.
     */
    where?: DifficultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Difficulties to fetch.
     */
    orderBy?: DifficultyOrderByWithRelationInput | DifficultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Difficulties.
     */
    cursor?: DifficultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Difficulties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Difficulties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Difficulties.
     */
    distinct?: DifficultyScalarFieldEnum | DifficultyScalarFieldEnum[]
  }

  /**
   * Difficulty findMany
   */
  export type DifficultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifficultyInclude<ExtArgs> | null
    /**
     * Filter, which Difficulties to fetch.
     */
    where?: DifficultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Difficulties to fetch.
     */
    orderBy?: DifficultyOrderByWithRelationInput | DifficultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Difficulties.
     */
    cursor?: DifficultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Difficulties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Difficulties.
     */
    skip?: number
    distinct?: DifficultyScalarFieldEnum | DifficultyScalarFieldEnum[]
  }

  /**
   * Difficulty create
   */
  export type DifficultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifficultyInclude<ExtArgs> | null
    /**
     * The data needed to create a Difficulty.
     */
    data: XOR<DifficultyCreateInput, DifficultyUncheckedCreateInput>
  }

  /**
   * Difficulty createMany
   */
  export type DifficultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Difficulties.
     */
    data: DifficultyCreateManyInput | DifficultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Difficulty createManyAndReturn
   */
  export type DifficultyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * The data used to create many Difficulties.
     */
    data: DifficultyCreateManyInput | DifficultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Difficulty update
   */
  export type DifficultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifficultyInclude<ExtArgs> | null
    /**
     * The data needed to update a Difficulty.
     */
    data: XOR<DifficultyUpdateInput, DifficultyUncheckedUpdateInput>
    /**
     * Choose, which Difficulty to update.
     */
    where: DifficultyWhereUniqueInput
  }

  /**
   * Difficulty updateMany
   */
  export type DifficultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Difficulties.
     */
    data: XOR<DifficultyUpdateManyMutationInput, DifficultyUncheckedUpdateManyInput>
    /**
     * Filter which Difficulties to update
     */
    where?: DifficultyWhereInput
    /**
     * Limit how many Difficulties to update.
     */
    limit?: number
  }

  /**
   * Difficulty updateManyAndReturn
   */
  export type DifficultyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * The data used to update Difficulties.
     */
    data: XOR<DifficultyUpdateManyMutationInput, DifficultyUncheckedUpdateManyInput>
    /**
     * Filter which Difficulties to update
     */
    where?: DifficultyWhereInput
    /**
     * Limit how many Difficulties to update.
     */
    limit?: number
  }

  /**
   * Difficulty upsert
   */
  export type DifficultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifficultyInclude<ExtArgs> | null
    /**
     * The filter to search for the Difficulty to update in case it exists.
     */
    where: DifficultyWhereUniqueInput
    /**
     * In case the Difficulty found by the `where` argument doesn't exist, create a new Difficulty with this data.
     */
    create: XOR<DifficultyCreateInput, DifficultyUncheckedCreateInput>
    /**
     * In case the Difficulty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DifficultyUpdateInput, DifficultyUncheckedUpdateInput>
  }

  /**
   * Difficulty delete
   */
  export type DifficultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifficultyInclude<ExtArgs> | null
    /**
     * Filter which Difficulty to delete.
     */
    where: DifficultyWhereUniqueInput
  }

  /**
   * Difficulty deleteMany
   */
  export type DifficultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Difficulties to delete
     */
    where?: DifficultyWhereInput
    /**
     * Limit how many Difficulties to delete.
     */
    limit?: number
  }

  /**
   * Difficulty.questions
   */
  export type Difficulty$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Difficulty.quizSessions
   */
  export type Difficulty$quizSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    where?: QuizSessionWhereInput
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    cursor?: QuizSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * Difficulty without action
   */
  export type DifficultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Difficulty
     */
    select?: DifficultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Difficulty
     */
    omit?: DifficultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifficultyInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    text: string | null
    explanation: string | null
    imageUrl: string | null
    categoryId: string | null
    difficultyId: string | null
    status: $Enums.QuestionStatus | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    text: string | null
    explanation: string | null
    imageUrl: string | null
    categoryId: string | null
    difficultyId: string | null
    status: $Enums.QuestionStatus | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    text: number
    explanation: number
    imageUrl: number
    categoryId: number
    difficultyId: number
    status: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionMinAggregateInputType = {
    id?: true
    text?: true
    explanation?: true
    imageUrl?: true
    categoryId?: true
    difficultyId?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    text?: true
    explanation?: true
    imageUrl?: true
    categoryId?: true
    difficultyId?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    text?: true
    explanation?: true
    imageUrl?: true
    categoryId?: true
    difficultyId?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    text: string
    explanation: string
    imageUrl: string | null
    categoryId: string
    difficultyId: string
    status: $Enums.QuestionStatus
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    explanation?: boolean
    imageUrl?: boolean
    categoryId?: boolean
    difficultyId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    answers?: boolean | Question$answersArgs<ExtArgs>
    sessionAnswers?: boolean | Question$sessionAnswersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    explanation?: boolean
    imageUrl?: boolean
    categoryId?: boolean
    difficultyId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    explanation?: boolean
    imageUrl?: boolean
    categoryId?: boolean
    difficultyId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    text?: boolean
    explanation?: boolean
    imageUrl?: boolean
    categoryId?: boolean
    difficultyId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "explanation" | "imageUrl" | "categoryId" | "difficultyId" | "status" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["question"]>
  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    answers?: boolean | Question$answersArgs<ExtArgs>
    sessionAnswers?: boolean | Question$sessionAnswersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      difficulty: Prisma.$DifficultyPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      answers: Prisma.$AnswerPayload<ExtArgs>[]
      sessionAnswers: Prisma.$SessionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      explanation: string
      imageUrl: string | null
      categoryId: string
      difficultyId: string
      status: $Enums.QuestionStatus
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {QuestionUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    difficulty<T extends DifficultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DifficultyDefaultArgs<ExtArgs>>): Prisma__DifficultyClient<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends Question$answersArgs<ExtArgs> = {}>(args?: Subset<T, Question$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionAnswers<T extends Question$sessionAnswersArgs<ExtArgs> = {}>(args?: Subset<T, Question$sessionAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly text: FieldRef<"Question", 'String'>
    readonly explanation: FieldRef<"Question", 'String'>
    readonly imageUrl: FieldRef<"Question", 'String'>
    readonly categoryId: FieldRef<"Question", 'String'>
    readonly difficultyId: FieldRef<"Question", 'String'>
    readonly status: FieldRef<"Question", 'QuestionStatus'>
    readonly createdById: FieldRef<"Question", 'String'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
    readonly updatedAt: FieldRef<"Question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
  }

  /**
   * Question updateManyAndReturn
   */
  export type QuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to delete.
     */
    limit?: number
  }

  /**
   * Question.answers
   */
  export type Question$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    cursor?: AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Question.sessionAnswers
   */
  export type Question$sessionAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    where?: SessionAnswerWhereInput
    orderBy?: SessionAnswerOrderByWithRelationInput | SessionAnswerOrderByWithRelationInput[]
    cursor?: SessionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionAnswerScalarFieldEnum | SessionAnswerScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Answer
   */

  export type AggregateAnswer = {
    _count: AnswerCountAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  export type AnswerMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    text: string | null
    isCorrect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnswerMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    text: string | null
    isCorrect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnswerCountAggregateOutputType = {
    id: number
    questionId: number
    text: number
    isCorrect: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnswerMinAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnswerMaxAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnswerCountAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answer to aggregate.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswerMaxAggregateInputType
  }

  export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer[P]>
      : GetScalarType<T[P], AggregateAnswer[P]>
  }




  export type AnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithAggregationInput | AnswerOrderByWithAggregationInput[]
    by: AnswerScalarFieldEnum[] | AnswerScalarFieldEnum
    having?: AnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswerCountAggregateInputType | true
    _min?: AnswerMinAggregateInputType
    _max?: AnswerMaxAggregateInputType
  }

  export type AnswerGroupByOutputType = {
    id: string
    questionId: string
    text: string
    isCorrect: boolean
    createdAt: Date
    updatedAt: Date
    _count: AnswerCountAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerGroupByOutputType[P]>
        }
      >
    >


  export type AnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    sessionAnswers?: boolean | Answer$sessionAnswersArgs<ExtArgs>
    _count?: boolean | AnswerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectScalar = {
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "text" | "isCorrect" | "createdAt" | "updatedAt", ExtArgs["result"]["answer"]>
  export type AnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    sessionAnswers?: boolean | Answer$sessionAnswersArgs<ExtArgs>
    _count?: boolean | AnswerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type AnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $AnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Answer"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
      sessionAnswers: Prisma.$SessionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      text: string
      isCorrect: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["answer"]>
    composites: {}
  }

  type AnswerGetPayload<S extends boolean | null | undefined | AnswerDefaultArgs> = $Result.GetResult<Prisma.$AnswerPayload, S>

  type AnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnswerCountAggregateInputType | true
    }

  export interface AnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Answer'], meta: { name: 'Answer' } }
    /**
     * Find zero or one Answer that matches the filter.
     * @param {AnswerFindUniqueArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnswerFindUniqueArgs>(args: SelectSubset<T, AnswerFindUniqueArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Answer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnswerFindUniqueOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, AnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnswerFindFirstArgs>(args?: SelectSubset<T, AnswerFindFirstArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, AnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answer.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnswerFindManyArgs>(args?: SelectSubset<T, AnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Answer.
     * @param {AnswerCreateArgs} args - Arguments to create a Answer.
     * @example
     * // Create one Answer
     * const Answer = await prisma.answer.create({
     *   data: {
     *     // ... data to create a Answer
     *   }
     * })
     * 
     */
    create<T extends AnswerCreateArgs>(args: SelectSubset<T, AnswerCreateArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Answers.
     * @param {AnswerCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answer = await prisma.answer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnswerCreateManyArgs>(args?: SelectSubset<T, AnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Answers and returns the data saved in the database.
     * @param {AnswerCreateManyAndReturnArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answer = await prisma.answer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Answers and only return the `id`
     * const answerWithIdOnly = await prisma.answer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, AnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Answer.
     * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
     * @example
     * // Delete one Answer
     * const Answer = await prisma.answer.delete({
     *   where: {
     *     // ... filter to delete one Answer
     *   }
     * })
     * 
     */
    delete<T extends AnswerDeleteArgs>(args: SelectSubset<T, AnswerDeleteArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Answer.
     * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
     * @example
     * // Update one Answer
     * const answer = await prisma.answer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnswerUpdateArgs>(args: SelectSubset<T, AnswerUpdateArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Answers.
     * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnswerDeleteManyArgs>(args?: SelectSubset<T, AnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnswerUpdateManyArgs>(args: SelectSubset<T, AnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers and returns the data updated in the database.
     * @param {AnswerUpdateManyAndReturnArgs} args - Arguments to update many Answers.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Answers and only return the `id`
     * const answerWithIdOnly = await prisma.answer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, AnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Answer.
     * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
     * @example
     * // Update or create a Answer
     * const answer = await prisma.answer.upsert({
     *   create: {
     *     // ... data to create a Answer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer we want to update
     *   }
     * })
     */
    upsert<T extends AnswerUpsertArgs>(args: SelectSubset<T, AnswerUpsertArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answer.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswerCountArgs>(
      args?: Subset<T, AnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswerAggregateArgs>(args: Subset<T, AnswerAggregateArgs>): Prisma.PrismaPromise<GetAnswerAggregateType<T>>

    /**
     * Group by Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerGroupByArgs['orderBy'] }
        : { orderBy?: AnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Answer model
   */
  readonly fields: AnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessionAnswers<T extends Answer$sessionAnswersArgs<ExtArgs> = {}>(args?: Subset<T, Answer$sessionAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Answer model
   */
  interface AnswerFieldRefs {
    readonly id: FieldRef<"Answer", 'String'>
    readonly questionId: FieldRef<"Answer", 'String'>
    readonly text: FieldRef<"Answer", 'String'>
    readonly isCorrect: FieldRef<"Answer", 'Boolean'>
    readonly createdAt: FieldRef<"Answer", 'DateTime'>
    readonly updatedAt: FieldRef<"Answer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Answer findUnique
   */
  export type AnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer findUniqueOrThrow
   */
  export type AnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer findFirst
   */
  export type AnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer findFirstOrThrow
   */
  export type AnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer findMany
   */
  export type AnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer create
   */
  export type AnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a Answer.
     */
    data: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
  }

  /**
   * Answer createMany
   */
  export type AnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Answer createManyAndReturn
   */
  export type AnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answer update
   */
  export type AnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a Answer.
     */
    data: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
    /**
     * Choose, which Answer to update.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer updateMany
   */
  export type AnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to update.
     */
    limit?: number
  }

  /**
   * Answer updateManyAndReturn
   */
  export type AnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answer upsert
   */
  export type AnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the Answer to update in case it exists.
     */
    where: AnswerWhereUniqueInput
    /**
     * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
     */
    create: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
    /**
     * In case the Answer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
  }

  /**
   * Answer delete
   */
  export type AnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter which Answer to delete.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer deleteMany
   */
  export type AnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to delete
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to delete.
     */
    limit?: number
  }

  /**
   * Answer.sessionAnswers
   */
  export type Answer$sessionAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    where?: SessionAnswerWhereInput
    orderBy?: SessionAnswerOrderByWithRelationInput | SessionAnswerOrderByWithRelationInput[]
    cursor?: SessionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionAnswerScalarFieldEnum | SessionAnswerScalarFieldEnum[]
  }

  /**
   * Answer without action
   */
  export type AnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
  }


  /**
   * Model QuizSession
   */

  export type AggregateQuizSession = {
    _count: QuizSessionCountAggregateOutputType | null
    _avg: QuizSessionAvgAggregateOutputType | null
    _sum: QuizSessionSumAggregateOutputType | null
    _min: QuizSessionMinAggregateOutputType | null
    _max: QuizSessionMaxAggregateOutputType | null
  }

  export type QuizSessionAvgAggregateOutputType = {
    score: number | null
  }

  export type QuizSessionSumAggregateOutputType = {
    score: number | null
  }

  export type QuizSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    categoryId: string | null
    difficultyId: string | null
    status: $Enums.SessionStatus | null
    score: number | null
    startedAt: Date | null
    completedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    categoryId: string | null
    difficultyId: string | null
    status: $Enums.SessionStatus | null
    score: number | null
    startedAt: Date | null
    completedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizSessionCountAggregateOutputType = {
    id: number
    userId: number
    categoryId: number
    difficultyId: number
    status: number
    score: number
    startedAt: number
    completedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizSessionAvgAggregateInputType = {
    score?: true
  }

  export type QuizSessionSumAggregateInputType = {
    score?: true
  }

  export type QuizSessionMinAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    difficultyId?: true
    status?: true
    score?: true
    startedAt?: true
    completedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    difficultyId?: true
    status?: true
    score?: true
    startedAt?: true
    completedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizSessionCountAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    difficultyId?: true
    status?: true
    score?: true
    startedAt?: true
    completedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizSession to aggregate.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizSessions
    **/
    _count?: true | QuizSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizSessionMaxAggregateInputType
  }

  export type GetQuizSessionAggregateType<T extends QuizSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizSession[P]>
      : GetScalarType<T[P], AggregateQuizSession[P]>
  }




  export type QuizSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSessionWhereInput
    orderBy?: QuizSessionOrderByWithAggregationInput | QuizSessionOrderByWithAggregationInput[]
    by: QuizSessionScalarFieldEnum[] | QuizSessionScalarFieldEnum
    having?: QuizSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizSessionCountAggregateInputType | true
    _avg?: QuizSessionAvgAggregateInputType
    _sum?: QuizSessionSumAggregateInputType
    _min?: QuizSessionMinAggregateInputType
    _max?: QuizSessionMaxAggregateInputType
  }

  export type QuizSessionGroupByOutputType = {
    id: string
    userId: string
    categoryId: string | null
    difficultyId: string
    status: $Enums.SessionStatus
    score: number
    startedAt: Date
    completedAt: Date | null
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: QuizSessionCountAggregateOutputType | null
    _avg: QuizSessionAvgAggregateOutputType | null
    _sum: QuizSessionSumAggregateOutputType | null
    _min: QuizSessionMinAggregateOutputType | null
    _max: QuizSessionMaxAggregateOutputType | null
  }

  type GetQuizSessionGroupByPayload<T extends QuizSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizSessionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizSessionGroupByOutputType[P]>
        }
      >
    >


  export type QuizSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    difficultyId?: boolean
    status?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
    answers?: boolean | QuizSession$answersArgs<ExtArgs>
    _count?: boolean | QuizSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSession"]>

  export type QuizSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    difficultyId?: boolean
    status?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSession"]>

  export type QuizSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    difficultyId?: boolean
    status?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSession"]>

  export type QuizSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    difficultyId?: boolean
    status?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuizSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "categoryId" | "difficultyId" | "status" | "score" | "startedAt" | "completedAt" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["quizSession"]>
  export type QuizSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
    answers?: boolean | QuizSession$answersArgs<ExtArgs>
    _count?: boolean | QuizSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
  }
  export type QuizSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    difficulty?: boolean | DifficultyDefaultArgs<ExtArgs>
  }

  export type $QuizSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      difficulty: Prisma.$DifficultyPayload<ExtArgs>
      answers: Prisma.$SessionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      categoryId: string | null
      difficultyId: string
      status: $Enums.SessionStatus
      score: number
      startedAt: Date
      completedAt: Date | null
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quizSession"]>
    composites: {}
  }

  type QuizSessionGetPayload<S extends boolean | null | undefined | QuizSessionDefaultArgs> = $Result.GetResult<Prisma.$QuizSessionPayload, S>

  type QuizSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizSessionCountAggregateInputType | true
    }

  export interface QuizSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizSession'], meta: { name: 'QuizSession' } }
    /**
     * Find zero or one QuizSession that matches the filter.
     * @param {QuizSessionFindUniqueArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizSessionFindUniqueArgs>(args: SelectSubset<T, QuizSessionFindUniqueArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizSessionFindUniqueOrThrowArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionFindFirstArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizSessionFindFirstArgs>(args?: SelectSubset<T, QuizSessionFindFirstArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionFindFirstOrThrowArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizSessions
     * const quizSessions = await prisma.quizSession.findMany()
     * 
     * // Get first 10 QuizSessions
     * const quizSessions = await prisma.quizSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizSessionWithIdOnly = await prisma.quizSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizSessionFindManyArgs>(args?: SelectSubset<T, QuizSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizSession.
     * @param {QuizSessionCreateArgs} args - Arguments to create a QuizSession.
     * @example
     * // Create one QuizSession
     * const QuizSession = await prisma.quizSession.create({
     *   data: {
     *     // ... data to create a QuizSession
     *   }
     * })
     * 
     */
    create<T extends QuizSessionCreateArgs>(args: SelectSubset<T, QuizSessionCreateArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizSessions.
     * @param {QuizSessionCreateManyArgs} args - Arguments to create many QuizSessions.
     * @example
     * // Create many QuizSessions
     * const quizSession = await prisma.quizSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizSessionCreateManyArgs>(args?: SelectSubset<T, QuizSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizSessions and returns the data saved in the database.
     * @param {QuizSessionCreateManyAndReturnArgs} args - Arguments to create many QuizSessions.
     * @example
     * // Create many QuizSessions
     * const quizSession = await prisma.quizSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizSessions and only return the `id`
     * const quizSessionWithIdOnly = await prisma.quizSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizSession.
     * @param {QuizSessionDeleteArgs} args - Arguments to delete one QuizSession.
     * @example
     * // Delete one QuizSession
     * const QuizSession = await prisma.quizSession.delete({
     *   where: {
     *     // ... filter to delete one QuizSession
     *   }
     * })
     * 
     */
    delete<T extends QuizSessionDeleteArgs>(args: SelectSubset<T, QuizSessionDeleteArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizSession.
     * @param {QuizSessionUpdateArgs} args - Arguments to update one QuizSession.
     * @example
     * // Update one QuizSession
     * const quizSession = await prisma.quizSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizSessionUpdateArgs>(args: SelectSubset<T, QuizSessionUpdateArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizSessions.
     * @param {QuizSessionDeleteManyArgs} args - Arguments to filter QuizSessions to delete.
     * @example
     * // Delete a few QuizSessions
     * const { count } = await prisma.quizSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizSessionDeleteManyArgs>(args?: SelectSubset<T, QuizSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizSessions
     * const quizSession = await prisma.quizSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizSessionUpdateManyArgs>(args: SelectSubset<T, QuizSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizSessions and returns the data updated in the database.
     * @param {QuizSessionUpdateManyAndReturnArgs} args - Arguments to update many QuizSessions.
     * @example
     * // Update many QuizSessions
     * const quizSession = await prisma.quizSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizSessions and only return the `id`
     * const quizSessionWithIdOnly = await prisma.quizSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizSession.
     * @param {QuizSessionUpsertArgs} args - Arguments to update or create a QuizSession.
     * @example
     * // Update or create a QuizSession
     * const quizSession = await prisma.quizSession.upsert({
     *   create: {
     *     // ... data to create a QuizSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizSession we want to update
     *   }
     * })
     */
    upsert<T extends QuizSessionUpsertArgs>(args: SelectSubset<T, QuizSessionUpsertArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionCountArgs} args - Arguments to filter QuizSessions to count.
     * @example
     * // Count the number of QuizSessions
     * const count = await prisma.quizSession.count({
     *   where: {
     *     // ... the filter for the QuizSessions we want to count
     *   }
     * })
    **/
    count<T extends QuizSessionCountArgs>(
      args?: Subset<T, QuizSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizSessionAggregateArgs>(args: Subset<T, QuizSessionAggregateArgs>): Prisma.PrismaPromise<GetQuizSessionAggregateType<T>>

    /**
     * Group by QuizSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizSessionGroupByArgs['orderBy'] }
        : { orderBy?: QuizSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizSession model
   */
  readonly fields: QuizSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    difficulty<T extends DifficultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DifficultyDefaultArgs<ExtArgs>>): Prisma__DifficultyClient<$Result.GetResult<Prisma.$DifficultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends QuizSession$answersArgs<ExtArgs> = {}>(args?: Subset<T, QuizSession$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizSession model
   */
  interface QuizSessionFieldRefs {
    readonly id: FieldRef<"QuizSession", 'String'>
    readonly userId: FieldRef<"QuizSession", 'String'>
    readonly categoryId: FieldRef<"QuizSession", 'String'>
    readonly difficultyId: FieldRef<"QuizSession", 'String'>
    readonly status: FieldRef<"QuizSession", 'SessionStatus'>
    readonly score: FieldRef<"QuizSession", 'Int'>
    readonly startedAt: FieldRef<"QuizSession", 'DateTime'>
    readonly completedAt: FieldRef<"QuizSession", 'DateTime'>
    readonly expiresAt: FieldRef<"QuizSession", 'DateTime'>
    readonly createdAt: FieldRef<"QuizSession", 'DateTime'>
    readonly updatedAt: FieldRef<"QuizSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizSession findUnique
   */
  export type QuizSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession findUniqueOrThrow
   */
  export type QuizSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession findFirst
   */
  export type QuizSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizSessions.
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizSessions.
     */
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * QuizSession findFirstOrThrow
   */
  export type QuizSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizSessions.
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizSessions.
     */
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * QuizSession findMany
   */
  export type QuizSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSessions to fetch.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizSessions.
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * QuizSession create
   */
  export type QuizSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizSession.
     */
    data: XOR<QuizSessionCreateInput, QuizSessionUncheckedCreateInput>
  }

  /**
   * QuizSession createMany
   */
  export type QuizSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizSessions.
     */
    data: QuizSessionCreateManyInput | QuizSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizSession createManyAndReturn
   */
  export type QuizSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizSessions.
     */
    data: QuizSessionCreateManyInput | QuizSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizSession update
   */
  export type QuizSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizSession.
     */
    data: XOR<QuizSessionUpdateInput, QuizSessionUncheckedUpdateInput>
    /**
     * Choose, which QuizSession to update.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession updateMany
   */
  export type QuizSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizSessions.
     */
    data: XOR<QuizSessionUpdateManyMutationInput, QuizSessionUncheckedUpdateManyInput>
    /**
     * Filter which QuizSessions to update
     */
    where?: QuizSessionWhereInput
    /**
     * Limit how many QuizSessions to update.
     */
    limit?: number
  }

  /**
   * QuizSession updateManyAndReturn
   */
  export type QuizSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * The data used to update QuizSessions.
     */
    data: XOR<QuizSessionUpdateManyMutationInput, QuizSessionUncheckedUpdateManyInput>
    /**
     * Filter which QuizSessions to update
     */
    where?: QuizSessionWhereInput
    /**
     * Limit how many QuizSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizSession upsert
   */
  export type QuizSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizSession to update in case it exists.
     */
    where: QuizSessionWhereUniqueInput
    /**
     * In case the QuizSession found by the `where` argument doesn't exist, create a new QuizSession with this data.
     */
    create: XOR<QuizSessionCreateInput, QuizSessionUncheckedCreateInput>
    /**
     * In case the QuizSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizSessionUpdateInput, QuizSessionUncheckedUpdateInput>
  }

  /**
   * QuizSession delete
   */
  export type QuizSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter which QuizSession to delete.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession deleteMany
   */
  export type QuizSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizSessions to delete
     */
    where?: QuizSessionWhereInput
    /**
     * Limit how many QuizSessions to delete.
     */
    limit?: number
  }

  /**
   * QuizSession.answers
   */
  export type QuizSession$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    where?: SessionAnswerWhereInput
    orderBy?: SessionAnswerOrderByWithRelationInput | SessionAnswerOrderByWithRelationInput[]
    cursor?: SessionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionAnswerScalarFieldEnum | SessionAnswerScalarFieldEnum[]
  }

  /**
   * QuizSession without action
   */
  export type QuizSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
  }


  /**
   * Model SessionAnswer
   */

  export type AggregateSessionAnswer = {
    _count: SessionAnswerCountAggregateOutputType | null
    _avg: SessionAnswerAvgAggregateOutputType | null
    _sum: SessionAnswerSumAggregateOutputType | null
    _min: SessionAnswerMinAggregateOutputType | null
    _max: SessionAnswerMaxAggregateOutputType | null
  }

  export type SessionAnswerAvgAggregateOutputType = {
    timeSpent: number | null
    pointsEarned: number | null
    timeBonus: number | null
  }

  export type SessionAnswerSumAggregateOutputType = {
    timeSpent: number | null
    pointsEarned: number | null
    timeBonus: number | null
  }

  export type SessionAnswerMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    questionId: string | null
    answerId: string | null
    isCorrect: boolean | null
    timeSpent: number | null
    pointsEarned: number | null
    timeBonus: number | null
    answeredAt: Date | null
  }

  export type SessionAnswerMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    questionId: string | null
    answerId: string | null
    isCorrect: boolean | null
    timeSpent: number | null
    pointsEarned: number | null
    timeBonus: number | null
    answeredAt: Date | null
  }

  export type SessionAnswerCountAggregateOutputType = {
    id: number
    sessionId: number
    questionId: number
    answerId: number
    isCorrect: number
    timeSpent: number
    pointsEarned: number
    timeBonus: number
    answeredAt: number
    _all: number
  }


  export type SessionAnswerAvgAggregateInputType = {
    timeSpent?: true
    pointsEarned?: true
    timeBonus?: true
  }

  export type SessionAnswerSumAggregateInputType = {
    timeSpent?: true
    pointsEarned?: true
    timeBonus?: true
  }

  export type SessionAnswerMinAggregateInputType = {
    id?: true
    sessionId?: true
    questionId?: true
    answerId?: true
    isCorrect?: true
    timeSpent?: true
    pointsEarned?: true
    timeBonus?: true
    answeredAt?: true
  }

  export type SessionAnswerMaxAggregateInputType = {
    id?: true
    sessionId?: true
    questionId?: true
    answerId?: true
    isCorrect?: true
    timeSpent?: true
    pointsEarned?: true
    timeBonus?: true
    answeredAt?: true
  }

  export type SessionAnswerCountAggregateInputType = {
    id?: true
    sessionId?: true
    questionId?: true
    answerId?: true
    isCorrect?: true
    timeSpent?: true
    pointsEarned?: true
    timeBonus?: true
    answeredAt?: true
    _all?: true
  }

  export type SessionAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionAnswer to aggregate.
     */
    where?: SessionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionAnswers to fetch.
     */
    orderBy?: SessionAnswerOrderByWithRelationInput | SessionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionAnswers
    **/
    _count?: true | SessionAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionAnswerMaxAggregateInputType
  }

  export type GetSessionAnswerAggregateType<T extends SessionAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionAnswer[P]>
      : GetScalarType<T[P], AggregateSessionAnswer[P]>
  }




  export type SessionAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionAnswerWhereInput
    orderBy?: SessionAnswerOrderByWithAggregationInput | SessionAnswerOrderByWithAggregationInput[]
    by: SessionAnswerScalarFieldEnum[] | SessionAnswerScalarFieldEnum
    having?: SessionAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionAnswerCountAggregateInputType | true
    _avg?: SessionAnswerAvgAggregateInputType
    _sum?: SessionAnswerSumAggregateInputType
    _min?: SessionAnswerMinAggregateInputType
    _max?: SessionAnswerMaxAggregateInputType
  }

  export type SessionAnswerGroupByOutputType = {
    id: string
    sessionId: string
    questionId: string
    answerId: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus: number
    answeredAt: Date
    _count: SessionAnswerCountAggregateOutputType | null
    _avg: SessionAnswerAvgAggregateOutputType | null
    _sum: SessionAnswerSumAggregateOutputType | null
    _min: SessionAnswerMinAggregateOutputType | null
    _max: SessionAnswerMaxAggregateOutputType | null
  }

  type GetSessionAnswerGroupByPayload<T extends SessionAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], SessionAnswerGroupByOutputType[P]>
        }
      >
    >


  export type SessionAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    questionId?: boolean
    answerId?: boolean
    isCorrect?: boolean
    timeSpent?: boolean
    pointsEarned?: boolean
    timeBonus?: boolean
    answeredAt?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    answer?: boolean | AnswerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionAnswer"]>

  export type SessionAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    questionId?: boolean
    answerId?: boolean
    isCorrect?: boolean
    timeSpent?: boolean
    pointsEarned?: boolean
    timeBonus?: boolean
    answeredAt?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    answer?: boolean | AnswerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionAnswer"]>

  export type SessionAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    questionId?: boolean
    answerId?: boolean
    isCorrect?: boolean
    timeSpent?: boolean
    pointsEarned?: boolean
    timeBonus?: boolean
    answeredAt?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    answer?: boolean | AnswerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionAnswer"]>

  export type SessionAnswerSelectScalar = {
    id?: boolean
    sessionId?: boolean
    questionId?: boolean
    answerId?: boolean
    isCorrect?: boolean
    timeSpent?: boolean
    pointsEarned?: boolean
    timeBonus?: boolean
    answeredAt?: boolean
  }

  export type SessionAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "questionId" | "answerId" | "isCorrect" | "timeSpent" | "pointsEarned" | "timeBonus" | "answeredAt", ExtArgs["result"]["sessionAnswer"]>
  export type SessionAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    answer?: boolean | AnswerDefaultArgs<ExtArgs>
  }
  export type SessionAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    answer?: boolean | AnswerDefaultArgs<ExtArgs>
  }
  export type SessionAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    answer?: boolean | AnswerDefaultArgs<ExtArgs>
  }

  export type $SessionAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionAnswer"
    objects: {
      session: Prisma.$QuizSessionPayload<ExtArgs>
      question: Prisma.$QuestionPayload<ExtArgs>
      answer: Prisma.$AnswerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      questionId: string
      answerId: string
      isCorrect: boolean
      timeSpent: number
      pointsEarned: number
      timeBonus: number
      answeredAt: Date
    }, ExtArgs["result"]["sessionAnswer"]>
    composites: {}
  }

  type SessionAnswerGetPayload<S extends boolean | null | undefined | SessionAnswerDefaultArgs> = $Result.GetResult<Prisma.$SessionAnswerPayload, S>

  type SessionAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionAnswerCountAggregateInputType | true
    }

  export interface SessionAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionAnswer'], meta: { name: 'SessionAnswer' } }
    /**
     * Find zero or one SessionAnswer that matches the filter.
     * @param {SessionAnswerFindUniqueArgs} args - Arguments to find a SessionAnswer
     * @example
     * // Get one SessionAnswer
     * const sessionAnswer = await prisma.sessionAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionAnswerFindUniqueArgs>(args: SelectSubset<T, SessionAnswerFindUniqueArgs<ExtArgs>>): Prisma__SessionAnswerClient<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionAnswerFindUniqueOrThrowArgs} args - Arguments to find a SessionAnswer
     * @example
     * // Get one SessionAnswer
     * const sessionAnswer = await prisma.sessionAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionAnswerClient<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAnswerFindFirstArgs} args - Arguments to find a SessionAnswer
     * @example
     * // Get one SessionAnswer
     * const sessionAnswer = await prisma.sessionAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionAnswerFindFirstArgs>(args?: SelectSubset<T, SessionAnswerFindFirstArgs<ExtArgs>>): Prisma__SessionAnswerClient<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAnswerFindFirstOrThrowArgs} args - Arguments to find a SessionAnswer
     * @example
     * // Get one SessionAnswer
     * const sessionAnswer = await prisma.sessionAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionAnswerClient<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionAnswers
     * const sessionAnswers = await prisma.sessionAnswer.findMany()
     * 
     * // Get first 10 SessionAnswers
     * const sessionAnswers = await prisma.sessionAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionAnswerWithIdOnly = await prisma.sessionAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionAnswerFindManyArgs>(args?: SelectSubset<T, SessionAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionAnswer.
     * @param {SessionAnswerCreateArgs} args - Arguments to create a SessionAnswer.
     * @example
     * // Create one SessionAnswer
     * const SessionAnswer = await prisma.sessionAnswer.create({
     *   data: {
     *     // ... data to create a SessionAnswer
     *   }
     * })
     * 
     */
    create<T extends SessionAnswerCreateArgs>(args: SelectSubset<T, SessionAnswerCreateArgs<ExtArgs>>): Prisma__SessionAnswerClient<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionAnswers.
     * @param {SessionAnswerCreateManyArgs} args - Arguments to create many SessionAnswers.
     * @example
     * // Create many SessionAnswers
     * const sessionAnswer = await prisma.sessionAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionAnswerCreateManyArgs>(args?: SelectSubset<T, SessionAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionAnswers and returns the data saved in the database.
     * @param {SessionAnswerCreateManyAndReturnArgs} args - Arguments to create many SessionAnswers.
     * @example
     * // Create many SessionAnswers
     * const sessionAnswer = await prisma.sessionAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionAnswers and only return the `id`
     * const sessionAnswerWithIdOnly = await prisma.sessionAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionAnswer.
     * @param {SessionAnswerDeleteArgs} args - Arguments to delete one SessionAnswer.
     * @example
     * // Delete one SessionAnswer
     * const SessionAnswer = await prisma.sessionAnswer.delete({
     *   where: {
     *     // ... filter to delete one SessionAnswer
     *   }
     * })
     * 
     */
    delete<T extends SessionAnswerDeleteArgs>(args: SelectSubset<T, SessionAnswerDeleteArgs<ExtArgs>>): Prisma__SessionAnswerClient<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionAnswer.
     * @param {SessionAnswerUpdateArgs} args - Arguments to update one SessionAnswer.
     * @example
     * // Update one SessionAnswer
     * const sessionAnswer = await prisma.sessionAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionAnswerUpdateArgs>(args: SelectSubset<T, SessionAnswerUpdateArgs<ExtArgs>>): Prisma__SessionAnswerClient<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionAnswers.
     * @param {SessionAnswerDeleteManyArgs} args - Arguments to filter SessionAnswers to delete.
     * @example
     * // Delete a few SessionAnswers
     * const { count } = await prisma.sessionAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionAnswerDeleteManyArgs>(args?: SelectSubset<T, SessionAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionAnswers
     * const sessionAnswer = await prisma.sessionAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionAnswerUpdateManyArgs>(args: SelectSubset<T, SessionAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionAnswers and returns the data updated in the database.
     * @param {SessionAnswerUpdateManyAndReturnArgs} args - Arguments to update many SessionAnswers.
     * @example
     * // Update many SessionAnswers
     * const sessionAnswer = await prisma.sessionAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionAnswers and only return the `id`
     * const sessionAnswerWithIdOnly = await prisma.sessionAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionAnswer.
     * @param {SessionAnswerUpsertArgs} args - Arguments to update or create a SessionAnswer.
     * @example
     * // Update or create a SessionAnswer
     * const sessionAnswer = await prisma.sessionAnswer.upsert({
     *   create: {
     *     // ... data to create a SessionAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionAnswer we want to update
     *   }
     * })
     */
    upsert<T extends SessionAnswerUpsertArgs>(args: SelectSubset<T, SessionAnswerUpsertArgs<ExtArgs>>): Prisma__SessionAnswerClient<$Result.GetResult<Prisma.$SessionAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAnswerCountArgs} args - Arguments to filter SessionAnswers to count.
     * @example
     * // Count the number of SessionAnswers
     * const count = await prisma.sessionAnswer.count({
     *   where: {
     *     // ... the filter for the SessionAnswers we want to count
     *   }
     * })
    **/
    count<T extends SessionAnswerCountArgs>(
      args?: Subset<T, SessionAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAnswerAggregateArgs>(args: Subset<T, SessionAnswerAggregateArgs>): Prisma.PrismaPromise<GetSessionAnswerAggregateType<T>>

    /**
     * Group by SessionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionAnswerGroupByArgs['orderBy'] }
        : { orderBy?: SessionAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionAnswer model
   */
  readonly fields: SessionAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends QuizSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizSessionDefaultArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answer<T extends AnswerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnswerDefaultArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionAnswer model
   */
  interface SessionAnswerFieldRefs {
    readonly id: FieldRef<"SessionAnswer", 'String'>
    readonly sessionId: FieldRef<"SessionAnswer", 'String'>
    readonly questionId: FieldRef<"SessionAnswer", 'String'>
    readonly answerId: FieldRef<"SessionAnswer", 'String'>
    readonly isCorrect: FieldRef<"SessionAnswer", 'Boolean'>
    readonly timeSpent: FieldRef<"SessionAnswer", 'Int'>
    readonly pointsEarned: FieldRef<"SessionAnswer", 'Int'>
    readonly timeBonus: FieldRef<"SessionAnswer", 'Int'>
    readonly answeredAt: FieldRef<"SessionAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionAnswer findUnique
   */
  export type SessionAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SessionAnswer to fetch.
     */
    where: SessionAnswerWhereUniqueInput
  }

  /**
   * SessionAnswer findUniqueOrThrow
   */
  export type SessionAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SessionAnswer to fetch.
     */
    where: SessionAnswerWhereUniqueInput
  }

  /**
   * SessionAnswer findFirst
   */
  export type SessionAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SessionAnswer to fetch.
     */
    where?: SessionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionAnswers to fetch.
     */
    orderBy?: SessionAnswerOrderByWithRelationInput | SessionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionAnswers.
     */
    cursor?: SessionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionAnswers.
     */
    distinct?: SessionAnswerScalarFieldEnum | SessionAnswerScalarFieldEnum[]
  }

  /**
   * SessionAnswer findFirstOrThrow
   */
  export type SessionAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SessionAnswer to fetch.
     */
    where?: SessionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionAnswers to fetch.
     */
    orderBy?: SessionAnswerOrderByWithRelationInput | SessionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionAnswers.
     */
    cursor?: SessionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionAnswers.
     */
    distinct?: SessionAnswerScalarFieldEnum | SessionAnswerScalarFieldEnum[]
  }

  /**
   * SessionAnswer findMany
   */
  export type SessionAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SessionAnswers to fetch.
     */
    where?: SessionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionAnswers to fetch.
     */
    orderBy?: SessionAnswerOrderByWithRelationInput | SessionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionAnswers.
     */
    cursor?: SessionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionAnswers.
     */
    skip?: number
    distinct?: SessionAnswerScalarFieldEnum | SessionAnswerScalarFieldEnum[]
  }

  /**
   * SessionAnswer create
   */
  export type SessionAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionAnswer.
     */
    data: XOR<SessionAnswerCreateInput, SessionAnswerUncheckedCreateInput>
  }

  /**
   * SessionAnswer createMany
   */
  export type SessionAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionAnswers.
     */
    data: SessionAnswerCreateManyInput | SessionAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionAnswer createManyAndReturn
   */
  export type SessionAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many SessionAnswers.
     */
    data: SessionAnswerCreateManyInput | SessionAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionAnswer update
   */
  export type SessionAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionAnswer.
     */
    data: XOR<SessionAnswerUpdateInput, SessionAnswerUncheckedUpdateInput>
    /**
     * Choose, which SessionAnswer to update.
     */
    where: SessionAnswerWhereUniqueInput
  }

  /**
   * SessionAnswer updateMany
   */
  export type SessionAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionAnswers.
     */
    data: XOR<SessionAnswerUpdateManyMutationInput, SessionAnswerUncheckedUpdateManyInput>
    /**
     * Filter which SessionAnswers to update
     */
    where?: SessionAnswerWhereInput
    /**
     * Limit how many SessionAnswers to update.
     */
    limit?: number
  }

  /**
   * SessionAnswer updateManyAndReturn
   */
  export type SessionAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * The data used to update SessionAnswers.
     */
    data: XOR<SessionAnswerUpdateManyMutationInput, SessionAnswerUncheckedUpdateManyInput>
    /**
     * Filter which SessionAnswers to update
     */
    where?: SessionAnswerWhereInput
    /**
     * Limit how many SessionAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionAnswer upsert
   */
  export type SessionAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionAnswer to update in case it exists.
     */
    where: SessionAnswerWhereUniqueInput
    /**
     * In case the SessionAnswer found by the `where` argument doesn't exist, create a new SessionAnswer with this data.
     */
    create: XOR<SessionAnswerCreateInput, SessionAnswerUncheckedCreateInput>
    /**
     * In case the SessionAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionAnswerUpdateInput, SessionAnswerUncheckedUpdateInput>
  }

  /**
   * SessionAnswer delete
   */
  export type SessionAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
    /**
     * Filter which SessionAnswer to delete.
     */
    where: SessionAnswerWhereUniqueInput
  }

  /**
   * SessionAnswer deleteMany
   */
  export type SessionAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionAnswers to delete
     */
    where?: SessionAnswerWhereInput
    /**
     * Limit how many SessionAnswers to delete.
     */
    limit?: number
  }

  /**
   * SessionAnswer without action
   */
  export type SessionAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAnswer
     */
    select?: SessionAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAnswer
     */
    omit?: SessionAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAnswerInclude<ExtArgs> | null
  }


  /**
   * Model PlayerProgress
   */

  export type AggregatePlayerProgress = {
    _count: PlayerProgressCountAggregateOutputType | null
    _avg: PlayerProgressAvgAggregateOutputType | null
    _sum: PlayerProgressSumAggregateOutputType | null
    _min: PlayerProgressMinAggregateOutputType | null
    _max: PlayerProgressMaxAggregateOutputType | null
  }

  export type PlayerProgressAvgAggregateOutputType = {
    currentXP: number | null
    currentLevel: number | null
    currentStreak: number | null
    longestStreak: number | null
    totalQuizzes: number | null
    perfectQuizzes: number | null
    totalCorrect: number | null
    totalAnswers: number | null
  }

  export type PlayerProgressSumAggregateOutputType = {
    currentXP: number | null
    currentLevel: number | null
    currentStreak: number | null
    longestStreak: number | null
    totalQuizzes: number | null
    perfectQuizzes: number | null
    totalCorrect: number | null
    totalAnswers: number | null
  }

  export type PlayerProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentXP: number | null
    currentLevel: number | null
    currentStreak: number | null
    longestStreak: number | null
    totalQuizzes: number | null
    perfectQuizzes: number | null
    totalCorrect: number | null
    totalAnswers: number | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentXP: number | null
    currentLevel: number | null
    currentStreak: number | null
    longestStreak: number | null
    totalQuizzes: number | null
    perfectQuizzes: number | null
    totalCorrect: number | null
    totalAnswers: number | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerProgressCountAggregateOutputType = {
    id: number
    userId: number
    currentXP: number
    currentLevel: number
    currentStreak: number
    longestStreak: number
    totalQuizzes: number
    perfectQuizzes: number
    totalCorrect: number
    totalAnswers: number
    lastPlayedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerProgressAvgAggregateInputType = {
    currentXP?: true
    currentLevel?: true
    currentStreak?: true
    longestStreak?: true
    totalQuizzes?: true
    perfectQuizzes?: true
    totalCorrect?: true
    totalAnswers?: true
  }

  export type PlayerProgressSumAggregateInputType = {
    currentXP?: true
    currentLevel?: true
    currentStreak?: true
    longestStreak?: true
    totalQuizzes?: true
    perfectQuizzes?: true
    totalCorrect?: true
    totalAnswers?: true
  }

  export type PlayerProgressMinAggregateInputType = {
    id?: true
    userId?: true
    currentXP?: true
    currentLevel?: true
    currentStreak?: true
    longestStreak?: true
    totalQuizzes?: true
    perfectQuizzes?: true
    totalCorrect?: true
    totalAnswers?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    currentXP?: true
    currentLevel?: true
    currentStreak?: true
    longestStreak?: true
    totalQuizzes?: true
    perfectQuizzes?: true
    totalCorrect?: true
    totalAnswers?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerProgressCountAggregateInputType = {
    id?: true
    userId?: true
    currentXP?: true
    currentLevel?: true
    currentStreak?: true
    longestStreak?: true
    totalQuizzes?: true
    perfectQuizzes?: true
    totalCorrect?: true
    totalAnswers?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerProgress to aggregate.
     */
    where?: PlayerProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProgresses to fetch.
     */
    orderBy?: PlayerProgressOrderByWithRelationInput | PlayerProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerProgresses
    **/
    _count?: true | PlayerProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerProgressMaxAggregateInputType
  }

  export type GetPlayerProgressAggregateType<T extends PlayerProgressAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerProgress[P]>
      : GetScalarType<T[P], AggregatePlayerProgress[P]>
  }




  export type PlayerProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerProgressWhereInput
    orderBy?: PlayerProgressOrderByWithAggregationInput | PlayerProgressOrderByWithAggregationInput[]
    by: PlayerProgressScalarFieldEnum[] | PlayerProgressScalarFieldEnum
    having?: PlayerProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerProgressCountAggregateInputType | true
    _avg?: PlayerProgressAvgAggregateInputType
    _sum?: PlayerProgressSumAggregateInputType
    _min?: PlayerProgressMinAggregateInputType
    _max?: PlayerProgressMaxAggregateInputType
  }

  export type PlayerProgressGroupByOutputType = {
    id: string
    userId: string
    currentXP: number
    currentLevel: number
    currentStreak: number
    longestStreak: number
    totalQuizzes: number
    perfectQuizzes: number
    totalCorrect: number
    totalAnswers: number
    lastPlayedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PlayerProgressCountAggregateOutputType | null
    _avg: PlayerProgressAvgAggregateOutputType | null
    _sum: PlayerProgressSumAggregateOutputType | null
    _min: PlayerProgressMinAggregateOutputType | null
    _max: PlayerProgressMaxAggregateOutputType | null
  }

  type GetPlayerProgressGroupByPayload<T extends PlayerProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerProgressGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerProgressGroupByOutputType[P]>
        }
      >
    >


  export type PlayerProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentXP?: boolean
    currentLevel?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    totalQuizzes?: boolean
    perfectQuizzes?: boolean
    totalCorrect?: boolean
    totalAnswers?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerProgress"]>

  export type PlayerProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentXP?: boolean
    currentLevel?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    totalQuizzes?: boolean
    perfectQuizzes?: boolean
    totalCorrect?: boolean
    totalAnswers?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerProgress"]>

  export type PlayerProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentXP?: boolean
    currentLevel?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    totalQuizzes?: boolean
    perfectQuizzes?: boolean
    totalCorrect?: boolean
    totalAnswers?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerProgress"]>

  export type PlayerProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    currentXP?: boolean
    currentLevel?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    totalQuizzes?: boolean
    perfectQuizzes?: boolean
    totalCorrect?: boolean
    totalAnswers?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "currentXP" | "currentLevel" | "currentStreak" | "longestStreak" | "totalQuizzes" | "perfectQuizzes" | "totalCorrect" | "totalAnswers" | "lastPlayedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["playerProgress"]>
  export type PlayerProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlayerProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlayerProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlayerProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentXP: number
      currentLevel: number
      currentStreak: number
      longestStreak: number
      totalQuizzes: number
      perfectQuizzes: number
      totalCorrect: number
      totalAnswers: number
      lastPlayedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerProgress"]>
    composites: {}
  }

  type PlayerProgressGetPayload<S extends boolean | null | undefined | PlayerProgressDefaultArgs> = $Result.GetResult<Prisma.$PlayerProgressPayload, S>

  type PlayerProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerProgressCountAggregateInputType | true
    }

  export interface PlayerProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerProgress'], meta: { name: 'PlayerProgress' } }
    /**
     * Find zero or one PlayerProgress that matches the filter.
     * @param {PlayerProgressFindUniqueArgs} args - Arguments to find a PlayerProgress
     * @example
     * // Get one PlayerProgress
     * const playerProgress = await prisma.playerProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerProgressFindUniqueArgs>(args: SelectSubset<T, PlayerProgressFindUniqueArgs<ExtArgs>>): Prisma__PlayerProgressClient<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerProgressFindUniqueOrThrowArgs} args - Arguments to find a PlayerProgress
     * @example
     * // Get one PlayerProgress
     * const playerProgress = await prisma.playerProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerProgressClient<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProgressFindFirstArgs} args - Arguments to find a PlayerProgress
     * @example
     * // Get one PlayerProgress
     * const playerProgress = await prisma.playerProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerProgressFindFirstArgs>(args?: SelectSubset<T, PlayerProgressFindFirstArgs<ExtArgs>>): Prisma__PlayerProgressClient<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProgressFindFirstOrThrowArgs} args - Arguments to find a PlayerProgress
     * @example
     * // Get one PlayerProgress
     * const playerProgress = await prisma.playerProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerProgressClient<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerProgresses
     * const playerProgresses = await prisma.playerProgress.findMany()
     * 
     * // Get first 10 PlayerProgresses
     * const playerProgresses = await prisma.playerProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerProgressWithIdOnly = await prisma.playerProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerProgressFindManyArgs>(args?: SelectSubset<T, PlayerProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerProgress.
     * @param {PlayerProgressCreateArgs} args - Arguments to create a PlayerProgress.
     * @example
     * // Create one PlayerProgress
     * const PlayerProgress = await prisma.playerProgress.create({
     *   data: {
     *     // ... data to create a PlayerProgress
     *   }
     * })
     * 
     */
    create<T extends PlayerProgressCreateArgs>(args: SelectSubset<T, PlayerProgressCreateArgs<ExtArgs>>): Prisma__PlayerProgressClient<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerProgresses.
     * @param {PlayerProgressCreateManyArgs} args - Arguments to create many PlayerProgresses.
     * @example
     * // Create many PlayerProgresses
     * const playerProgress = await prisma.playerProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerProgressCreateManyArgs>(args?: SelectSubset<T, PlayerProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerProgresses and returns the data saved in the database.
     * @param {PlayerProgressCreateManyAndReturnArgs} args - Arguments to create many PlayerProgresses.
     * @example
     * // Create many PlayerProgresses
     * const playerProgress = await prisma.playerProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerProgresses and only return the `id`
     * const playerProgressWithIdOnly = await prisma.playerProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerProgress.
     * @param {PlayerProgressDeleteArgs} args - Arguments to delete one PlayerProgress.
     * @example
     * // Delete one PlayerProgress
     * const PlayerProgress = await prisma.playerProgress.delete({
     *   where: {
     *     // ... filter to delete one PlayerProgress
     *   }
     * })
     * 
     */
    delete<T extends PlayerProgressDeleteArgs>(args: SelectSubset<T, PlayerProgressDeleteArgs<ExtArgs>>): Prisma__PlayerProgressClient<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerProgress.
     * @param {PlayerProgressUpdateArgs} args - Arguments to update one PlayerProgress.
     * @example
     * // Update one PlayerProgress
     * const playerProgress = await prisma.playerProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerProgressUpdateArgs>(args: SelectSubset<T, PlayerProgressUpdateArgs<ExtArgs>>): Prisma__PlayerProgressClient<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerProgresses.
     * @param {PlayerProgressDeleteManyArgs} args - Arguments to filter PlayerProgresses to delete.
     * @example
     * // Delete a few PlayerProgresses
     * const { count } = await prisma.playerProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerProgressDeleteManyArgs>(args?: SelectSubset<T, PlayerProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerProgresses
     * const playerProgress = await prisma.playerProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerProgressUpdateManyArgs>(args: SelectSubset<T, PlayerProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerProgresses and returns the data updated in the database.
     * @param {PlayerProgressUpdateManyAndReturnArgs} args - Arguments to update many PlayerProgresses.
     * @example
     * // Update many PlayerProgresses
     * const playerProgress = await prisma.playerProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerProgresses and only return the `id`
     * const playerProgressWithIdOnly = await prisma.playerProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerProgress.
     * @param {PlayerProgressUpsertArgs} args - Arguments to update or create a PlayerProgress.
     * @example
     * // Update or create a PlayerProgress
     * const playerProgress = await prisma.playerProgress.upsert({
     *   create: {
     *     // ... data to create a PlayerProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerProgress we want to update
     *   }
     * })
     */
    upsert<T extends PlayerProgressUpsertArgs>(args: SelectSubset<T, PlayerProgressUpsertArgs<ExtArgs>>): Prisma__PlayerProgressClient<$Result.GetResult<Prisma.$PlayerProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProgressCountArgs} args - Arguments to filter PlayerProgresses to count.
     * @example
     * // Count the number of PlayerProgresses
     * const count = await prisma.playerProgress.count({
     *   where: {
     *     // ... the filter for the PlayerProgresses we want to count
     *   }
     * })
    **/
    count<T extends PlayerProgressCountArgs>(
      args?: Subset<T, PlayerProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerProgressAggregateArgs>(args: Subset<T, PlayerProgressAggregateArgs>): Prisma.PrismaPromise<GetPlayerProgressAggregateType<T>>

    /**
     * Group by PlayerProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerProgressGroupByArgs['orderBy'] }
        : { orderBy?: PlayerProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerProgress model
   */
  readonly fields: PlayerProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerProgress model
   */
  interface PlayerProgressFieldRefs {
    readonly id: FieldRef<"PlayerProgress", 'String'>
    readonly userId: FieldRef<"PlayerProgress", 'String'>
    readonly currentXP: FieldRef<"PlayerProgress", 'Int'>
    readonly currentLevel: FieldRef<"PlayerProgress", 'Int'>
    readonly currentStreak: FieldRef<"PlayerProgress", 'Int'>
    readonly longestStreak: FieldRef<"PlayerProgress", 'Int'>
    readonly totalQuizzes: FieldRef<"PlayerProgress", 'Int'>
    readonly perfectQuizzes: FieldRef<"PlayerProgress", 'Int'>
    readonly totalCorrect: FieldRef<"PlayerProgress", 'Int'>
    readonly totalAnswers: FieldRef<"PlayerProgress", 'Int'>
    readonly lastPlayedAt: FieldRef<"PlayerProgress", 'DateTime'>
    readonly createdAt: FieldRef<"PlayerProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerProgress findUnique
   */
  export type PlayerProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
    /**
     * Filter, which PlayerProgress to fetch.
     */
    where: PlayerProgressWhereUniqueInput
  }

  /**
   * PlayerProgress findUniqueOrThrow
   */
  export type PlayerProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
    /**
     * Filter, which PlayerProgress to fetch.
     */
    where: PlayerProgressWhereUniqueInput
  }

  /**
   * PlayerProgress findFirst
   */
  export type PlayerProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
    /**
     * Filter, which PlayerProgress to fetch.
     */
    where?: PlayerProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProgresses to fetch.
     */
    orderBy?: PlayerProgressOrderByWithRelationInput | PlayerProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerProgresses.
     */
    cursor?: PlayerProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerProgresses.
     */
    distinct?: PlayerProgressScalarFieldEnum | PlayerProgressScalarFieldEnum[]
  }

  /**
   * PlayerProgress findFirstOrThrow
   */
  export type PlayerProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
    /**
     * Filter, which PlayerProgress to fetch.
     */
    where?: PlayerProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProgresses to fetch.
     */
    orderBy?: PlayerProgressOrderByWithRelationInput | PlayerProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerProgresses.
     */
    cursor?: PlayerProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerProgresses.
     */
    distinct?: PlayerProgressScalarFieldEnum | PlayerProgressScalarFieldEnum[]
  }

  /**
   * PlayerProgress findMany
   */
  export type PlayerProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
    /**
     * Filter, which PlayerProgresses to fetch.
     */
    where?: PlayerProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProgresses to fetch.
     */
    orderBy?: PlayerProgressOrderByWithRelationInput | PlayerProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerProgresses.
     */
    cursor?: PlayerProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProgresses.
     */
    skip?: number
    distinct?: PlayerProgressScalarFieldEnum | PlayerProgressScalarFieldEnum[]
  }

  /**
   * PlayerProgress create
   */
  export type PlayerProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerProgress.
     */
    data: XOR<PlayerProgressCreateInput, PlayerProgressUncheckedCreateInput>
  }

  /**
   * PlayerProgress createMany
   */
  export type PlayerProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerProgresses.
     */
    data: PlayerProgressCreateManyInput | PlayerProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerProgress createManyAndReturn
   */
  export type PlayerProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerProgresses.
     */
    data: PlayerProgressCreateManyInput | PlayerProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerProgress update
   */
  export type PlayerProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerProgress.
     */
    data: XOR<PlayerProgressUpdateInput, PlayerProgressUncheckedUpdateInput>
    /**
     * Choose, which PlayerProgress to update.
     */
    where: PlayerProgressWhereUniqueInput
  }

  /**
   * PlayerProgress updateMany
   */
  export type PlayerProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerProgresses.
     */
    data: XOR<PlayerProgressUpdateManyMutationInput, PlayerProgressUncheckedUpdateManyInput>
    /**
     * Filter which PlayerProgresses to update
     */
    where?: PlayerProgressWhereInput
    /**
     * Limit how many PlayerProgresses to update.
     */
    limit?: number
  }

  /**
   * PlayerProgress updateManyAndReturn
   */
  export type PlayerProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * The data used to update PlayerProgresses.
     */
    data: XOR<PlayerProgressUpdateManyMutationInput, PlayerProgressUncheckedUpdateManyInput>
    /**
     * Filter which PlayerProgresses to update
     */
    where?: PlayerProgressWhereInput
    /**
     * Limit how many PlayerProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerProgress upsert
   */
  export type PlayerProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerProgress to update in case it exists.
     */
    where: PlayerProgressWhereUniqueInput
    /**
     * In case the PlayerProgress found by the `where` argument doesn't exist, create a new PlayerProgress with this data.
     */
    create: XOR<PlayerProgressCreateInput, PlayerProgressUncheckedCreateInput>
    /**
     * In case the PlayerProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerProgressUpdateInput, PlayerProgressUncheckedUpdateInput>
  }

  /**
   * PlayerProgress delete
   */
  export type PlayerProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
    /**
     * Filter which PlayerProgress to delete.
     */
    where: PlayerProgressWhereUniqueInput
  }

  /**
   * PlayerProgress deleteMany
   */
  export type PlayerProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerProgresses to delete
     */
    where?: PlayerProgressWhereInput
    /**
     * Limit how many PlayerProgresses to delete.
     */
    limit?: number
  }

  /**
   * PlayerProgress without action
   */
  export type PlayerProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProgress
     */
    select?: PlayerProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProgress
     */
    omit?: PlayerProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerProgressInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    coinReward: number | null
  }

  export type BadgeSumAggregateOutputType = {
    coinReward: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    rarity: $Enums.BadgeRarity | null
    condition: string | null
    coinReward: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    rarity: $Enums.BadgeRarity | null
    condition: string | null
    coinReward: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    rarity: number
    condition: number
    coinReward: number
    conditionData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    coinReward?: true
  }

  export type BadgeSumAggregateInputType = {
    coinReward?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    rarity?: true
    condition?: true
    coinReward?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    rarity?: true
    condition?: true
    coinReward?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    rarity?: true
    condition?: true
    coinReward?: true
    conditionData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    name: string
    description: string
    imageUrl: string
    rarity: $Enums.BadgeRarity
    condition: string
    coinReward: number
    conditionData: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    rarity?: boolean
    condition?: boolean
    coinReward?: boolean
    conditionData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playerBadges?: boolean | Badge$playerBadgesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    rarity?: boolean
    condition?: boolean
    coinReward?: boolean
    conditionData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    rarity?: boolean
    condition?: boolean
    coinReward?: boolean
    conditionData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    rarity?: boolean
    condition?: boolean
    coinReward?: boolean
    conditionData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "imageUrl" | "rarity" | "condition" | "coinReward" | "conditionData" | "createdAt" | "updatedAt", ExtArgs["result"]["badge"]>
  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerBadges?: boolean | Badge$playerBadgesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      playerBadges: Prisma.$PlayerBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      imageUrl: string
      rarity: $Enums.BadgeRarity
      condition: string
      coinReward: number
      conditionData: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {BadgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playerBadges<T extends Badge$playerBadgesArgs<ExtArgs> = {}>(args?: Subset<T, Badge$playerBadgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly imageUrl: FieldRef<"Badge", 'String'>
    readonly rarity: FieldRef<"Badge", 'BadgeRarity'>
    readonly condition: FieldRef<"Badge", 'String'>
    readonly coinReward: FieldRef<"Badge", 'Int'>
    readonly conditionData: FieldRef<"Badge", 'Json'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
    readonly updatedAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge updateManyAndReturn
   */
  export type BadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badge.playerBadges
   */
  export type Badge$playerBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    where?: PlayerBadgeWhereInput
    orderBy?: PlayerBadgeOrderByWithRelationInput | PlayerBadgeOrderByWithRelationInput[]
    cursor?: PlayerBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerBadgeScalarFieldEnum | PlayerBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model PlayerBadge
   */

  export type AggregatePlayerBadge = {
    _count: PlayerBadgeCountAggregateOutputType | null
    _min: PlayerBadgeMinAggregateOutputType | null
    _max: PlayerBadgeMaxAggregateOutputType | null
  }

  export type PlayerBadgeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    unlockedAt: Date | null
  }

  export type PlayerBadgeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    unlockedAt: Date | null
  }

  export type PlayerBadgeCountAggregateOutputType = {
    id: number
    userId: number
    badgeId: number
    unlockedAt: number
    _all: number
  }


  export type PlayerBadgeMinAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    unlockedAt?: true
  }

  export type PlayerBadgeMaxAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    unlockedAt?: true
  }

  export type PlayerBadgeCountAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    unlockedAt?: true
    _all?: true
  }

  export type PlayerBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerBadge to aggregate.
     */
    where?: PlayerBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerBadges to fetch.
     */
    orderBy?: PlayerBadgeOrderByWithRelationInput | PlayerBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerBadges
    **/
    _count?: true | PlayerBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerBadgeMaxAggregateInputType
  }

  export type GetPlayerBadgeAggregateType<T extends PlayerBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerBadge[P]>
      : GetScalarType<T[P], AggregatePlayerBadge[P]>
  }




  export type PlayerBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerBadgeWhereInput
    orderBy?: PlayerBadgeOrderByWithAggregationInput | PlayerBadgeOrderByWithAggregationInput[]
    by: PlayerBadgeScalarFieldEnum[] | PlayerBadgeScalarFieldEnum
    having?: PlayerBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerBadgeCountAggregateInputType | true
    _min?: PlayerBadgeMinAggregateInputType
    _max?: PlayerBadgeMaxAggregateInputType
  }

  export type PlayerBadgeGroupByOutputType = {
    id: string
    userId: string
    badgeId: string
    unlockedAt: Date
    _count: PlayerBadgeCountAggregateOutputType | null
    _min: PlayerBadgeMinAggregateOutputType | null
    _max: PlayerBadgeMaxAggregateOutputType | null
  }

  type GetPlayerBadgeGroupByPayload<T extends PlayerBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerBadgeGroupByOutputType[P]>
        }
      >
    >


  export type PlayerBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    unlockedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerBadge"]>

  export type PlayerBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    unlockedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerBadge"]>

  export type PlayerBadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    unlockedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerBadge"]>

  export type PlayerBadgeSelectScalar = {
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    unlockedAt?: boolean
  }

  export type PlayerBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "badgeId" | "unlockedAt", ExtArgs["result"]["playerBadge"]>
  export type PlayerBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type PlayerBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type PlayerBadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }

  export type $PlayerBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerBadge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      badge: Prisma.$BadgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      badgeId: string
      unlockedAt: Date
    }, ExtArgs["result"]["playerBadge"]>
    composites: {}
  }

  type PlayerBadgeGetPayload<S extends boolean | null | undefined | PlayerBadgeDefaultArgs> = $Result.GetResult<Prisma.$PlayerBadgePayload, S>

  type PlayerBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerBadgeCountAggregateInputType | true
    }

  export interface PlayerBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerBadge'], meta: { name: 'PlayerBadge' } }
    /**
     * Find zero or one PlayerBadge that matches the filter.
     * @param {PlayerBadgeFindUniqueArgs} args - Arguments to find a PlayerBadge
     * @example
     * // Get one PlayerBadge
     * const playerBadge = await prisma.playerBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerBadgeFindUniqueArgs>(args: SelectSubset<T, PlayerBadgeFindUniqueArgs<ExtArgs>>): Prisma__PlayerBadgeClient<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerBadgeFindUniqueOrThrowArgs} args - Arguments to find a PlayerBadge
     * @example
     * // Get one PlayerBadge
     * const playerBadge = await prisma.playerBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerBadgeClient<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBadgeFindFirstArgs} args - Arguments to find a PlayerBadge
     * @example
     * // Get one PlayerBadge
     * const playerBadge = await prisma.playerBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerBadgeFindFirstArgs>(args?: SelectSubset<T, PlayerBadgeFindFirstArgs<ExtArgs>>): Prisma__PlayerBadgeClient<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBadgeFindFirstOrThrowArgs} args - Arguments to find a PlayerBadge
     * @example
     * // Get one PlayerBadge
     * const playerBadge = await prisma.playerBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerBadgeClient<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerBadges
     * const playerBadges = await prisma.playerBadge.findMany()
     * 
     * // Get first 10 PlayerBadges
     * const playerBadges = await prisma.playerBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerBadgeWithIdOnly = await prisma.playerBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerBadgeFindManyArgs>(args?: SelectSubset<T, PlayerBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerBadge.
     * @param {PlayerBadgeCreateArgs} args - Arguments to create a PlayerBadge.
     * @example
     * // Create one PlayerBadge
     * const PlayerBadge = await prisma.playerBadge.create({
     *   data: {
     *     // ... data to create a PlayerBadge
     *   }
     * })
     * 
     */
    create<T extends PlayerBadgeCreateArgs>(args: SelectSubset<T, PlayerBadgeCreateArgs<ExtArgs>>): Prisma__PlayerBadgeClient<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerBadges.
     * @param {PlayerBadgeCreateManyArgs} args - Arguments to create many PlayerBadges.
     * @example
     * // Create many PlayerBadges
     * const playerBadge = await prisma.playerBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerBadgeCreateManyArgs>(args?: SelectSubset<T, PlayerBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerBadges and returns the data saved in the database.
     * @param {PlayerBadgeCreateManyAndReturnArgs} args - Arguments to create many PlayerBadges.
     * @example
     * // Create many PlayerBadges
     * const playerBadge = await prisma.playerBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerBadges and only return the `id`
     * const playerBadgeWithIdOnly = await prisma.playerBadge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerBadge.
     * @param {PlayerBadgeDeleteArgs} args - Arguments to delete one PlayerBadge.
     * @example
     * // Delete one PlayerBadge
     * const PlayerBadge = await prisma.playerBadge.delete({
     *   where: {
     *     // ... filter to delete one PlayerBadge
     *   }
     * })
     * 
     */
    delete<T extends PlayerBadgeDeleteArgs>(args: SelectSubset<T, PlayerBadgeDeleteArgs<ExtArgs>>): Prisma__PlayerBadgeClient<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerBadge.
     * @param {PlayerBadgeUpdateArgs} args - Arguments to update one PlayerBadge.
     * @example
     * // Update one PlayerBadge
     * const playerBadge = await prisma.playerBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerBadgeUpdateArgs>(args: SelectSubset<T, PlayerBadgeUpdateArgs<ExtArgs>>): Prisma__PlayerBadgeClient<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerBadges.
     * @param {PlayerBadgeDeleteManyArgs} args - Arguments to filter PlayerBadges to delete.
     * @example
     * // Delete a few PlayerBadges
     * const { count } = await prisma.playerBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerBadgeDeleteManyArgs>(args?: SelectSubset<T, PlayerBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerBadges
     * const playerBadge = await prisma.playerBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerBadgeUpdateManyArgs>(args: SelectSubset<T, PlayerBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerBadges and returns the data updated in the database.
     * @param {PlayerBadgeUpdateManyAndReturnArgs} args - Arguments to update many PlayerBadges.
     * @example
     * // Update many PlayerBadges
     * const playerBadge = await prisma.playerBadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerBadges and only return the `id`
     * const playerBadgeWithIdOnly = await prisma.playerBadge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerBadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerBadge.
     * @param {PlayerBadgeUpsertArgs} args - Arguments to update or create a PlayerBadge.
     * @example
     * // Update or create a PlayerBadge
     * const playerBadge = await prisma.playerBadge.upsert({
     *   create: {
     *     // ... data to create a PlayerBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerBadge we want to update
     *   }
     * })
     */
    upsert<T extends PlayerBadgeUpsertArgs>(args: SelectSubset<T, PlayerBadgeUpsertArgs<ExtArgs>>): Prisma__PlayerBadgeClient<$Result.GetResult<Prisma.$PlayerBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBadgeCountArgs} args - Arguments to filter PlayerBadges to count.
     * @example
     * // Count the number of PlayerBadges
     * const count = await prisma.playerBadge.count({
     *   where: {
     *     // ... the filter for the PlayerBadges we want to count
     *   }
     * })
    **/
    count<T extends PlayerBadgeCountArgs>(
      args?: Subset<T, PlayerBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerBadgeAggregateArgs>(args: Subset<T, PlayerBadgeAggregateArgs>): Prisma.PrismaPromise<GetPlayerBadgeAggregateType<T>>

    /**
     * Group by PlayerBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerBadgeGroupByArgs['orderBy'] }
        : { orderBy?: PlayerBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerBadge model
   */
  readonly fields: PlayerBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerBadge model
   */
  interface PlayerBadgeFieldRefs {
    readonly id: FieldRef<"PlayerBadge", 'String'>
    readonly userId: FieldRef<"PlayerBadge", 'String'>
    readonly badgeId: FieldRef<"PlayerBadge", 'String'>
    readonly unlockedAt: FieldRef<"PlayerBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerBadge findUnique
   */
  export type PlayerBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    /**
     * Filter, which PlayerBadge to fetch.
     */
    where: PlayerBadgeWhereUniqueInput
  }

  /**
   * PlayerBadge findUniqueOrThrow
   */
  export type PlayerBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    /**
     * Filter, which PlayerBadge to fetch.
     */
    where: PlayerBadgeWhereUniqueInput
  }

  /**
   * PlayerBadge findFirst
   */
  export type PlayerBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    /**
     * Filter, which PlayerBadge to fetch.
     */
    where?: PlayerBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerBadges to fetch.
     */
    orderBy?: PlayerBadgeOrderByWithRelationInput | PlayerBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerBadges.
     */
    cursor?: PlayerBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerBadges.
     */
    distinct?: PlayerBadgeScalarFieldEnum | PlayerBadgeScalarFieldEnum[]
  }

  /**
   * PlayerBadge findFirstOrThrow
   */
  export type PlayerBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    /**
     * Filter, which PlayerBadge to fetch.
     */
    where?: PlayerBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerBadges to fetch.
     */
    orderBy?: PlayerBadgeOrderByWithRelationInput | PlayerBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerBadges.
     */
    cursor?: PlayerBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerBadges.
     */
    distinct?: PlayerBadgeScalarFieldEnum | PlayerBadgeScalarFieldEnum[]
  }

  /**
   * PlayerBadge findMany
   */
  export type PlayerBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    /**
     * Filter, which PlayerBadges to fetch.
     */
    where?: PlayerBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerBadges to fetch.
     */
    orderBy?: PlayerBadgeOrderByWithRelationInput | PlayerBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerBadges.
     */
    cursor?: PlayerBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerBadges.
     */
    skip?: number
    distinct?: PlayerBadgeScalarFieldEnum | PlayerBadgeScalarFieldEnum[]
  }

  /**
   * PlayerBadge create
   */
  export type PlayerBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerBadge.
     */
    data: XOR<PlayerBadgeCreateInput, PlayerBadgeUncheckedCreateInput>
  }

  /**
   * PlayerBadge createMany
   */
  export type PlayerBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerBadges.
     */
    data: PlayerBadgeCreateManyInput | PlayerBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerBadge createManyAndReturn
   */
  export type PlayerBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerBadges.
     */
    data: PlayerBadgeCreateManyInput | PlayerBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerBadge update
   */
  export type PlayerBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerBadge.
     */
    data: XOR<PlayerBadgeUpdateInput, PlayerBadgeUncheckedUpdateInput>
    /**
     * Choose, which PlayerBadge to update.
     */
    where: PlayerBadgeWhereUniqueInput
  }

  /**
   * PlayerBadge updateMany
   */
  export type PlayerBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerBadges.
     */
    data: XOR<PlayerBadgeUpdateManyMutationInput, PlayerBadgeUncheckedUpdateManyInput>
    /**
     * Filter which PlayerBadges to update
     */
    where?: PlayerBadgeWhereInput
    /**
     * Limit how many PlayerBadges to update.
     */
    limit?: number
  }

  /**
   * PlayerBadge updateManyAndReturn
   */
  export type PlayerBadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * The data used to update PlayerBadges.
     */
    data: XOR<PlayerBadgeUpdateManyMutationInput, PlayerBadgeUncheckedUpdateManyInput>
    /**
     * Filter which PlayerBadges to update
     */
    where?: PlayerBadgeWhereInput
    /**
     * Limit how many PlayerBadges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerBadge upsert
   */
  export type PlayerBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerBadge to update in case it exists.
     */
    where: PlayerBadgeWhereUniqueInput
    /**
     * In case the PlayerBadge found by the `where` argument doesn't exist, create a new PlayerBadge with this data.
     */
    create: XOR<PlayerBadgeCreateInput, PlayerBadgeUncheckedCreateInput>
    /**
     * In case the PlayerBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerBadgeUpdateInput, PlayerBadgeUncheckedUpdateInput>
  }

  /**
   * PlayerBadge delete
   */
  export type PlayerBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
    /**
     * Filter which PlayerBadge to delete.
     */
    where: PlayerBadgeWhereUniqueInput
  }

  /**
   * PlayerBadge deleteMany
   */
  export type PlayerBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerBadges to delete
     */
    where?: PlayerBadgeWhereInput
    /**
     * Limit how many PlayerBadges to delete.
     */
    limit?: number
  }

  /**
   * PlayerBadge without action
   */
  export type PlayerBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerBadge
     */
    select?: PlayerBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerBadge
     */
    omit?: PlayerBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerBadgeInclude<ExtArgs> | null
  }


  /**
   * Model CategoryStat
   */

  export type AggregateCategoryStat = {
    _count: CategoryStatCountAggregateOutputType | null
    _avg: CategoryStatAvgAggregateOutputType | null
    _sum: CategoryStatSumAggregateOutputType | null
    _min: CategoryStatMinAggregateOutputType | null
    _max: CategoryStatMaxAggregateOutputType | null
  }

  export type CategoryStatAvgAggregateOutputType = {
    quizzesPlayed: number | null
    correctAnswers: number | null
    totalAnswers: number | null
  }

  export type CategoryStatSumAggregateOutputType = {
    quizzesPlayed: number | null
    correctAnswers: number | null
    totalAnswers: number | null
  }

  export type CategoryStatMinAggregateOutputType = {
    id: string | null
    userId: string | null
    categoryName: string | null
    quizzesPlayed: number | null
    correctAnswers: number | null
    totalAnswers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryStatMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    categoryName: string | null
    quizzesPlayed: number | null
    correctAnswers: number | null
    totalAnswers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryStatCountAggregateOutputType = {
    id: number
    userId: number
    categoryName: number
    quizzesPlayed: number
    correctAnswers: number
    totalAnswers: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryStatAvgAggregateInputType = {
    quizzesPlayed?: true
    correctAnswers?: true
    totalAnswers?: true
  }

  export type CategoryStatSumAggregateInputType = {
    quizzesPlayed?: true
    correctAnswers?: true
    totalAnswers?: true
  }

  export type CategoryStatMinAggregateInputType = {
    id?: true
    userId?: true
    categoryName?: true
    quizzesPlayed?: true
    correctAnswers?: true
    totalAnswers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryStatMaxAggregateInputType = {
    id?: true
    userId?: true
    categoryName?: true
    quizzesPlayed?: true
    correctAnswers?: true
    totalAnswers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryStatCountAggregateInputType = {
    id?: true
    userId?: true
    categoryName?: true
    quizzesPlayed?: true
    correctAnswers?: true
    totalAnswers?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryStat to aggregate.
     */
    where?: CategoryStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryStats to fetch.
     */
    orderBy?: CategoryStatOrderByWithRelationInput | CategoryStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryStats
    **/
    _count?: true | CategoryStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoryStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryStatMaxAggregateInputType
  }

  export type GetCategoryStatAggregateType<T extends CategoryStatAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryStat[P]>
      : GetScalarType<T[P], AggregateCategoryStat[P]>
  }




  export type CategoryStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryStatWhereInput
    orderBy?: CategoryStatOrderByWithAggregationInput | CategoryStatOrderByWithAggregationInput[]
    by: CategoryStatScalarFieldEnum[] | CategoryStatScalarFieldEnum
    having?: CategoryStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryStatCountAggregateInputType | true
    _avg?: CategoryStatAvgAggregateInputType
    _sum?: CategoryStatSumAggregateInputType
    _min?: CategoryStatMinAggregateInputType
    _max?: CategoryStatMaxAggregateInputType
  }

  export type CategoryStatGroupByOutputType = {
    id: string
    userId: string
    categoryName: string
    quizzesPlayed: number
    correctAnswers: number
    totalAnswers: number
    createdAt: Date
    updatedAt: Date
    _count: CategoryStatCountAggregateOutputType | null
    _avg: CategoryStatAvgAggregateOutputType | null
    _sum: CategoryStatSumAggregateOutputType | null
    _min: CategoryStatMinAggregateOutputType | null
    _max: CategoryStatMaxAggregateOutputType | null
  }

  type GetCategoryStatGroupByPayload<T extends CategoryStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryStatGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryStatGroupByOutputType[P]>
        }
      >
    >


  export type CategoryStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryName?: boolean
    quizzesPlayed?: boolean
    correctAnswers?: boolean
    totalAnswers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryStat"]>

  export type CategoryStatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryName?: boolean
    quizzesPlayed?: boolean
    correctAnswers?: boolean
    totalAnswers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryStat"]>

  export type CategoryStatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryName?: boolean
    quizzesPlayed?: boolean
    correctAnswers?: boolean
    totalAnswers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryStat"]>

  export type CategoryStatSelectScalar = {
    id?: boolean
    userId?: boolean
    categoryName?: boolean
    quizzesPlayed?: boolean
    correctAnswers?: boolean
    totalAnswers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryStatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "categoryName" | "quizzesPlayed" | "correctAnswers" | "totalAnswers" | "createdAt" | "updatedAt", ExtArgs["result"]["categoryStat"]>
  export type CategoryStatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CategoryStatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CategoryStatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CategoryStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoryStat"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      categoryName: string
      quizzesPlayed: number
      correctAnswers: number
      totalAnswers: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["categoryStat"]>
    composites: {}
  }

  type CategoryStatGetPayload<S extends boolean | null | undefined | CategoryStatDefaultArgs> = $Result.GetResult<Prisma.$CategoryStatPayload, S>

  type CategoryStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryStatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryStatCountAggregateInputType | true
    }

  export interface CategoryStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryStat'], meta: { name: 'CategoryStat' } }
    /**
     * Find zero or one CategoryStat that matches the filter.
     * @param {CategoryStatFindUniqueArgs} args - Arguments to find a CategoryStat
     * @example
     * // Get one CategoryStat
     * const categoryStat = await prisma.categoryStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryStatFindUniqueArgs>(args: SelectSubset<T, CategoryStatFindUniqueArgs<ExtArgs>>): Prisma__CategoryStatClient<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategoryStat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryStatFindUniqueOrThrowArgs} args - Arguments to find a CategoryStat
     * @example
     * // Get one CategoryStat
     * const categoryStat = await prisma.categoryStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryStatFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryStatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryStatClient<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryStatFindFirstArgs} args - Arguments to find a CategoryStat
     * @example
     * // Get one CategoryStat
     * const categoryStat = await prisma.categoryStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryStatFindFirstArgs>(args?: SelectSubset<T, CategoryStatFindFirstArgs<ExtArgs>>): Prisma__CategoryStatClient<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryStatFindFirstOrThrowArgs} args - Arguments to find a CategoryStat
     * @example
     * // Get one CategoryStat
     * const categoryStat = await prisma.categoryStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryStatFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryStatFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryStatClient<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategoryStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryStatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryStats
     * const categoryStats = await prisma.categoryStat.findMany()
     * 
     * // Get first 10 CategoryStats
     * const categoryStats = await prisma.categoryStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryStatWithIdOnly = await prisma.categoryStat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryStatFindManyArgs>(args?: SelectSubset<T, CategoryStatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategoryStat.
     * @param {CategoryStatCreateArgs} args - Arguments to create a CategoryStat.
     * @example
     * // Create one CategoryStat
     * const CategoryStat = await prisma.categoryStat.create({
     *   data: {
     *     // ... data to create a CategoryStat
     *   }
     * })
     * 
     */
    create<T extends CategoryStatCreateArgs>(args: SelectSubset<T, CategoryStatCreateArgs<ExtArgs>>): Prisma__CategoryStatClient<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategoryStats.
     * @param {CategoryStatCreateManyArgs} args - Arguments to create many CategoryStats.
     * @example
     * // Create many CategoryStats
     * const categoryStat = await prisma.categoryStat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryStatCreateManyArgs>(args?: SelectSubset<T, CategoryStatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoryStats and returns the data saved in the database.
     * @param {CategoryStatCreateManyAndReturnArgs} args - Arguments to create many CategoryStats.
     * @example
     * // Create many CategoryStats
     * const categoryStat = await prisma.categoryStat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoryStats and only return the `id`
     * const categoryStatWithIdOnly = await prisma.categoryStat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryStatCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryStatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CategoryStat.
     * @param {CategoryStatDeleteArgs} args - Arguments to delete one CategoryStat.
     * @example
     * // Delete one CategoryStat
     * const CategoryStat = await prisma.categoryStat.delete({
     *   where: {
     *     // ... filter to delete one CategoryStat
     *   }
     * })
     * 
     */
    delete<T extends CategoryStatDeleteArgs>(args: SelectSubset<T, CategoryStatDeleteArgs<ExtArgs>>): Prisma__CategoryStatClient<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategoryStat.
     * @param {CategoryStatUpdateArgs} args - Arguments to update one CategoryStat.
     * @example
     * // Update one CategoryStat
     * const categoryStat = await prisma.categoryStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryStatUpdateArgs>(args: SelectSubset<T, CategoryStatUpdateArgs<ExtArgs>>): Prisma__CategoryStatClient<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategoryStats.
     * @param {CategoryStatDeleteManyArgs} args - Arguments to filter CategoryStats to delete.
     * @example
     * // Delete a few CategoryStats
     * const { count } = await prisma.categoryStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryStatDeleteManyArgs>(args?: SelectSubset<T, CategoryStatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryStats
     * const categoryStat = await prisma.categoryStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryStatUpdateManyArgs>(args: SelectSubset<T, CategoryStatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryStats and returns the data updated in the database.
     * @param {CategoryStatUpdateManyAndReturnArgs} args - Arguments to update many CategoryStats.
     * @example
     * // Update many CategoryStats
     * const categoryStat = await prisma.categoryStat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CategoryStats and only return the `id`
     * const categoryStatWithIdOnly = await prisma.categoryStat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryStatUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryStatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CategoryStat.
     * @param {CategoryStatUpsertArgs} args - Arguments to update or create a CategoryStat.
     * @example
     * // Update or create a CategoryStat
     * const categoryStat = await prisma.categoryStat.upsert({
     *   create: {
     *     // ... data to create a CategoryStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryStat we want to update
     *   }
     * })
     */
    upsert<T extends CategoryStatUpsertArgs>(args: SelectSubset<T, CategoryStatUpsertArgs<ExtArgs>>): Prisma__CategoryStatClient<$Result.GetResult<Prisma.$CategoryStatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CategoryStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryStatCountArgs} args - Arguments to filter CategoryStats to count.
     * @example
     * // Count the number of CategoryStats
     * const count = await prisma.categoryStat.count({
     *   where: {
     *     // ... the filter for the CategoryStats we want to count
     *   }
     * })
    **/
    count<T extends CategoryStatCountArgs>(
      args?: Subset<T, CategoryStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryStatAggregateArgs>(args: Subset<T, CategoryStatAggregateArgs>): Prisma.PrismaPromise<GetCategoryStatAggregateType<T>>

    /**
     * Group by CategoryStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryStatGroupByArgs['orderBy'] }
        : { orderBy?: CategoryStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryStat model
   */
  readonly fields: CategoryStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategoryStat model
   */
  interface CategoryStatFieldRefs {
    readonly id: FieldRef<"CategoryStat", 'String'>
    readonly userId: FieldRef<"CategoryStat", 'String'>
    readonly categoryName: FieldRef<"CategoryStat", 'String'>
    readonly quizzesPlayed: FieldRef<"CategoryStat", 'Int'>
    readonly correctAnswers: FieldRef<"CategoryStat", 'Int'>
    readonly totalAnswers: FieldRef<"CategoryStat", 'Int'>
    readonly createdAt: FieldRef<"CategoryStat", 'DateTime'>
    readonly updatedAt: FieldRef<"CategoryStat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CategoryStat findUnique
   */
  export type CategoryStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
    /**
     * Filter, which CategoryStat to fetch.
     */
    where: CategoryStatWhereUniqueInput
  }

  /**
   * CategoryStat findUniqueOrThrow
   */
  export type CategoryStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
    /**
     * Filter, which CategoryStat to fetch.
     */
    where: CategoryStatWhereUniqueInput
  }

  /**
   * CategoryStat findFirst
   */
  export type CategoryStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
    /**
     * Filter, which CategoryStat to fetch.
     */
    where?: CategoryStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryStats to fetch.
     */
    orderBy?: CategoryStatOrderByWithRelationInput | CategoryStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryStats.
     */
    cursor?: CategoryStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryStats.
     */
    distinct?: CategoryStatScalarFieldEnum | CategoryStatScalarFieldEnum[]
  }

  /**
   * CategoryStat findFirstOrThrow
   */
  export type CategoryStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
    /**
     * Filter, which CategoryStat to fetch.
     */
    where?: CategoryStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryStats to fetch.
     */
    orderBy?: CategoryStatOrderByWithRelationInput | CategoryStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryStats.
     */
    cursor?: CategoryStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryStats.
     */
    distinct?: CategoryStatScalarFieldEnum | CategoryStatScalarFieldEnum[]
  }

  /**
   * CategoryStat findMany
   */
  export type CategoryStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
    /**
     * Filter, which CategoryStats to fetch.
     */
    where?: CategoryStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryStats to fetch.
     */
    orderBy?: CategoryStatOrderByWithRelationInput | CategoryStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryStats.
     */
    cursor?: CategoryStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryStats.
     */
    skip?: number
    distinct?: CategoryStatScalarFieldEnum | CategoryStatScalarFieldEnum[]
  }

  /**
   * CategoryStat create
   */
  export type CategoryStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryStat.
     */
    data: XOR<CategoryStatCreateInput, CategoryStatUncheckedCreateInput>
  }

  /**
   * CategoryStat createMany
   */
  export type CategoryStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryStats.
     */
    data: CategoryStatCreateManyInput | CategoryStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoryStat createManyAndReturn
   */
  export type CategoryStatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * The data used to create many CategoryStats.
     */
    data: CategoryStatCreateManyInput | CategoryStatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryStat update
   */
  export type CategoryStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryStat.
     */
    data: XOR<CategoryStatUpdateInput, CategoryStatUncheckedUpdateInput>
    /**
     * Choose, which CategoryStat to update.
     */
    where: CategoryStatWhereUniqueInput
  }

  /**
   * CategoryStat updateMany
   */
  export type CategoryStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryStats.
     */
    data: XOR<CategoryStatUpdateManyMutationInput, CategoryStatUncheckedUpdateManyInput>
    /**
     * Filter which CategoryStats to update
     */
    where?: CategoryStatWhereInput
    /**
     * Limit how many CategoryStats to update.
     */
    limit?: number
  }

  /**
   * CategoryStat updateManyAndReturn
   */
  export type CategoryStatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * The data used to update CategoryStats.
     */
    data: XOR<CategoryStatUpdateManyMutationInput, CategoryStatUncheckedUpdateManyInput>
    /**
     * Filter which CategoryStats to update
     */
    where?: CategoryStatWhereInput
    /**
     * Limit how many CategoryStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryStat upsert
   */
  export type CategoryStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryStat to update in case it exists.
     */
    where: CategoryStatWhereUniqueInput
    /**
     * In case the CategoryStat found by the `where` argument doesn't exist, create a new CategoryStat with this data.
     */
    create: XOR<CategoryStatCreateInput, CategoryStatUncheckedCreateInput>
    /**
     * In case the CategoryStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryStatUpdateInput, CategoryStatUncheckedUpdateInput>
  }

  /**
   * CategoryStat delete
   */
  export type CategoryStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
    /**
     * Filter which CategoryStat to delete.
     */
    where: CategoryStatWhereUniqueInput
  }

  /**
   * CategoryStat deleteMany
   */
  export type CategoryStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryStats to delete
     */
    where?: CategoryStatWhereInput
    /**
     * Limit how many CategoryStats to delete.
     */
    limit?: number
  }

  /**
   * CategoryStat without action
   */
  export type CategoryStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryStat
     */
    select?: CategoryStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryStat
     */
    omit?: CategoryStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryStatInclude<ExtArgs> | null
  }


  /**
   * Model StreakProtection
   */

  export type AggregateStreakProtection = {
    _count: StreakProtectionCountAggregateOutputType | null
    _min: StreakProtectionMinAggregateOutputType | null
    _max: StreakProtectionMaxAggregateOutputType | null
  }

  export type StreakProtectionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type StreakProtectionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type StreakProtectionCountAggregateOutputType = {
    id: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type StreakProtectionMinAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type StreakProtectionMaxAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type StreakProtectionCountAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type StreakProtectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StreakProtection to aggregate.
     */
    where?: StreakProtectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreakProtections to fetch.
     */
    orderBy?: StreakProtectionOrderByWithRelationInput | StreakProtectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StreakProtectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreakProtections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreakProtections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StreakProtections
    **/
    _count?: true | StreakProtectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StreakProtectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StreakProtectionMaxAggregateInputType
  }

  export type GetStreakProtectionAggregateType<T extends StreakProtectionAggregateArgs> = {
        [P in keyof T & keyof AggregateStreakProtection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStreakProtection[P]>
      : GetScalarType<T[P], AggregateStreakProtection[P]>
  }




  export type StreakProtectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreakProtectionWhereInput
    orderBy?: StreakProtectionOrderByWithAggregationInput | StreakProtectionOrderByWithAggregationInput[]
    by: StreakProtectionScalarFieldEnum[] | StreakProtectionScalarFieldEnum
    having?: StreakProtectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StreakProtectionCountAggregateInputType | true
    _min?: StreakProtectionMinAggregateInputType
    _max?: StreakProtectionMaxAggregateInputType
  }

  export type StreakProtectionGroupByOutputType = {
    id: string
    userId: string
    expiresAt: Date
    createdAt: Date
    _count: StreakProtectionCountAggregateOutputType | null
    _min: StreakProtectionMinAggregateOutputType | null
    _max: StreakProtectionMaxAggregateOutputType | null
  }

  type GetStreakProtectionGroupByPayload<T extends StreakProtectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StreakProtectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StreakProtectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StreakProtectionGroupByOutputType[P]>
            : GetScalarType<T[P], StreakProtectionGroupByOutputType[P]>
        }
      >
    >


  export type StreakProtectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streakProtection"]>

  export type StreakProtectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streakProtection"]>

  export type StreakProtectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streakProtection"]>

  export type StreakProtectionSelectScalar = {
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type StreakProtectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "expiresAt" | "createdAt", ExtArgs["result"]["streakProtection"]>
  export type StreakProtectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StreakProtectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StreakProtectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StreakProtectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StreakProtection"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["streakProtection"]>
    composites: {}
  }

  type StreakProtectionGetPayload<S extends boolean | null | undefined | StreakProtectionDefaultArgs> = $Result.GetResult<Prisma.$StreakProtectionPayload, S>

  type StreakProtectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StreakProtectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StreakProtectionCountAggregateInputType | true
    }

  export interface StreakProtectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StreakProtection'], meta: { name: 'StreakProtection' } }
    /**
     * Find zero or one StreakProtection that matches the filter.
     * @param {StreakProtectionFindUniqueArgs} args - Arguments to find a StreakProtection
     * @example
     * // Get one StreakProtection
     * const streakProtection = await prisma.streakProtection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StreakProtectionFindUniqueArgs>(args: SelectSubset<T, StreakProtectionFindUniqueArgs<ExtArgs>>): Prisma__StreakProtectionClient<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StreakProtection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StreakProtectionFindUniqueOrThrowArgs} args - Arguments to find a StreakProtection
     * @example
     * // Get one StreakProtection
     * const streakProtection = await prisma.streakProtection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StreakProtectionFindUniqueOrThrowArgs>(args: SelectSubset<T, StreakProtectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StreakProtectionClient<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StreakProtection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakProtectionFindFirstArgs} args - Arguments to find a StreakProtection
     * @example
     * // Get one StreakProtection
     * const streakProtection = await prisma.streakProtection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StreakProtectionFindFirstArgs>(args?: SelectSubset<T, StreakProtectionFindFirstArgs<ExtArgs>>): Prisma__StreakProtectionClient<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StreakProtection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakProtectionFindFirstOrThrowArgs} args - Arguments to find a StreakProtection
     * @example
     * // Get one StreakProtection
     * const streakProtection = await prisma.streakProtection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StreakProtectionFindFirstOrThrowArgs>(args?: SelectSubset<T, StreakProtectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StreakProtectionClient<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StreakProtections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakProtectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StreakProtections
     * const streakProtections = await prisma.streakProtection.findMany()
     * 
     * // Get first 10 StreakProtections
     * const streakProtections = await prisma.streakProtection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const streakProtectionWithIdOnly = await prisma.streakProtection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StreakProtectionFindManyArgs>(args?: SelectSubset<T, StreakProtectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StreakProtection.
     * @param {StreakProtectionCreateArgs} args - Arguments to create a StreakProtection.
     * @example
     * // Create one StreakProtection
     * const StreakProtection = await prisma.streakProtection.create({
     *   data: {
     *     // ... data to create a StreakProtection
     *   }
     * })
     * 
     */
    create<T extends StreakProtectionCreateArgs>(args: SelectSubset<T, StreakProtectionCreateArgs<ExtArgs>>): Prisma__StreakProtectionClient<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StreakProtections.
     * @param {StreakProtectionCreateManyArgs} args - Arguments to create many StreakProtections.
     * @example
     * // Create many StreakProtections
     * const streakProtection = await prisma.streakProtection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StreakProtectionCreateManyArgs>(args?: SelectSubset<T, StreakProtectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StreakProtections and returns the data saved in the database.
     * @param {StreakProtectionCreateManyAndReturnArgs} args - Arguments to create many StreakProtections.
     * @example
     * // Create many StreakProtections
     * const streakProtection = await prisma.streakProtection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StreakProtections and only return the `id`
     * const streakProtectionWithIdOnly = await prisma.streakProtection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StreakProtectionCreateManyAndReturnArgs>(args?: SelectSubset<T, StreakProtectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StreakProtection.
     * @param {StreakProtectionDeleteArgs} args - Arguments to delete one StreakProtection.
     * @example
     * // Delete one StreakProtection
     * const StreakProtection = await prisma.streakProtection.delete({
     *   where: {
     *     // ... filter to delete one StreakProtection
     *   }
     * })
     * 
     */
    delete<T extends StreakProtectionDeleteArgs>(args: SelectSubset<T, StreakProtectionDeleteArgs<ExtArgs>>): Prisma__StreakProtectionClient<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StreakProtection.
     * @param {StreakProtectionUpdateArgs} args - Arguments to update one StreakProtection.
     * @example
     * // Update one StreakProtection
     * const streakProtection = await prisma.streakProtection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StreakProtectionUpdateArgs>(args: SelectSubset<T, StreakProtectionUpdateArgs<ExtArgs>>): Prisma__StreakProtectionClient<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StreakProtections.
     * @param {StreakProtectionDeleteManyArgs} args - Arguments to filter StreakProtections to delete.
     * @example
     * // Delete a few StreakProtections
     * const { count } = await prisma.streakProtection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StreakProtectionDeleteManyArgs>(args?: SelectSubset<T, StreakProtectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StreakProtections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakProtectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StreakProtections
     * const streakProtection = await prisma.streakProtection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StreakProtectionUpdateManyArgs>(args: SelectSubset<T, StreakProtectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StreakProtections and returns the data updated in the database.
     * @param {StreakProtectionUpdateManyAndReturnArgs} args - Arguments to update many StreakProtections.
     * @example
     * // Update many StreakProtections
     * const streakProtection = await prisma.streakProtection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StreakProtections and only return the `id`
     * const streakProtectionWithIdOnly = await prisma.streakProtection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StreakProtectionUpdateManyAndReturnArgs>(args: SelectSubset<T, StreakProtectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StreakProtection.
     * @param {StreakProtectionUpsertArgs} args - Arguments to update or create a StreakProtection.
     * @example
     * // Update or create a StreakProtection
     * const streakProtection = await prisma.streakProtection.upsert({
     *   create: {
     *     // ... data to create a StreakProtection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StreakProtection we want to update
     *   }
     * })
     */
    upsert<T extends StreakProtectionUpsertArgs>(args: SelectSubset<T, StreakProtectionUpsertArgs<ExtArgs>>): Prisma__StreakProtectionClient<$Result.GetResult<Prisma.$StreakProtectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StreakProtections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakProtectionCountArgs} args - Arguments to filter StreakProtections to count.
     * @example
     * // Count the number of StreakProtections
     * const count = await prisma.streakProtection.count({
     *   where: {
     *     // ... the filter for the StreakProtections we want to count
     *   }
     * })
    **/
    count<T extends StreakProtectionCountArgs>(
      args?: Subset<T, StreakProtectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StreakProtectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StreakProtection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakProtectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StreakProtectionAggregateArgs>(args: Subset<T, StreakProtectionAggregateArgs>): Prisma.PrismaPromise<GetStreakProtectionAggregateType<T>>

    /**
     * Group by StreakProtection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakProtectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StreakProtectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StreakProtectionGroupByArgs['orderBy'] }
        : { orderBy?: StreakProtectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StreakProtectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStreakProtectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StreakProtection model
   */
  readonly fields: StreakProtectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StreakProtection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StreakProtectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StreakProtection model
   */
  interface StreakProtectionFieldRefs {
    readonly id: FieldRef<"StreakProtection", 'String'>
    readonly userId: FieldRef<"StreakProtection", 'String'>
    readonly expiresAt: FieldRef<"StreakProtection", 'DateTime'>
    readonly createdAt: FieldRef<"StreakProtection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StreakProtection findUnique
   */
  export type StreakProtectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
    /**
     * Filter, which StreakProtection to fetch.
     */
    where: StreakProtectionWhereUniqueInput
  }

  /**
   * StreakProtection findUniqueOrThrow
   */
  export type StreakProtectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
    /**
     * Filter, which StreakProtection to fetch.
     */
    where: StreakProtectionWhereUniqueInput
  }

  /**
   * StreakProtection findFirst
   */
  export type StreakProtectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
    /**
     * Filter, which StreakProtection to fetch.
     */
    where?: StreakProtectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreakProtections to fetch.
     */
    orderBy?: StreakProtectionOrderByWithRelationInput | StreakProtectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StreakProtections.
     */
    cursor?: StreakProtectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreakProtections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreakProtections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StreakProtections.
     */
    distinct?: StreakProtectionScalarFieldEnum | StreakProtectionScalarFieldEnum[]
  }

  /**
   * StreakProtection findFirstOrThrow
   */
  export type StreakProtectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
    /**
     * Filter, which StreakProtection to fetch.
     */
    where?: StreakProtectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreakProtections to fetch.
     */
    orderBy?: StreakProtectionOrderByWithRelationInput | StreakProtectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StreakProtections.
     */
    cursor?: StreakProtectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreakProtections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreakProtections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StreakProtections.
     */
    distinct?: StreakProtectionScalarFieldEnum | StreakProtectionScalarFieldEnum[]
  }

  /**
   * StreakProtection findMany
   */
  export type StreakProtectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
    /**
     * Filter, which StreakProtections to fetch.
     */
    where?: StreakProtectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreakProtections to fetch.
     */
    orderBy?: StreakProtectionOrderByWithRelationInput | StreakProtectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StreakProtections.
     */
    cursor?: StreakProtectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreakProtections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreakProtections.
     */
    skip?: number
    distinct?: StreakProtectionScalarFieldEnum | StreakProtectionScalarFieldEnum[]
  }

  /**
   * StreakProtection create
   */
  export type StreakProtectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
    /**
     * The data needed to create a StreakProtection.
     */
    data: XOR<StreakProtectionCreateInput, StreakProtectionUncheckedCreateInput>
  }

  /**
   * StreakProtection createMany
   */
  export type StreakProtectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StreakProtections.
     */
    data: StreakProtectionCreateManyInput | StreakProtectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StreakProtection createManyAndReturn
   */
  export type StreakProtectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * The data used to create many StreakProtections.
     */
    data: StreakProtectionCreateManyInput | StreakProtectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StreakProtection update
   */
  export type StreakProtectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
    /**
     * The data needed to update a StreakProtection.
     */
    data: XOR<StreakProtectionUpdateInput, StreakProtectionUncheckedUpdateInput>
    /**
     * Choose, which StreakProtection to update.
     */
    where: StreakProtectionWhereUniqueInput
  }

  /**
   * StreakProtection updateMany
   */
  export type StreakProtectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StreakProtections.
     */
    data: XOR<StreakProtectionUpdateManyMutationInput, StreakProtectionUncheckedUpdateManyInput>
    /**
     * Filter which StreakProtections to update
     */
    where?: StreakProtectionWhereInput
    /**
     * Limit how many StreakProtections to update.
     */
    limit?: number
  }

  /**
   * StreakProtection updateManyAndReturn
   */
  export type StreakProtectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * The data used to update StreakProtections.
     */
    data: XOR<StreakProtectionUpdateManyMutationInput, StreakProtectionUncheckedUpdateManyInput>
    /**
     * Filter which StreakProtections to update
     */
    where?: StreakProtectionWhereInput
    /**
     * Limit how many StreakProtections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StreakProtection upsert
   */
  export type StreakProtectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
    /**
     * The filter to search for the StreakProtection to update in case it exists.
     */
    where: StreakProtectionWhereUniqueInput
    /**
     * In case the StreakProtection found by the `where` argument doesn't exist, create a new StreakProtection with this data.
     */
    create: XOR<StreakProtectionCreateInput, StreakProtectionUncheckedCreateInput>
    /**
     * In case the StreakProtection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StreakProtectionUpdateInput, StreakProtectionUncheckedUpdateInput>
  }

  /**
   * StreakProtection delete
   */
  export type StreakProtectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
    /**
     * Filter which StreakProtection to delete.
     */
    where: StreakProtectionWhereUniqueInput
  }

  /**
   * StreakProtection deleteMany
   */
  export type StreakProtectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StreakProtections to delete
     */
    where?: StreakProtectionWhereInput
    /**
     * Limit how many StreakProtections to delete.
     */
    limit?: number
  }

  /**
   * StreakProtection without action
   */
  export type StreakProtectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakProtection
     */
    select?: StreakProtectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakProtection
     */
    omit?: StreakProtectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakProtectionInclude<ExtArgs> | null
  }


  /**
   * Model PlayerRanking
   */

  export type AggregatePlayerRanking = {
    _count: PlayerRankingCountAggregateOutputType | null
    _avg: PlayerRankingAvgAggregateOutputType | null
    _sum: PlayerRankingSumAggregateOutputType | null
    _min: PlayerRankingMinAggregateOutputType | null
    _max: PlayerRankingMaxAggregateOutputType | null
  }

  export type PlayerRankingAvgAggregateOutputType = {
    globalScore: number | null
    weeklyScore: number | null
    globalRank: number | null
    weeklyRank: number | null
  }

  export type PlayerRankingSumAggregateOutputType = {
    globalScore: number | null
    weeklyScore: number | null
    globalRank: number | null
    weeklyRank: number | null
  }

  export type PlayerRankingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    globalScore: number | null
    weeklyScore: number | null
    globalRank: number | null
    weeklyRank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerRankingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    globalScore: number | null
    weeklyScore: number | null
    globalRank: number | null
    weeklyRank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerRankingCountAggregateOutputType = {
    id: number
    userId: number
    globalScore: number
    weeklyScore: number
    globalRank: number
    weeklyRank: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerRankingAvgAggregateInputType = {
    globalScore?: true
    weeklyScore?: true
    globalRank?: true
    weeklyRank?: true
  }

  export type PlayerRankingSumAggregateInputType = {
    globalScore?: true
    weeklyScore?: true
    globalRank?: true
    weeklyRank?: true
  }

  export type PlayerRankingMinAggregateInputType = {
    id?: true
    userId?: true
    globalScore?: true
    weeklyScore?: true
    globalRank?: true
    weeklyRank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerRankingMaxAggregateInputType = {
    id?: true
    userId?: true
    globalScore?: true
    weeklyScore?: true
    globalRank?: true
    weeklyRank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerRankingCountAggregateInputType = {
    id?: true
    userId?: true
    globalScore?: true
    weeklyScore?: true
    globalRank?: true
    weeklyRank?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerRankingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerRanking to aggregate.
     */
    where?: PlayerRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRankings to fetch.
     */
    orderBy?: PlayerRankingOrderByWithRelationInput | PlayerRankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerRankings
    **/
    _count?: true | PlayerRankingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerRankingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerRankingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerRankingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerRankingMaxAggregateInputType
  }

  export type GetPlayerRankingAggregateType<T extends PlayerRankingAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerRanking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerRanking[P]>
      : GetScalarType<T[P], AggregatePlayerRanking[P]>
  }




  export type PlayerRankingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerRankingWhereInput
    orderBy?: PlayerRankingOrderByWithAggregationInput | PlayerRankingOrderByWithAggregationInput[]
    by: PlayerRankingScalarFieldEnum[] | PlayerRankingScalarFieldEnum
    having?: PlayerRankingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerRankingCountAggregateInputType | true
    _avg?: PlayerRankingAvgAggregateInputType
    _sum?: PlayerRankingSumAggregateInputType
    _min?: PlayerRankingMinAggregateInputType
    _max?: PlayerRankingMaxAggregateInputType
  }

  export type PlayerRankingGroupByOutputType = {
    id: string
    userId: string
    globalScore: number
    weeklyScore: number
    globalRank: number | null
    weeklyRank: number | null
    createdAt: Date
    updatedAt: Date
    _count: PlayerRankingCountAggregateOutputType | null
    _avg: PlayerRankingAvgAggregateOutputType | null
    _sum: PlayerRankingSumAggregateOutputType | null
    _min: PlayerRankingMinAggregateOutputType | null
    _max: PlayerRankingMaxAggregateOutputType | null
  }

  type GetPlayerRankingGroupByPayload<T extends PlayerRankingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerRankingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerRankingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerRankingGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerRankingGroupByOutputType[P]>
        }
      >
    >


  export type PlayerRankingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    globalScore?: boolean
    weeklyScore?: boolean
    globalRank?: boolean
    weeklyRank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerRanking"]>

  export type PlayerRankingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    globalScore?: boolean
    weeklyScore?: boolean
    globalRank?: boolean
    weeklyRank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerRanking"]>

  export type PlayerRankingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    globalScore?: boolean
    weeklyScore?: boolean
    globalRank?: boolean
    weeklyRank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerRanking"]>

  export type PlayerRankingSelectScalar = {
    id?: boolean
    userId?: boolean
    globalScore?: boolean
    weeklyScore?: boolean
    globalRank?: boolean
    weeklyRank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerRankingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "globalScore" | "weeklyScore" | "globalRank" | "weeklyRank" | "createdAt" | "updatedAt", ExtArgs["result"]["playerRanking"]>
  export type PlayerRankingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlayerRankingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlayerRankingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlayerRankingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerRanking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      globalScore: number
      weeklyScore: number
      globalRank: number | null
      weeklyRank: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerRanking"]>
    composites: {}
  }

  type PlayerRankingGetPayload<S extends boolean | null | undefined | PlayerRankingDefaultArgs> = $Result.GetResult<Prisma.$PlayerRankingPayload, S>

  type PlayerRankingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerRankingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerRankingCountAggregateInputType | true
    }

  export interface PlayerRankingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerRanking'], meta: { name: 'PlayerRanking' } }
    /**
     * Find zero or one PlayerRanking that matches the filter.
     * @param {PlayerRankingFindUniqueArgs} args - Arguments to find a PlayerRanking
     * @example
     * // Get one PlayerRanking
     * const playerRanking = await prisma.playerRanking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerRankingFindUniqueArgs>(args: SelectSubset<T, PlayerRankingFindUniqueArgs<ExtArgs>>): Prisma__PlayerRankingClient<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerRanking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerRankingFindUniqueOrThrowArgs} args - Arguments to find a PlayerRanking
     * @example
     * // Get one PlayerRanking
     * const playerRanking = await prisma.playerRanking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerRankingFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerRankingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerRankingClient<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerRanking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRankingFindFirstArgs} args - Arguments to find a PlayerRanking
     * @example
     * // Get one PlayerRanking
     * const playerRanking = await prisma.playerRanking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerRankingFindFirstArgs>(args?: SelectSubset<T, PlayerRankingFindFirstArgs<ExtArgs>>): Prisma__PlayerRankingClient<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerRanking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRankingFindFirstOrThrowArgs} args - Arguments to find a PlayerRanking
     * @example
     * // Get one PlayerRanking
     * const playerRanking = await prisma.playerRanking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerRankingFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerRankingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerRankingClient<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerRankings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRankingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerRankings
     * const playerRankings = await prisma.playerRanking.findMany()
     * 
     * // Get first 10 PlayerRankings
     * const playerRankings = await prisma.playerRanking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerRankingWithIdOnly = await prisma.playerRanking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerRankingFindManyArgs>(args?: SelectSubset<T, PlayerRankingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerRanking.
     * @param {PlayerRankingCreateArgs} args - Arguments to create a PlayerRanking.
     * @example
     * // Create one PlayerRanking
     * const PlayerRanking = await prisma.playerRanking.create({
     *   data: {
     *     // ... data to create a PlayerRanking
     *   }
     * })
     * 
     */
    create<T extends PlayerRankingCreateArgs>(args: SelectSubset<T, PlayerRankingCreateArgs<ExtArgs>>): Prisma__PlayerRankingClient<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerRankings.
     * @param {PlayerRankingCreateManyArgs} args - Arguments to create many PlayerRankings.
     * @example
     * // Create many PlayerRankings
     * const playerRanking = await prisma.playerRanking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerRankingCreateManyArgs>(args?: SelectSubset<T, PlayerRankingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerRankings and returns the data saved in the database.
     * @param {PlayerRankingCreateManyAndReturnArgs} args - Arguments to create many PlayerRankings.
     * @example
     * // Create many PlayerRankings
     * const playerRanking = await prisma.playerRanking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerRankings and only return the `id`
     * const playerRankingWithIdOnly = await prisma.playerRanking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerRankingCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerRankingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerRanking.
     * @param {PlayerRankingDeleteArgs} args - Arguments to delete one PlayerRanking.
     * @example
     * // Delete one PlayerRanking
     * const PlayerRanking = await prisma.playerRanking.delete({
     *   where: {
     *     // ... filter to delete one PlayerRanking
     *   }
     * })
     * 
     */
    delete<T extends PlayerRankingDeleteArgs>(args: SelectSubset<T, PlayerRankingDeleteArgs<ExtArgs>>): Prisma__PlayerRankingClient<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerRanking.
     * @param {PlayerRankingUpdateArgs} args - Arguments to update one PlayerRanking.
     * @example
     * // Update one PlayerRanking
     * const playerRanking = await prisma.playerRanking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerRankingUpdateArgs>(args: SelectSubset<T, PlayerRankingUpdateArgs<ExtArgs>>): Prisma__PlayerRankingClient<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerRankings.
     * @param {PlayerRankingDeleteManyArgs} args - Arguments to filter PlayerRankings to delete.
     * @example
     * // Delete a few PlayerRankings
     * const { count } = await prisma.playerRanking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerRankingDeleteManyArgs>(args?: SelectSubset<T, PlayerRankingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerRankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRankingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerRankings
     * const playerRanking = await prisma.playerRanking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerRankingUpdateManyArgs>(args: SelectSubset<T, PlayerRankingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerRankings and returns the data updated in the database.
     * @param {PlayerRankingUpdateManyAndReturnArgs} args - Arguments to update many PlayerRankings.
     * @example
     * // Update many PlayerRankings
     * const playerRanking = await prisma.playerRanking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerRankings and only return the `id`
     * const playerRankingWithIdOnly = await prisma.playerRanking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerRankingUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerRankingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerRanking.
     * @param {PlayerRankingUpsertArgs} args - Arguments to update or create a PlayerRanking.
     * @example
     * // Update or create a PlayerRanking
     * const playerRanking = await prisma.playerRanking.upsert({
     *   create: {
     *     // ... data to create a PlayerRanking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerRanking we want to update
     *   }
     * })
     */
    upsert<T extends PlayerRankingUpsertArgs>(args: SelectSubset<T, PlayerRankingUpsertArgs<ExtArgs>>): Prisma__PlayerRankingClient<$Result.GetResult<Prisma.$PlayerRankingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerRankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRankingCountArgs} args - Arguments to filter PlayerRankings to count.
     * @example
     * // Count the number of PlayerRankings
     * const count = await prisma.playerRanking.count({
     *   where: {
     *     // ... the filter for the PlayerRankings we want to count
     *   }
     * })
    **/
    count<T extends PlayerRankingCountArgs>(
      args?: Subset<T, PlayerRankingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerRankingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerRanking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRankingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerRankingAggregateArgs>(args: Subset<T, PlayerRankingAggregateArgs>): Prisma.PrismaPromise<GetPlayerRankingAggregateType<T>>

    /**
     * Group by PlayerRanking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRankingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerRankingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerRankingGroupByArgs['orderBy'] }
        : { orderBy?: PlayerRankingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerRankingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerRankingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerRanking model
   */
  readonly fields: PlayerRankingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerRanking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerRankingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerRanking model
   */
  interface PlayerRankingFieldRefs {
    readonly id: FieldRef<"PlayerRanking", 'String'>
    readonly userId: FieldRef<"PlayerRanking", 'String'>
    readonly globalScore: FieldRef<"PlayerRanking", 'Int'>
    readonly weeklyScore: FieldRef<"PlayerRanking", 'Int'>
    readonly globalRank: FieldRef<"PlayerRanking", 'Int'>
    readonly weeklyRank: FieldRef<"PlayerRanking", 'Int'>
    readonly createdAt: FieldRef<"PlayerRanking", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerRanking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerRanking findUnique
   */
  export type PlayerRankingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
    /**
     * Filter, which PlayerRanking to fetch.
     */
    where: PlayerRankingWhereUniqueInput
  }

  /**
   * PlayerRanking findUniqueOrThrow
   */
  export type PlayerRankingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
    /**
     * Filter, which PlayerRanking to fetch.
     */
    where: PlayerRankingWhereUniqueInput
  }

  /**
   * PlayerRanking findFirst
   */
  export type PlayerRankingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
    /**
     * Filter, which PlayerRanking to fetch.
     */
    where?: PlayerRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRankings to fetch.
     */
    orderBy?: PlayerRankingOrderByWithRelationInput | PlayerRankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerRankings.
     */
    cursor?: PlayerRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerRankings.
     */
    distinct?: PlayerRankingScalarFieldEnum | PlayerRankingScalarFieldEnum[]
  }

  /**
   * PlayerRanking findFirstOrThrow
   */
  export type PlayerRankingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
    /**
     * Filter, which PlayerRanking to fetch.
     */
    where?: PlayerRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRankings to fetch.
     */
    orderBy?: PlayerRankingOrderByWithRelationInput | PlayerRankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerRankings.
     */
    cursor?: PlayerRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerRankings.
     */
    distinct?: PlayerRankingScalarFieldEnum | PlayerRankingScalarFieldEnum[]
  }

  /**
   * PlayerRanking findMany
   */
  export type PlayerRankingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
    /**
     * Filter, which PlayerRankings to fetch.
     */
    where?: PlayerRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRankings to fetch.
     */
    orderBy?: PlayerRankingOrderByWithRelationInput | PlayerRankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerRankings.
     */
    cursor?: PlayerRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRankings.
     */
    skip?: number
    distinct?: PlayerRankingScalarFieldEnum | PlayerRankingScalarFieldEnum[]
  }

  /**
   * PlayerRanking create
   */
  export type PlayerRankingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerRanking.
     */
    data: XOR<PlayerRankingCreateInput, PlayerRankingUncheckedCreateInput>
  }

  /**
   * PlayerRanking createMany
   */
  export type PlayerRankingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerRankings.
     */
    data: PlayerRankingCreateManyInput | PlayerRankingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerRanking createManyAndReturn
   */
  export type PlayerRankingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerRankings.
     */
    data: PlayerRankingCreateManyInput | PlayerRankingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerRanking update
   */
  export type PlayerRankingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerRanking.
     */
    data: XOR<PlayerRankingUpdateInput, PlayerRankingUncheckedUpdateInput>
    /**
     * Choose, which PlayerRanking to update.
     */
    where: PlayerRankingWhereUniqueInput
  }

  /**
   * PlayerRanking updateMany
   */
  export type PlayerRankingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerRankings.
     */
    data: XOR<PlayerRankingUpdateManyMutationInput, PlayerRankingUncheckedUpdateManyInput>
    /**
     * Filter which PlayerRankings to update
     */
    where?: PlayerRankingWhereInput
    /**
     * Limit how many PlayerRankings to update.
     */
    limit?: number
  }

  /**
   * PlayerRanking updateManyAndReturn
   */
  export type PlayerRankingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * The data used to update PlayerRankings.
     */
    data: XOR<PlayerRankingUpdateManyMutationInput, PlayerRankingUncheckedUpdateManyInput>
    /**
     * Filter which PlayerRankings to update
     */
    where?: PlayerRankingWhereInput
    /**
     * Limit how many PlayerRankings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerRanking upsert
   */
  export type PlayerRankingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerRanking to update in case it exists.
     */
    where: PlayerRankingWhereUniqueInput
    /**
     * In case the PlayerRanking found by the `where` argument doesn't exist, create a new PlayerRanking with this data.
     */
    create: XOR<PlayerRankingCreateInput, PlayerRankingUncheckedCreateInput>
    /**
     * In case the PlayerRanking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerRankingUpdateInput, PlayerRankingUncheckedUpdateInput>
  }

  /**
   * PlayerRanking delete
   */
  export type PlayerRankingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
    /**
     * Filter which PlayerRanking to delete.
     */
    where: PlayerRankingWhereUniqueInput
  }

  /**
   * PlayerRanking deleteMany
   */
  export type PlayerRankingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerRankings to delete
     */
    where?: PlayerRankingWhereInput
    /**
     * Limit how many PlayerRankings to delete.
     */
    limit?: number
  }

  /**
   * PlayerRanking without action
   */
  export type PlayerRankingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRanking
     */
    select?: PlayerRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerRanking
     */
    omit?: PlayerRankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRankingInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balance: number | null
    lifetimeEarned: number | null
    lifetimeSpent: number | null
  }

  export type WalletSumAggregateOutputType = {
    balance: number | null
    lifetimeEarned: number | null
    lifetimeSpent: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    balance: number | null
    lifetimeEarned: number | null
    lifetimeSpent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    balance: number | null
    lifetimeEarned: number | null
    lifetimeSpent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    balance: number
    lifetimeEarned: number
    lifetimeSpent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balance?: true
    lifetimeEarned?: true
    lifetimeSpent?: true
  }

  export type WalletSumAggregateInputType = {
    balance?: true
    lifetimeEarned?: true
    lifetimeSpent?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    lifetimeEarned?: true
    lifetimeSpent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    lifetimeEarned?: true
    lifetimeSpent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    lifetimeEarned?: true
    lifetimeSpent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    userId: string
    balance: number
    lifetimeEarned: number
    lifetimeSpent: number
    createdAt: Date
    updatedAt: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    lifetimeEarned?: boolean
    lifetimeSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    lifetimeEarned?: boolean
    lifetimeSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    lifetimeEarned?: boolean
    lifetimeSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    userId?: boolean
    balance?: boolean
    lifetimeEarned?: boolean
    lifetimeSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "balance" | "lifetimeEarned" | "lifetimeSpent" | "createdAt" | "updatedAt", ExtArgs["result"]["wallet"]>
  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      balance: number
      lifetimeEarned: number
      lifetimeSpent: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {WalletUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly balance: FieldRef<"Wallet", 'Int'>
    readonly lifetimeEarned: FieldRef<"Wallet", 'Int'>
    readonly lifetimeSpent: FieldRef<"Wallet", 'Int'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet updateManyAndReturn
   */
  export type WalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
    balanceAfter: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
    balanceAfter: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    source: string | null
    description: string | null
    balanceAfter: number | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    source: string | null
    description: string | null
    balanceAfter: number | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    amount: number
    source: number
    description: number
    balanceAfter: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    balanceAfter?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    balanceAfter?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    source?: true
    description?: true
    balanceAfter?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    source?: true
    description?: true
    balanceAfter?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    source?: true
    description?: true
    balanceAfter?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.TransactionType
    amount: number
    source: string
    description: string | null
    balanceAfter: number
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    source?: boolean
    description?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    source?: boolean
    description?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    source?: boolean
    description?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    source?: boolean
    description?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "amount" | "source" | "description" | "balanceAfter" | "createdAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.TransactionType
      amount: number
      source: string
      description: string | null
      balanceAfter: number
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly amount: FieldRef<"Transaction", 'Int'>
    readonly source: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly balanceAfter: FieldRef<"Transaction", 'Int'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model ShopItem
   */

  export type AggregateShopItem = {
    _count: ShopItemCountAggregateOutputType | null
    _avg: ShopItemAvgAggregateOutputType | null
    _sum: ShopItemSumAggregateOutputType | null
    _min: ShopItemMinAggregateOutputType | null
    _max: ShopItemMaxAggregateOutputType | null
  }

  export type ShopItemAvgAggregateOutputType = {
    price: number | null
  }

  export type ShopItemSumAggregateOutputType = {
    price: number | null
  }

  export type ShopItemMinAggregateOutputType = {
    id: string | null
    type: $Enums.ShopItemType | null
    name: string | null
    description: string | null
    price: number | null
    available: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopItemMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ShopItemType | null
    name: string | null
    description: string | null
    price: number | null
    available: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopItemCountAggregateOutputType = {
    id: number
    type: number
    name: number
    description: number
    price: number
    available: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopItemAvgAggregateInputType = {
    price?: true
  }

  export type ShopItemSumAggregateInputType = {
    price?: true
  }

  export type ShopItemMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    price?: true
    available?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopItemMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    price?: true
    available?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopItemCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    price?: true
    available?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItem to aggregate.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopItems
    **/
    _count?: true | ShopItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopItemMaxAggregateInputType
  }

  export type GetShopItemAggregateType<T extends ShopItemAggregateArgs> = {
        [P in keyof T & keyof AggregateShopItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopItem[P]>
      : GetScalarType<T[P], AggregateShopItem[P]>
  }




  export type ShopItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemWhereInput
    orderBy?: ShopItemOrderByWithAggregationInput | ShopItemOrderByWithAggregationInput[]
    by: ShopItemScalarFieldEnum[] | ShopItemScalarFieldEnum
    having?: ShopItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopItemCountAggregateInputType | true
    _avg?: ShopItemAvgAggregateInputType
    _sum?: ShopItemSumAggregateInputType
    _min?: ShopItemMinAggregateInputType
    _max?: ShopItemMaxAggregateInputType
  }

  export type ShopItemGroupByOutputType = {
    id: string
    type: $Enums.ShopItemType
    name: string
    description: string
    price: number
    available: boolean
    createdAt: Date
    updatedAt: Date
    _count: ShopItemCountAggregateOutputType | null
    _avg: ShopItemAvgAggregateOutputType | null
    _sum: ShopItemSumAggregateOutputType | null
    _min: ShopItemMinAggregateOutputType | null
    _max: ShopItemMaxAggregateOutputType | null
  }

  type GetShopItemGroupByPayload<T extends ShopItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopItemGroupByOutputType[P]>
            : GetScalarType<T[P], ShopItemGroupByOutputType[P]>
        }
      >
    >


  export type ShopItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    available?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shopItem"]>

  export type ShopItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    available?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shopItem"]>

  export type ShopItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    available?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shopItem"]>

  export type ShopItemSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    available?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "description" | "price" | "available" | "createdAt" | "updatedAt", ExtArgs["result"]["shopItem"]>

  export type $ShopItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ShopItemType
      name: string
      description: string
      price: number
      available: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopItem"]>
    composites: {}
  }

  type ShopItemGetPayload<S extends boolean | null | undefined | ShopItemDefaultArgs> = $Result.GetResult<Prisma.$ShopItemPayload, S>

  type ShopItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopItemCountAggregateInputType | true
    }

  export interface ShopItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopItem'], meta: { name: 'ShopItem' } }
    /**
     * Find zero or one ShopItem that matches the filter.
     * @param {ShopItemFindUniqueArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopItemFindUniqueArgs>(args: SelectSubset<T, ShopItemFindUniqueArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopItemFindUniqueOrThrowArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindFirstArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopItemFindFirstArgs>(args?: SelectSubset<T, ShopItemFindFirstArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindFirstOrThrowArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopItems
     * const shopItems = await prisma.shopItem.findMany()
     * 
     * // Get first 10 ShopItems
     * const shopItems = await prisma.shopItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopItemWithIdOnly = await prisma.shopItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopItemFindManyArgs>(args?: SelectSubset<T, ShopItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopItem.
     * @param {ShopItemCreateArgs} args - Arguments to create a ShopItem.
     * @example
     * // Create one ShopItem
     * const ShopItem = await prisma.shopItem.create({
     *   data: {
     *     // ... data to create a ShopItem
     *   }
     * })
     * 
     */
    create<T extends ShopItemCreateArgs>(args: SelectSubset<T, ShopItemCreateArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopItems.
     * @param {ShopItemCreateManyArgs} args - Arguments to create many ShopItems.
     * @example
     * // Create many ShopItems
     * const shopItem = await prisma.shopItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopItemCreateManyArgs>(args?: SelectSubset<T, ShopItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopItems and returns the data saved in the database.
     * @param {ShopItemCreateManyAndReturnArgs} args - Arguments to create many ShopItems.
     * @example
     * // Create many ShopItems
     * const shopItem = await prisma.shopItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopItems and only return the `id`
     * const shopItemWithIdOnly = await prisma.shopItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShopItem.
     * @param {ShopItemDeleteArgs} args - Arguments to delete one ShopItem.
     * @example
     * // Delete one ShopItem
     * const ShopItem = await prisma.shopItem.delete({
     *   where: {
     *     // ... filter to delete one ShopItem
     *   }
     * })
     * 
     */
    delete<T extends ShopItemDeleteArgs>(args: SelectSubset<T, ShopItemDeleteArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopItem.
     * @param {ShopItemUpdateArgs} args - Arguments to update one ShopItem.
     * @example
     * // Update one ShopItem
     * const shopItem = await prisma.shopItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopItemUpdateArgs>(args: SelectSubset<T, ShopItemUpdateArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopItems.
     * @param {ShopItemDeleteManyArgs} args - Arguments to filter ShopItems to delete.
     * @example
     * // Delete a few ShopItems
     * const { count } = await prisma.shopItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopItemDeleteManyArgs>(args?: SelectSubset<T, ShopItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopItems
     * const shopItem = await prisma.shopItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopItemUpdateManyArgs>(args: SelectSubset<T, ShopItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopItems and returns the data updated in the database.
     * @param {ShopItemUpdateManyAndReturnArgs} args - Arguments to update many ShopItems.
     * @example
     * // Update many ShopItems
     * const shopItem = await prisma.shopItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShopItems and only return the `id`
     * const shopItemWithIdOnly = await prisma.shopItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShopItem.
     * @param {ShopItemUpsertArgs} args - Arguments to update or create a ShopItem.
     * @example
     * // Update or create a ShopItem
     * const shopItem = await prisma.shopItem.upsert({
     *   create: {
     *     // ... data to create a ShopItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopItem we want to update
     *   }
     * })
     */
    upsert<T extends ShopItemUpsertArgs>(args: SelectSubset<T, ShopItemUpsertArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemCountArgs} args - Arguments to filter ShopItems to count.
     * @example
     * // Count the number of ShopItems
     * const count = await prisma.shopItem.count({
     *   where: {
     *     // ... the filter for the ShopItems we want to count
     *   }
     * })
    **/
    count<T extends ShopItemCountArgs>(
      args?: Subset<T, ShopItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopItemAggregateArgs>(args: Subset<T, ShopItemAggregateArgs>): Prisma.PrismaPromise<GetShopItemAggregateType<T>>

    /**
     * Group by ShopItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopItemGroupByArgs['orderBy'] }
        : { orderBy?: ShopItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopItem model
   */
  readonly fields: ShopItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopItem model
   */
  interface ShopItemFieldRefs {
    readonly id: FieldRef<"ShopItem", 'String'>
    readonly type: FieldRef<"ShopItem", 'ShopItemType'>
    readonly name: FieldRef<"ShopItem", 'String'>
    readonly description: FieldRef<"ShopItem", 'String'>
    readonly price: FieldRef<"ShopItem", 'Int'>
    readonly available: FieldRef<"ShopItem", 'Boolean'>
    readonly createdAt: FieldRef<"ShopItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopItem findUnique
   */
  export type ShopItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem findUniqueOrThrow
   */
  export type ShopItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem findFirst
   */
  export type ShopItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItems.
     */
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * ShopItem findFirstOrThrow
   */
  export type ShopItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItems.
     */
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * ShopItem findMany
   */
  export type ShopItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Filter, which ShopItems to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * ShopItem create
   */
  export type ShopItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * The data needed to create a ShopItem.
     */
    data: XOR<ShopItemCreateInput, ShopItemUncheckedCreateInput>
  }

  /**
   * ShopItem createMany
   */
  export type ShopItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopItems.
     */
    data: ShopItemCreateManyInput | ShopItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopItem createManyAndReturn
   */
  export type ShopItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * The data used to create many ShopItems.
     */
    data: ShopItemCreateManyInput | ShopItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopItem update
   */
  export type ShopItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * The data needed to update a ShopItem.
     */
    data: XOR<ShopItemUpdateInput, ShopItemUncheckedUpdateInput>
    /**
     * Choose, which ShopItem to update.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem updateMany
   */
  export type ShopItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopItems.
     */
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyInput>
    /**
     * Filter which ShopItems to update
     */
    where?: ShopItemWhereInput
    /**
     * Limit how many ShopItems to update.
     */
    limit?: number
  }

  /**
   * ShopItem updateManyAndReturn
   */
  export type ShopItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * The data used to update ShopItems.
     */
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyInput>
    /**
     * Filter which ShopItems to update
     */
    where?: ShopItemWhereInput
    /**
     * Limit how many ShopItems to update.
     */
    limit?: number
  }

  /**
   * ShopItem upsert
   */
  export type ShopItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * The filter to search for the ShopItem to update in case it exists.
     */
    where: ShopItemWhereUniqueInput
    /**
     * In case the ShopItem found by the `where` argument doesn't exist, create a new ShopItem with this data.
     */
    create: XOR<ShopItemCreateInput, ShopItemUncheckedCreateInput>
    /**
     * In case the ShopItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopItemUpdateInput, ShopItemUncheckedUpdateInput>
  }

  /**
   * ShopItem delete
   */
  export type ShopItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Filter which ShopItem to delete.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem deleteMany
   */
  export type ShopItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItems to delete
     */
    where?: ShopItemWhereInput
    /**
     * Limit how many ShopItems to delete.
     */
    limit?: number
  }

  /**
   * ShopItem without action
   */
  export type ShopItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
  }


  /**
   * Model Lives
   */

  export type AggregateLives = {
    _count: LivesCountAggregateOutputType | null
    _avg: LivesAvgAggregateOutputType | null
    _sum: LivesSumAggregateOutputType | null
    _min: LivesMinAggregateOutputType | null
    _max: LivesMaxAggregateOutputType | null
  }

  export type LivesAvgAggregateOutputType = {
    currentLives: number | null
    maxLives: number | null
  }

  export type LivesSumAggregateOutputType = {
    currentLives: number | null
    maxLives: number | null
  }

  export type LivesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentLives: number | null
    maxLives: number | null
    lastRegenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LivesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentLives: number | null
    maxLives: number | null
    lastRegenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LivesCountAggregateOutputType = {
    id: number
    userId: number
    currentLives: number
    maxLives: number
    lastRegenAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LivesAvgAggregateInputType = {
    currentLives?: true
    maxLives?: true
  }

  export type LivesSumAggregateInputType = {
    currentLives?: true
    maxLives?: true
  }

  export type LivesMinAggregateInputType = {
    id?: true
    userId?: true
    currentLives?: true
    maxLives?: true
    lastRegenAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LivesMaxAggregateInputType = {
    id?: true
    userId?: true
    currentLives?: true
    maxLives?: true
    lastRegenAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LivesCountAggregateInputType = {
    id?: true
    userId?: true
    currentLives?: true
    maxLives?: true
    lastRegenAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LivesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lives to aggregate.
     */
    where?: LivesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lives to fetch.
     */
    orderBy?: LivesOrderByWithRelationInput | LivesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LivesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lives
    **/
    _count?: true | LivesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LivesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LivesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LivesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LivesMaxAggregateInputType
  }

  export type GetLivesAggregateType<T extends LivesAggregateArgs> = {
        [P in keyof T & keyof AggregateLives]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLives[P]>
      : GetScalarType<T[P], AggregateLives[P]>
  }




  export type LivesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivesWhereInput
    orderBy?: LivesOrderByWithAggregationInput | LivesOrderByWithAggregationInput[]
    by: LivesScalarFieldEnum[] | LivesScalarFieldEnum
    having?: LivesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LivesCountAggregateInputType | true
    _avg?: LivesAvgAggregateInputType
    _sum?: LivesSumAggregateInputType
    _min?: LivesMinAggregateInputType
    _max?: LivesMaxAggregateInputType
  }

  export type LivesGroupByOutputType = {
    id: string
    userId: string
    currentLives: number
    maxLives: number
    lastRegenAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LivesCountAggregateOutputType | null
    _avg: LivesAvgAggregateOutputType | null
    _sum: LivesSumAggregateOutputType | null
    _min: LivesMinAggregateOutputType | null
    _max: LivesMaxAggregateOutputType | null
  }

  type GetLivesGroupByPayload<T extends LivesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LivesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LivesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LivesGroupByOutputType[P]>
            : GetScalarType<T[P], LivesGroupByOutputType[P]>
        }
      >
    >


  export type LivesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentLives?: boolean
    maxLives?: boolean
    lastRegenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lives"]>

  export type LivesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentLives?: boolean
    maxLives?: boolean
    lastRegenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lives"]>

  export type LivesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentLives?: boolean
    maxLives?: boolean
    lastRegenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lives"]>

  export type LivesSelectScalar = {
    id?: boolean
    userId?: boolean
    currentLives?: boolean
    maxLives?: boolean
    lastRegenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LivesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "currentLives" | "maxLives" | "lastRegenAt" | "createdAt" | "updatedAt", ExtArgs["result"]["lives"]>
  export type LivesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LivesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LivesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LivesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lives"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentLives: number
      maxLives: number
      lastRegenAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lives"]>
    composites: {}
  }

  type LivesGetPayload<S extends boolean | null | undefined | LivesDefaultArgs> = $Result.GetResult<Prisma.$LivesPayload, S>

  type LivesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LivesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LivesCountAggregateInputType | true
    }

  export interface LivesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lives'], meta: { name: 'Lives' } }
    /**
     * Find zero or one Lives that matches the filter.
     * @param {LivesFindUniqueArgs} args - Arguments to find a Lives
     * @example
     * // Get one Lives
     * const lives = await prisma.lives.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LivesFindUniqueArgs>(args: SelectSubset<T, LivesFindUniqueArgs<ExtArgs>>): Prisma__LivesClient<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lives that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LivesFindUniqueOrThrowArgs} args - Arguments to find a Lives
     * @example
     * // Get one Lives
     * const lives = await prisma.lives.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LivesFindUniqueOrThrowArgs>(args: SelectSubset<T, LivesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LivesClient<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivesFindFirstArgs} args - Arguments to find a Lives
     * @example
     * // Get one Lives
     * const lives = await prisma.lives.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LivesFindFirstArgs>(args?: SelectSubset<T, LivesFindFirstArgs<ExtArgs>>): Prisma__LivesClient<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lives that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivesFindFirstOrThrowArgs} args - Arguments to find a Lives
     * @example
     * // Get one Lives
     * const lives = await prisma.lives.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LivesFindFirstOrThrowArgs>(args?: SelectSubset<T, LivesFindFirstOrThrowArgs<ExtArgs>>): Prisma__LivesClient<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lives
     * const lives = await prisma.lives.findMany()
     * 
     * // Get first 10 Lives
     * const lives = await prisma.lives.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const livesWithIdOnly = await prisma.lives.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LivesFindManyArgs>(args?: SelectSubset<T, LivesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lives.
     * @param {LivesCreateArgs} args - Arguments to create a Lives.
     * @example
     * // Create one Lives
     * const Lives = await prisma.lives.create({
     *   data: {
     *     // ... data to create a Lives
     *   }
     * })
     * 
     */
    create<T extends LivesCreateArgs>(args: SelectSubset<T, LivesCreateArgs<ExtArgs>>): Prisma__LivesClient<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lives.
     * @param {LivesCreateManyArgs} args - Arguments to create many Lives.
     * @example
     * // Create many Lives
     * const lives = await prisma.lives.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LivesCreateManyArgs>(args?: SelectSubset<T, LivesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lives and returns the data saved in the database.
     * @param {LivesCreateManyAndReturnArgs} args - Arguments to create many Lives.
     * @example
     * // Create many Lives
     * const lives = await prisma.lives.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lives and only return the `id`
     * const livesWithIdOnly = await prisma.lives.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LivesCreateManyAndReturnArgs>(args?: SelectSubset<T, LivesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lives.
     * @param {LivesDeleteArgs} args - Arguments to delete one Lives.
     * @example
     * // Delete one Lives
     * const Lives = await prisma.lives.delete({
     *   where: {
     *     // ... filter to delete one Lives
     *   }
     * })
     * 
     */
    delete<T extends LivesDeleteArgs>(args: SelectSubset<T, LivesDeleteArgs<ExtArgs>>): Prisma__LivesClient<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lives.
     * @param {LivesUpdateArgs} args - Arguments to update one Lives.
     * @example
     * // Update one Lives
     * const lives = await prisma.lives.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LivesUpdateArgs>(args: SelectSubset<T, LivesUpdateArgs<ExtArgs>>): Prisma__LivesClient<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lives.
     * @param {LivesDeleteManyArgs} args - Arguments to filter Lives to delete.
     * @example
     * // Delete a few Lives
     * const { count } = await prisma.lives.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LivesDeleteManyArgs>(args?: SelectSubset<T, LivesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lives
     * const lives = await prisma.lives.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LivesUpdateManyArgs>(args: SelectSubset<T, LivesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lives and returns the data updated in the database.
     * @param {LivesUpdateManyAndReturnArgs} args - Arguments to update many Lives.
     * @example
     * // Update many Lives
     * const lives = await prisma.lives.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lives and only return the `id`
     * const livesWithIdOnly = await prisma.lives.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LivesUpdateManyAndReturnArgs>(args: SelectSubset<T, LivesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lives.
     * @param {LivesUpsertArgs} args - Arguments to update or create a Lives.
     * @example
     * // Update or create a Lives
     * const lives = await prisma.lives.upsert({
     *   create: {
     *     // ... data to create a Lives
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lives we want to update
     *   }
     * })
     */
    upsert<T extends LivesUpsertArgs>(args: SelectSubset<T, LivesUpsertArgs<ExtArgs>>): Prisma__LivesClient<$Result.GetResult<Prisma.$LivesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivesCountArgs} args - Arguments to filter Lives to count.
     * @example
     * // Count the number of Lives
     * const count = await prisma.lives.count({
     *   where: {
     *     // ... the filter for the Lives we want to count
     *   }
     * })
    **/
    count<T extends LivesCountArgs>(
      args?: Subset<T, LivesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LivesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LivesAggregateArgs>(args: Subset<T, LivesAggregateArgs>): Prisma.PrismaPromise<GetLivesAggregateType<T>>

    /**
     * Group by Lives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LivesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LivesGroupByArgs['orderBy'] }
        : { orderBy?: LivesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LivesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLivesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lives model
   */
  readonly fields: LivesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lives.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LivesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lives model
   */
  interface LivesFieldRefs {
    readonly id: FieldRef<"Lives", 'String'>
    readonly userId: FieldRef<"Lives", 'String'>
    readonly currentLives: FieldRef<"Lives", 'Int'>
    readonly maxLives: FieldRef<"Lives", 'Int'>
    readonly lastRegenAt: FieldRef<"Lives", 'DateTime'>
    readonly createdAt: FieldRef<"Lives", 'DateTime'>
    readonly updatedAt: FieldRef<"Lives", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lives findUnique
   */
  export type LivesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
    /**
     * Filter, which Lives to fetch.
     */
    where: LivesWhereUniqueInput
  }

  /**
   * Lives findUniqueOrThrow
   */
  export type LivesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
    /**
     * Filter, which Lives to fetch.
     */
    where: LivesWhereUniqueInput
  }

  /**
   * Lives findFirst
   */
  export type LivesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
    /**
     * Filter, which Lives to fetch.
     */
    where?: LivesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lives to fetch.
     */
    orderBy?: LivesOrderByWithRelationInput | LivesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lives.
     */
    cursor?: LivesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lives.
     */
    distinct?: LivesScalarFieldEnum | LivesScalarFieldEnum[]
  }

  /**
   * Lives findFirstOrThrow
   */
  export type LivesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
    /**
     * Filter, which Lives to fetch.
     */
    where?: LivesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lives to fetch.
     */
    orderBy?: LivesOrderByWithRelationInput | LivesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lives.
     */
    cursor?: LivesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lives.
     */
    distinct?: LivesScalarFieldEnum | LivesScalarFieldEnum[]
  }

  /**
   * Lives findMany
   */
  export type LivesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
    /**
     * Filter, which Lives to fetch.
     */
    where?: LivesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lives to fetch.
     */
    orderBy?: LivesOrderByWithRelationInput | LivesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lives.
     */
    cursor?: LivesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lives.
     */
    skip?: number
    distinct?: LivesScalarFieldEnum | LivesScalarFieldEnum[]
  }

  /**
   * Lives create
   */
  export type LivesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
    /**
     * The data needed to create a Lives.
     */
    data: XOR<LivesCreateInput, LivesUncheckedCreateInput>
  }

  /**
   * Lives createMany
   */
  export type LivesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lives.
     */
    data: LivesCreateManyInput | LivesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lives createManyAndReturn
   */
  export type LivesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * The data used to create many Lives.
     */
    data: LivesCreateManyInput | LivesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lives update
   */
  export type LivesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
    /**
     * The data needed to update a Lives.
     */
    data: XOR<LivesUpdateInput, LivesUncheckedUpdateInput>
    /**
     * Choose, which Lives to update.
     */
    where: LivesWhereUniqueInput
  }

  /**
   * Lives updateMany
   */
  export type LivesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lives.
     */
    data: XOR<LivesUpdateManyMutationInput, LivesUncheckedUpdateManyInput>
    /**
     * Filter which Lives to update
     */
    where?: LivesWhereInput
    /**
     * Limit how many Lives to update.
     */
    limit?: number
  }

  /**
   * Lives updateManyAndReturn
   */
  export type LivesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * The data used to update Lives.
     */
    data: XOR<LivesUpdateManyMutationInput, LivesUncheckedUpdateManyInput>
    /**
     * Filter which Lives to update
     */
    where?: LivesWhereInput
    /**
     * Limit how many Lives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lives upsert
   */
  export type LivesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
    /**
     * The filter to search for the Lives to update in case it exists.
     */
    where: LivesWhereUniqueInput
    /**
     * In case the Lives found by the `where` argument doesn't exist, create a new Lives with this data.
     */
    create: XOR<LivesCreateInput, LivesUncheckedCreateInput>
    /**
     * In case the Lives was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LivesUpdateInput, LivesUncheckedUpdateInput>
  }

  /**
   * Lives delete
   */
  export type LivesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
    /**
     * Filter which Lives to delete.
     */
    where: LivesWhereUniqueInput
  }

  /**
   * Lives deleteMany
   */
  export type LivesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lives to delete
     */
    where?: LivesWhereInput
    /**
     * Limit how many Lives to delete.
     */
    limit?: number
  }

  /**
   * Lives without action
   */
  export type LivesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lives
     */
    select?: LivesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lives
     */
    omit?: LivesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    username: 'username',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    icon: 'icon',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const DifficultyScalarFieldEnum: {
    id: 'id',
    level: 'level',
    name: 'name',
    timePerQuestion: 'timePerQuestion',
    xpMultiplier: 'xpMultiplier',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DifficultyScalarFieldEnum = (typeof DifficultyScalarFieldEnum)[keyof typeof DifficultyScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    text: 'text',
    explanation: 'explanation',
    imageUrl: 'imageUrl',
    categoryId: 'categoryId',
    difficultyId: 'difficultyId',
    status: 'status',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const AnswerScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    text: 'text',
    isCorrect: 'isCorrect',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnswerScalarFieldEnum = (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum]


  export const QuizSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    categoryId: 'categoryId',
    difficultyId: 'difficultyId',
    status: 'status',
    score: 'score',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizSessionScalarFieldEnum = (typeof QuizSessionScalarFieldEnum)[keyof typeof QuizSessionScalarFieldEnum]


  export const SessionAnswerScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    questionId: 'questionId',
    answerId: 'answerId',
    isCorrect: 'isCorrect',
    timeSpent: 'timeSpent',
    pointsEarned: 'pointsEarned',
    timeBonus: 'timeBonus',
    answeredAt: 'answeredAt'
  };

  export type SessionAnswerScalarFieldEnum = (typeof SessionAnswerScalarFieldEnum)[keyof typeof SessionAnswerScalarFieldEnum]


  export const PlayerProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentXP: 'currentXP',
    currentLevel: 'currentLevel',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    totalQuizzes: 'totalQuizzes',
    perfectQuizzes: 'perfectQuizzes',
    totalCorrect: 'totalCorrect',
    totalAnswers: 'totalAnswers',
    lastPlayedAt: 'lastPlayedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerProgressScalarFieldEnum = (typeof PlayerProgressScalarFieldEnum)[keyof typeof PlayerProgressScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    rarity: 'rarity',
    condition: 'condition',
    coinReward: 'coinReward',
    conditionData: 'conditionData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const PlayerBadgeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    badgeId: 'badgeId',
    unlockedAt: 'unlockedAt'
  };

  export type PlayerBadgeScalarFieldEnum = (typeof PlayerBadgeScalarFieldEnum)[keyof typeof PlayerBadgeScalarFieldEnum]


  export const CategoryStatScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    categoryName: 'categoryName',
    quizzesPlayed: 'quizzesPlayed',
    correctAnswers: 'correctAnswers',
    totalAnswers: 'totalAnswers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryStatScalarFieldEnum = (typeof CategoryStatScalarFieldEnum)[keyof typeof CategoryStatScalarFieldEnum]


  export const StreakProtectionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type StreakProtectionScalarFieldEnum = (typeof StreakProtectionScalarFieldEnum)[keyof typeof StreakProtectionScalarFieldEnum]


  export const PlayerRankingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    globalScore: 'globalScore',
    weeklyScore: 'weeklyScore',
    globalRank: 'globalRank',
    weeklyRank: 'weeklyRank',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerRankingScalarFieldEnum = (typeof PlayerRankingScalarFieldEnum)[keyof typeof PlayerRankingScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    balance: 'balance',
    lifetimeEarned: 'lifetimeEarned',
    lifetimeSpent: 'lifetimeSpent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    amount: 'amount',
    source: 'source',
    description: 'description',
    balanceAfter: 'balanceAfter',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const ShopItemScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    description: 'description',
    price: 'price',
    available: 'available',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopItemScalarFieldEnum = (typeof ShopItemScalarFieldEnum)[keyof typeof ShopItemScalarFieldEnum]


  export const LivesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentLives: 'currentLives',
    maxLives: 'maxLives',
    lastRegenAt: 'lastRegenAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LivesScalarFieldEnum = (typeof LivesScalarFieldEnum)[keyof typeof LivesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'QuestionStatus'
   */
  export type EnumQuestionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionStatus'>
    


  /**
   * Reference to a field of type 'QuestionStatus[]'
   */
  export type ListEnumQuestionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


  /**
   * Reference to a field of type 'BadgeRarity'
   */
  export type EnumBadgeRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BadgeRarity'>
    


  /**
   * Reference to a field of type 'BadgeRarity[]'
   */
  export type ListEnumBadgeRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BadgeRarity[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'ShopItemType'
   */
  export type EnumShopItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShopItemType'>
    


  /**
   * Reference to a field of type 'ShopItemType[]'
   */
  export type ListEnumShopItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShopItemType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    refreshTokens?: RefreshTokenListRelationFilter
    quizSessions?: QuizSessionListRelationFilter
    playerProgress?: XOR<PlayerProgressNullableScalarRelationFilter, PlayerProgressWhereInput> | null
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    lives?: XOR<LivesNullableScalarRelationFilter, LivesWhereInput> | null
    transactions?: TransactionListRelationFilter
    playerRanking?: XOR<PlayerRankingNullableScalarRelationFilter, PlayerRankingWhereInput> | null
    createdQuestions?: QuestionListRelationFilter
    playerBadges?: PlayerBadgeListRelationFilter
    streakProtections?: StreakProtectionListRelationFilter
    categoryStats?: CategoryStatListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    quizSessions?: QuizSessionOrderByRelationAggregateInput
    playerProgress?: PlayerProgressOrderByWithRelationInput
    wallet?: WalletOrderByWithRelationInput
    lives?: LivesOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    playerRanking?: PlayerRankingOrderByWithRelationInput
    createdQuestions?: QuestionOrderByRelationAggregateInput
    playerBadges?: PlayerBadgeOrderByRelationAggregateInput
    streakProtections?: StreakProtectionOrderByRelationAggregateInput
    categoryStats?: CategoryStatOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    refreshTokens?: RefreshTokenListRelationFilter
    quizSessions?: QuizSessionListRelationFilter
    playerProgress?: XOR<PlayerProgressNullableScalarRelationFilter, PlayerProgressWhereInput> | null
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    lives?: XOR<LivesNullableScalarRelationFilter, LivesWhereInput> | null
    transactions?: TransactionListRelationFilter
    playerRanking?: XOR<PlayerRankingNullableScalarRelationFilter, PlayerRankingWhereInput> | null
    createdQuestions?: QuestionListRelationFilter
    playerBadges?: PlayerBadgeListRelationFilter
    streakProtections?: StreakProtectionListRelationFilter
    categoryStats?: CategoryStatListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    description?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    questions?: QuestionListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: QuestionOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    icon?: StringNullableFilter<"Category"> | string | null
    description?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    questions?: QuestionListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type DifficultyWhereInput = {
    AND?: DifficultyWhereInput | DifficultyWhereInput[]
    OR?: DifficultyWhereInput[]
    NOT?: DifficultyWhereInput | DifficultyWhereInput[]
    id?: StringFilter<"Difficulty"> | string
    level?: StringFilter<"Difficulty"> | string
    name?: StringFilter<"Difficulty"> | string
    timePerQuestion?: IntFilter<"Difficulty"> | number
    xpMultiplier?: FloatFilter<"Difficulty"> | number
    createdAt?: DateTimeFilter<"Difficulty"> | Date | string
    updatedAt?: DateTimeFilter<"Difficulty"> | Date | string
    questions?: QuestionListRelationFilter
    quizSessions?: QuizSessionListRelationFilter
  }

  export type DifficultyOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    name?: SortOrder
    timePerQuestion?: SortOrder
    xpMultiplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: QuestionOrderByRelationAggregateInput
    quizSessions?: QuizSessionOrderByRelationAggregateInput
  }

  export type DifficultyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    level?: string
    AND?: DifficultyWhereInput | DifficultyWhereInput[]
    OR?: DifficultyWhereInput[]
    NOT?: DifficultyWhereInput | DifficultyWhereInput[]
    name?: StringFilter<"Difficulty"> | string
    timePerQuestion?: IntFilter<"Difficulty"> | number
    xpMultiplier?: FloatFilter<"Difficulty"> | number
    createdAt?: DateTimeFilter<"Difficulty"> | Date | string
    updatedAt?: DateTimeFilter<"Difficulty"> | Date | string
    questions?: QuestionListRelationFilter
    quizSessions?: QuizSessionListRelationFilter
  }, "id" | "level">

  export type DifficultyOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    name?: SortOrder
    timePerQuestion?: SortOrder
    xpMultiplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DifficultyCountOrderByAggregateInput
    _avg?: DifficultyAvgOrderByAggregateInput
    _max?: DifficultyMaxOrderByAggregateInput
    _min?: DifficultyMinOrderByAggregateInput
    _sum?: DifficultySumOrderByAggregateInput
  }

  export type DifficultyScalarWhereWithAggregatesInput = {
    AND?: DifficultyScalarWhereWithAggregatesInput | DifficultyScalarWhereWithAggregatesInput[]
    OR?: DifficultyScalarWhereWithAggregatesInput[]
    NOT?: DifficultyScalarWhereWithAggregatesInput | DifficultyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Difficulty"> | string
    level?: StringWithAggregatesFilter<"Difficulty"> | string
    name?: StringWithAggregatesFilter<"Difficulty"> | string
    timePerQuestion?: IntWithAggregatesFilter<"Difficulty"> | number
    xpMultiplier?: FloatWithAggregatesFilter<"Difficulty"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Difficulty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Difficulty"> | Date | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    explanation?: StringFilter<"Question"> | string
    imageUrl?: StringNullableFilter<"Question"> | string | null
    categoryId?: StringFilter<"Question"> | string
    difficultyId?: StringFilter<"Question"> | string
    status?: EnumQuestionStatusFilter<"Question"> | $Enums.QuestionStatus
    createdById?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    difficulty?: XOR<DifficultyScalarRelationFilter, DifficultyWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    answers?: AnswerListRelationFilter
    sessionAnswers?: SessionAnswerListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    explanation?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    difficulty?: DifficultyOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    answers?: AnswerOrderByRelationAggregateInput
    sessionAnswers?: SessionAnswerOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    text?: StringFilter<"Question"> | string
    explanation?: StringFilter<"Question"> | string
    imageUrl?: StringNullableFilter<"Question"> | string | null
    categoryId?: StringFilter<"Question"> | string
    difficultyId?: StringFilter<"Question"> | string
    status?: EnumQuestionStatusFilter<"Question"> | $Enums.QuestionStatus
    createdById?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    difficulty?: XOR<DifficultyScalarRelationFilter, DifficultyWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    answers?: AnswerListRelationFilter
    sessionAnswers?: SessionAnswerListRelationFilter
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    explanation?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    text?: StringWithAggregatesFilter<"Question"> | string
    explanation?: StringWithAggregatesFilter<"Question"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Question"> | string | null
    categoryId?: StringWithAggregatesFilter<"Question"> | string
    difficultyId?: StringWithAggregatesFilter<"Question"> | string
    status?: EnumQuestionStatusWithAggregatesFilter<"Question"> | $Enums.QuestionStatus
    createdById?: StringWithAggregatesFilter<"Question"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
  }

  export type AnswerWhereInput = {
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    id?: StringFilter<"Answer"> | string
    questionId?: StringFilter<"Answer"> | string
    text?: StringFilter<"Answer"> | string
    isCorrect?: BoolFilter<"Answer"> | boolean
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    updatedAt?: DateTimeFilter<"Answer"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    sessionAnswers?: SessionAnswerListRelationFilter
  }

  export type AnswerOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: QuestionOrderByWithRelationInput
    sessionAnswers?: SessionAnswerOrderByRelationAggregateInput
  }

  export type AnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    questionId?: StringFilter<"Answer"> | string
    text?: StringFilter<"Answer"> | string
    isCorrect?: BoolFilter<"Answer"> | boolean
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    updatedAt?: DateTimeFilter<"Answer"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    sessionAnswers?: SessionAnswerListRelationFilter
  }, "id">

  export type AnswerOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnswerCountOrderByAggregateInput
    _max?: AnswerMaxOrderByAggregateInput
    _min?: AnswerMinOrderByAggregateInput
  }

  export type AnswerScalarWhereWithAggregatesInput = {
    AND?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    OR?: AnswerScalarWhereWithAggregatesInput[]
    NOT?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Answer"> | string
    questionId?: StringWithAggregatesFilter<"Answer"> | string
    text?: StringWithAggregatesFilter<"Answer"> | string
    isCorrect?: BoolWithAggregatesFilter<"Answer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Answer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Answer"> | Date | string
  }

  export type QuizSessionWhereInput = {
    AND?: QuizSessionWhereInput | QuizSessionWhereInput[]
    OR?: QuizSessionWhereInput[]
    NOT?: QuizSessionWhereInput | QuizSessionWhereInput[]
    id?: StringFilter<"QuizSession"> | string
    userId?: StringFilter<"QuizSession"> | string
    categoryId?: StringNullableFilter<"QuizSession"> | string | null
    difficultyId?: StringFilter<"QuizSession"> | string
    status?: EnumSessionStatusFilter<"QuizSession"> | $Enums.SessionStatus
    score?: IntFilter<"QuizSession"> | number
    startedAt?: DateTimeFilter<"QuizSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"QuizSession"> | Date | string | null
    expiresAt?: DateTimeFilter<"QuizSession"> | Date | string
    createdAt?: DateTimeFilter<"QuizSession"> | Date | string
    updatedAt?: DateTimeFilter<"QuizSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    difficulty?: XOR<DifficultyScalarRelationFilter, DifficultyWhereInput>
    answers?: SessionAnswerListRelationFilter
  }

  export type QuizSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    difficulty?: DifficultyOrderByWithRelationInput
    answers?: SessionAnswerOrderByRelationAggregateInput
  }

  export type QuizSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizSessionWhereInput | QuizSessionWhereInput[]
    OR?: QuizSessionWhereInput[]
    NOT?: QuizSessionWhereInput | QuizSessionWhereInput[]
    userId?: StringFilter<"QuizSession"> | string
    categoryId?: StringNullableFilter<"QuizSession"> | string | null
    difficultyId?: StringFilter<"QuizSession"> | string
    status?: EnumSessionStatusFilter<"QuizSession"> | $Enums.SessionStatus
    score?: IntFilter<"QuizSession"> | number
    startedAt?: DateTimeFilter<"QuizSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"QuizSession"> | Date | string | null
    expiresAt?: DateTimeFilter<"QuizSession"> | Date | string
    createdAt?: DateTimeFilter<"QuizSession"> | Date | string
    updatedAt?: DateTimeFilter<"QuizSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    difficulty?: XOR<DifficultyScalarRelationFilter, DifficultyWhereInput>
    answers?: SessionAnswerListRelationFilter
  }, "id">

  export type QuizSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizSessionCountOrderByAggregateInput
    _avg?: QuizSessionAvgOrderByAggregateInput
    _max?: QuizSessionMaxOrderByAggregateInput
    _min?: QuizSessionMinOrderByAggregateInput
    _sum?: QuizSessionSumOrderByAggregateInput
  }

  export type QuizSessionScalarWhereWithAggregatesInput = {
    AND?: QuizSessionScalarWhereWithAggregatesInput | QuizSessionScalarWhereWithAggregatesInput[]
    OR?: QuizSessionScalarWhereWithAggregatesInput[]
    NOT?: QuizSessionScalarWhereWithAggregatesInput | QuizSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizSession"> | string
    userId?: StringWithAggregatesFilter<"QuizSession"> | string
    categoryId?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    difficultyId?: StringWithAggregatesFilter<"QuizSession"> | string
    status?: EnumSessionStatusWithAggregatesFilter<"QuizSession"> | $Enums.SessionStatus
    score?: IntWithAggregatesFilter<"QuizSession"> | number
    startedAt?: DateTimeWithAggregatesFilter<"QuizSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"QuizSession"> | Date | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"QuizSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"QuizSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuizSession"> | Date | string
  }

  export type SessionAnswerWhereInput = {
    AND?: SessionAnswerWhereInput | SessionAnswerWhereInput[]
    OR?: SessionAnswerWhereInput[]
    NOT?: SessionAnswerWhereInput | SessionAnswerWhereInput[]
    id?: StringFilter<"SessionAnswer"> | string
    sessionId?: StringFilter<"SessionAnswer"> | string
    questionId?: StringFilter<"SessionAnswer"> | string
    answerId?: StringFilter<"SessionAnswer"> | string
    isCorrect?: BoolFilter<"SessionAnswer"> | boolean
    timeSpent?: IntFilter<"SessionAnswer"> | number
    pointsEarned?: IntFilter<"SessionAnswer"> | number
    timeBonus?: IntFilter<"SessionAnswer"> | number
    answeredAt?: DateTimeFilter<"SessionAnswer"> | Date | string
    session?: XOR<QuizSessionScalarRelationFilter, QuizSessionWhereInput>
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    answer?: XOR<AnswerScalarRelationFilter, AnswerWhereInput>
  }

  export type SessionAnswerOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    questionId?: SortOrder
    answerId?: SortOrder
    isCorrect?: SortOrder
    timeSpent?: SortOrder
    pointsEarned?: SortOrder
    timeBonus?: SortOrder
    answeredAt?: SortOrder
    session?: QuizSessionOrderByWithRelationInput
    question?: QuestionOrderByWithRelationInput
    answer?: AnswerOrderByWithRelationInput
  }

  export type SessionAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_questionId?: SessionAnswerSessionIdQuestionIdCompoundUniqueInput
    AND?: SessionAnswerWhereInput | SessionAnswerWhereInput[]
    OR?: SessionAnswerWhereInput[]
    NOT?: SessionAnswerWhereInput | SessionAnswerWhereInput[]
    sessionId?: StringFilter<"SessionAnswer"> | string
    questionId?: StringFilter<"SessionAnswer"> | string
    answerId?: StringFilter<"SessionAnswer"> | string
    isCorrect?: BoolFilter<"SessionAnswer"> | boolean
    timeSpent?: IntFilter<"SessionAnswer"> | number
    pointsEarned?: IntFilter<"SessionAnswer"> | number
    timeBonus?: IntFilter<"SessionAnswer"> | number
    answeredAt?: DateTimeFilter<"SessionAnswer"> | Date | string
    session?: XOR<QuizSessionScalarRelationFilter, QuizSessionWhereInput>
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    answer?: XOR<AnswerScalarRelationFilter, AnswerWhereInput>
  }, "id" | "sessionId_questionId">

  export type SessionAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    questionId?: SortOrder
    answerId?: SortOrder
    isCorrect?: SortOrder
    timeSpent?: SortOrder
    pointsEarned?: SortOrder
    timeBonus?: SortOrder
    answeredAt?: SortOrder
    _count?: SessionAnswerCountOrderByAggregateInput
    _avg?: SessionAnswerAvgOrderByAggregateInput
    _max?: SessionAnswerMaxOrderByAggregateInput
    _min?: SessionAnswerMinOrderByAggregateInput
    _sum?: SessionAnswerSumOrderByAggregateInput
  }

  export type SessionAnswerScalarWhereWithAggregatesInput = {
    AND?: SessionAnswerScalarWhereWithAggregatesInput | SessionAnswerScalarWhereWithAggregatesInput[]
    OR?: SessionAnswerScalarWhereWithAggregatesInput[]
    NOT?: SessionAnswerScalarWhereWithAggregatesInput | SessionAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionAnswer"> | string
    sessionId?: StringWithAggregatesFilter<"SessionAnswer"> | string
    questionId?: StringWithAggregatesFilter<"SessionAnswer"> | string
    answerId?: StringWithAggregatesFilter<"SessionAnswer"> | string
    isCorrect?: BoolWithAggregatesFilter<"SessionAnswer"> | boolean
    timeSpent?: IntWithAggregatesFilter<"SessionAnswer"> | number
    pointsEarned?: IntWithAggregatesFilter<"SessionAnswer"> | number
    timeBonus?: IntWithAggregatesFilter<"SessionAnswer"> | number
    answeredAt?: DateTimeWithAggregatesFilter<"SessionAnswer"> | Date | string
  }

  export type PlayerProgressWhereInput = {
    AND?: PlayerProgressWhereInput | PlayerProgressWhereInput[]
    OR?: PlayerProgressWhereInput[]
    NOT?: PlayerProgressWhereInput | PlayerProgressWhereInput[]
    id?: StringFilter<"PlayerProgress"> | string
    userId?: StringFilter<"PlayerProgress"> | string
    currentXP?: IntFilter<"PlayerProgress"> | number
    currentLevel?: IntFilter<"PlayerProgress"> | number
    currentStreak?: IntFilter<"PlayerProgress"> | number
    longestStreak?: IntFilter<"PlayerProgress"> | number
    totalQuizzes?: IntFilter<"PlayerProgress"> | number
    perfectQuizzes?: IntFilter<"PlayerProgress"> | number
    totalCorrect?: IntFilter<"PlayerProgress"> | number
    totalAnswers?: IntFilter<"PlayerProgress"> | number
    lastPlayedAt?: DateTimeNullableFilter<"PlayerProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerProgress"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PlayerProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentXP?: SortOrder
    currentLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalQuizzes?: SortOrder
    perfectQuizzes?: SortOrder
    totalCorrect?: SortOrder
    totalAnswers?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PlayerProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PlayerProgressWhereInput | PlayerProgressWhereInput[]
    OR?: PlayerProgressWhereInput[]
    NOT?: PlayerProgressWhereInput | PlayerProgressWhereInput[]
    currentXP?: IntFilter<"PlayerProgress"> | number
    currentLevel?: IntFilter<"PlayerProgress"> | number
    currentStreak?: IntFilter<"PlayerProgress"> | number
    longestStreak?: IntFilter<"PlayerProgress"> | number
    totalQuizzes?: IntFilter<"PlayerProgress"> | number
    perfectQuizzes?: IntFilter<"PlayerProgress"> | number
    totalCorrect?: IntFilter<"PlayerProgress"> | number
    totalAnswers?: IntFilter<"PlayerProgress"> | number
    lastPlayedAt?: DateTimeNullableFilter<"PlayerProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"PlayerProgress"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type PlayerProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentXP?: SortOrder
    currentLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalQuizzes?: SortOrder
    perfectQuizzes?: SortOrder
    totalCorrect?: SortOrder
    totalAnswers?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerProgressCountOrderByAggregateInput
    _avg?: PlayerProgressAvgOrderByAggregateInput
    _max?: PlayerProgressMaxOrderByAggregateInput
    _min?: PlayerProgressMinOrderByAggregateInput
    _sum?: PlayerProgressSumOrderByAggregateInput
  }

  export type PlayerProgressScalarWhereWithAggregatesInput = {
    AND?: PlayerProgressScalarWhereWithAggregatesInput | PlayerProgressScalarWhereWithAggregatesInput[]
    OR?: PlayerProgressScalarWhereWithAggregatesInput[]
    NOT?: PlayerProgressScalarWhereWithAggregatesInput | PlayerProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerProgress"> | string
    userId?: StringWithAggregatesFilter<"PlayerProgress"> | string
    currentXP?: IntWithAggregatesFilter<"PlayerProgress"> | number
    currentLevel?: IntWithAggregatesFilter<"PlayerProgress"> | number
    currentStreak?: IntWithAggregatesFilter<"PlayerProgress"> | number
    longestStreak?: IntWithAggregatesFilter<"PlayerProgress"> | number
    totalQuizzes?: IntWithAggregatesFilter<"PlayerProgress"> | number
    perfectQuizzes?: IntWithAggregatesFilter<"PlayerProgress"> | number
    totalCorrect?: IntWithAggregatesFilter<"PlayerProgress"> | number
    totalAnswers?: IntWithAggregatesFilter<"PlayerProgress"> | number
    lastPlayedAt?: DateTimeNullableWithAggregatesFilter<"PlayerProgress"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlayerProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerProgress"> | Date | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    imageUrl?: StringFilter<"Badge"> | string
    rarity?: EnumBadgeRarityFilter<"Badge"> | $Enums.BadgeRarity
    condition?: StringFilter<"Badge"> | string
    coinReward?: IntFilter<"Badge"> | number
    conditionData?: JsonFilter<"Badge">
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    updatedAt?: DateTimeFilter<"Badge"> | Date | string
    playerBadges?: PlayerBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    rarity?: SortOrder
    condition?: SortOrder
    coinReward?: SortOrder
    conditionData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    playerBadges?: PlayerBadgeOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    description?: StringFilter<"Badge"> | string
    imageUrl?: StringFilter<"Badge"> | string
    rarity?: EnumBadgeRarityFilter<"Badge"> | $Enums.BadgeRarity
    condition?: StringFilter<"Badge"> | string
    coinReward?: IntFilter<"Badge"> | number
    conditionData?: JsonFilter<"Badge">
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    updatedAt?: DateTimeFilter<"Badge"> | Date | string
    playerBadges?: PlayerBadgeListRelationFilter
  }, "id" | "name">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    rarity?: SortOrder
    condition?: SortOrder
    coinReward?: SortOrder
    conditionData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringWithAggregatesFilter<"Badge"> | string
    imageUrl?: StringWithAggregatesFilter<"Badge"> | string
    rarity?: EnumBadgeRarityWithAggregatesFilter<"Badge"> | $Enums.BadgeRarity
    condition?: StringWithAggregatesFilter<"Badge"> | string
    coinReward?: IntWithAggregatesFilter<"Badge"> | number
    conditionData?: JsonWithAggregatesFilter<"Badge">
    createdAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type PlayerBadgeWhereInput = {
    AND?: PlayerBadgeWhereInput | PlayerBadgeWhereInput[]
    OR?: PlayerBadgeWhereInput[]
    NOT?: PlayerBadgeWhereInput | PlayerBadgeWhereInput[]
    id?: StringFilter<"PlayerBadge"> | string
    userId?: StringFilter<"PlayerBadge"> | string
    badgeId?: StringFilter<"PlayerBadge"> | string
    unlockedAt?: DateTimeFilter<"PlayerBadge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }

  export type PlayerBadgeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    unlockedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
  }

  export type PlayerBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_badgeId?: PlayerBadgeUserIdBadgeIdCompoundUniqueInput
    AND?: PlayerBadgeWhereInput | PlayerBadgeWhereInput[]
    OR?: PlayerBadgeWhereInput[]
    NOT?: PlayerBadgeWhereInput | PlayerBadgeWhereInput[]
    userId?: StringFilter<"PlayerBadge"> | string
    badgeId?: StringFilter<"PlayerBadge"> | string
    unlockedAt?: DateTimeFilter<"PlayerBadge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }, "id" | "userId_badgeId">

  export type PlayerBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    unlockedAt?: SortOrder
    _count?: PlayerBadgeCountOrderByAggregateInput
    _max?: PlayerBadgeMaxOrderByAggregateInput
    _min?: PlayerBadgeMinOrderByAggregateInput
  }

  export type PlayerBadgeScalarWhereWithAggregatesInput = {
    AND?: PlayerBadgeScalarWhereWithAggregatesInput | PlayerBadgeScalarWhereWithAggregatesInput[]
    OR?: PlayerBadgeScalarWhereWithAggregatesInput[]
    NOT?: PlayerBadgeScalarWhereWithAggregatesInput | PlayerBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerBadge"> | string
    userId?: StringWithAggregatesFilter<"PlayerBadge"> | string
    badgeId?: StringWithAggregatesFilter<"PlayerBadge"> | string
    unlockedAt?: DateTimeWithAggregatesFilter<"PlayerBadge"> | Date | string
  }

  export type CategoryStatWhereInput = {
    AND?: CategoryStatWhereInput | CategoryStatWhereInput[]
    OR?: CategoryStatWhereInput[]
    NOT?: CategoryStatWhereInput | CategoryStatWhereInput[]
    id?: StringFilter<"CategoryStat"> | string
    userId?: StringFilter<"CategoryStat"> | string
    categoryName?: StringFilter<"CategoryStat"> | string
    quizzesPlayed?: IntFilter<"CategoryStat"> | number
    correctAnswers?: IntFilter<"CategoryStat"> | number
    totalAnswers?: IntFilter<"CategoryStat"> | number
    createdAt?: DateTimeFilter<"CategoryStat"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryStat"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CategoryStatOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryName?: SortOrder
    quizzesPlayed?: SortOrder
    correctAnswers?: SortOrder
    totalAnswers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CategoryStatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_categoryName?: CategoryStatUserIdCategoryNameCompoundUniqueInput
    AND?: CategoryStatWhereInput | CategoryStatWhereInput[]
    OR?: CategoryStatWhereInput[]
    NOT?: CategoryStatWhereInput | CategoryStatWhereInput[]
    userId?: StringFilter<"CategoryStat"> | string
    categoryName?: StringFilter<"CategoryStat"> | string
    quizzesPlayed?: IntFilter<"CategoryStat"> | number
    correctAnswers?: IntFilter<"CategoryStat"> | number
    totalAnswers?: IntFilter<"CategoryStat"> | number
    createdAt?: DateTimeFilter<"CategoryStat"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryStat"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_categoryName">

  export type CategoryStatOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryName?: SortOrder
    quizzesPlayed?: SortOrder
    correctAnswers?: SortOrder
    totalAnswers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryStatCountOrderByAggregateInput
    _avg?: CategoryStatAvgOrderByAggregateInput
    _max?: CategoryStatMaxOrderByAggregateInput
    _min?: CategoryStatMinOrderByAggregateInput
    _sum?: CategoryStatSumOrderByAggregateInput
  }

  export type CategoryStatScalarWhereWithAggregatesInput = {
    AND?: CategoryStatScalarWhereWithAggregatesInput | CategoryStatScalarWhereWithAggregatesInput[]
    OR?: CategoryStatScalarWhereWithAggregatesInput[]
    NOT?: CategoryStatScalarWhereWithAggregatesInput | CategoryStatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CategoryStat"> | string
    userId?: StringWithAggregatesFilter<"CategoryStat"> | string
    categoryName?: StringWithAggregatesFilter<"CategoryStat"> | string
    quizzesPlayed?: IntWithAggregatesFilter<"CategoryStat"> | number
    correctAnswers?: IntWithAggregatesFilter<"CategoryStat"> | number
    totalAnswers?: IntWithAggregatesFilter<"CategoryStat"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CategoryStat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CategoryStat"> | Date | string
  }

  export type StreakProtectionWhereInput = {
    AND?: StreakProtectionWhereInput | StreakProtectionWhereInput[]
    OR?: StreakProtectionWhereInput[]
    NOT?: StreakProtectionWhereInput | StreakProtectionWhereInput[]
    id?: StringFilter<"StreakProtection"> | string
    userId?: StringFilter<"StreakProtection"> | string
    expiresAt?: DateTimeFilter<"StreakProtection"> | Date | string
    createdAt?: DateTimeFilter<"StreakProtection"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StreakProtectionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StreakProtectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StreakProtectionWhereInput | StreakProtectionWhereInput[]
    OR?: StreakProtectionWhereInput[]
    NOT?: StreakProtectionWhereInput | StreakProtectionWhereInput[]
    userId?: StringFilter<"StreakProtection"> | string
    expiresAt?: DateTimeFilter<"StreakProtection"> | Date | string
    createdAt?: DateTimeFilter<"StreakProtection"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type StreakProtectionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: StreakProtectionCountOrderByAggregateInput
    _max?: StreakProtectionMaxOrderByAggregateInput
    _min?: StreakProtectionMinOrderByAggregateInput
  }

  export type StreakProtectionScalarWhereWithAggregatesInput = {
    AND?: StreakProtectionScalarWhereWithAggregatesInput | StreakProtectionScalarWhereWithAggregatesInput[]
    OR?: StreakProtectionScalarWhereWithAggregatesInput[]
    NOT?: StreakProtectionScalarWhereWithAggregatesInput | StreakProtectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StreakProtection"> | string
    userId?: StringWithAggregatesFilter<"StreakProtection"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"StreakProtection"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"StreakProtection"> | Date | string
  }

  export type PlayerRankingWhereInput = {
    AND?: PlayerRankingWhereInput | PlayerRankingWhereInput[]
    OR?: PlayerRankingWhereInput[]
    NOT?: PlayerRankingWhereInput | PlayerRankingWhereInput[]
    id?: StringFilter<"PlayerRanking"> | string
    userId?: StringFilter<"PlayerRanking"> | string
    globalScore?: IntFilter<"PlayerRanking"> | number
    weeklyScore?: IntFilter<"PlayerRanking"> | number
    globalRank?: IntNullableFilter<"PlayerRanking"> | number | null
    weeklyRank?: IntNullableFilter<"PlayerRanking"> | number | null
    createdAt?: DateTimeFilter<"PlayerRanking"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerRanking"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PlayerRankingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    globalScore?: SortOrder
    weeklyScore?: SortOrder
    globalRank?: SortOrderInput | SortOrder
    weeklyRank?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PlayerRankingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PlayerRankingWhereInput | PlayerRankingWhereInput[]
    OR?: PlayerRankingWhereInput[]
    NOT?: PlayerRankingWhereInput | PlayerRankingWhereInput[]
    globalScore?: IntFilter<"PlayerRanking"> | number
    weeklyScore?: IntFilter<"PlayerRanking"> | number
    globalRank?: IntNullableFilter<"PlayerRanking"> | number | null
    weeklyRank?: IntNullableFilter<"PlayerRanking"> | number | null
    createdAt?: DateTimeFilter<"PlayerRanking"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerRanking"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type PlayerRankingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    globalScore?: SortOrder
    weeklyScore?: SortOrder
    globalRank?: SortOrderInput | SortOrder
    weeklyRank?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerRankingCountOrderByAggregateInput
    _avg?: PlayerRankingAvgOrderByAggregateInput
    _max?: PlayerRankingMaxOrderByAggregateInput
    _min?: PlayerRankingMinOrderByAggregateInput
    _sum?: PlayerRankingSumOrderByAggregateInput
  }

  export type PlayerRankingScalarWhereWithAggregatesInput = {
    AND?: PlayerRankingScalarWhereWithAggregatesInput | PlayerRankingScalarWhereWithAggregatesInput[]
    OR?: PlayerRankingScalarWhereWithAggregatesInput[]
    NOT?: PlayerRankingScalarWhereWithAggregatesInput | PlayerRankingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerRanking"> | string
    userId?: StringWithAggregatesFilter<"PlayerRanking"> | string
    globalScore?: IntWithAggregatesFilter<"PlayerRanking"> | number
    weeklyScore?: IntWithAggregatesFilter<"PlayerRanking"> | number
    globalRank?: IntNullableWithAggregatesFilter<"PlayerRanking"> | number | null
    weeklyRank?: IntNullableWithAggregatesFilter<"PlayerRanking"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PlayerRanking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerRanking"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    balance?: IntFilter<"Wallet"> | number
    lifetimeEarned?: IntFilter<"Wallet"> | number
    lifetimeSpent?: IntFilter<"Wallet"> | number
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    lifetimeEarned?: SortOrder
    lifetimeSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    balance?: IntFilter<"Wallet"> | number
    lifetimeEarned?: IntFilter<"Wallet"> | number
    lifetimeSpent?: IntFilter<"Wallet"> | number
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    lifetimeEarned?: SortOrder
    lifetimeSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    userId?: StringWithAggregatesFilter<"Wallet"> | string
    balance?: IntWithAggregatesFilter<"Wallet"> | number
    lifetimeEarned?: IntWithAggregatesFilter<"Wallet"> | number
    lifetimeSpent?: IntWithAggregatesFilter<"Wallet"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntFilter<"Transaction"> | number
    source?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    balanceAfter?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    description?: SortOrderInput | SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntFilter<"Transaction"> | number
    source?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    balanceAfter?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    description?: SortOrderInput | SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntWithAggregatesFilter<"Transaction"> | number
    source?: StringWithAggregatesFilter<"Transaction"> | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    balanceAfter?: IntWithAggregatesFilter<"Transaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type ShopItemWhereInput = {
    AND?: ShopItemWhereInput | ShopItemWhereInput[]
    OR?: ShopItemWhereInput[]
    NOT?: ShopItemWhereInput | ShopItemWhereInput[]
    id?: StringFilter<"ShopItem"> | string
    type?: EnumShopItemTypeFilter<"ShopItem"> | $Enums.ShopItemType
    name?: StringFilter<"ShopItem"> | string
    description?: StringFilter<"ShopItem"> | string
    price?: IntFilter<"ShopItem"> | number
    available?: BoolFilter<"ShopItem"> | boolean
    createdAt?: DateTimeFilter<"ShopItem"> | Date | string
    updatedAt?: DateTimeFilter<"ShopItem"> | Date | string
  }

  export type ShopItemOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopItemWhereInput | ShopItemWhereInput[]
    OR?: ShopItemWhereInput[]
    NOT?: ShopItemWhereInput | ShopItemWhereInput[]
    type?: EnumShopItemTypeFilter<"ShopItem"> | $Enums.ShopItemType
    name?: StringFilter<"ShopItem"> | string
    description?: StringFilter<"ShopItem"> | string
    price?: IntFilter<"ShopItem"> | number
    available?: BoolFilter<"ShopItem"> | boolean
    createdAt?: DateTimeFilter<"ShopItem"> | Date | string
    updatedAt?: DateTimeFilter<"ShopItem"> | Date | string
  }, "id">

  export type ShopItemOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopItemCountOrderByAggregateInput
    _avg?: ShopItemAvgOrderByAggregateInput
    _max?: ShopItemMaxOrderByAggregateInput
    _min?: ShopItemMinOrderByAggregateInput
    _sum?: ShopItemSumOrderByAggregateInput
  }

  export type ShopItemScalarWhereWithAggregatesInput = {
    AND?: ShopItemScalarWhereWithAggregatesInput | ShopItemScalarWhereWithAggregatesInput[]
    OR?: ShopItemScalarWhereWithAggregatesInput[]
    NOT?: ShopItemScalarWhereWithAggregatesInput | ShopItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopItem"> | string
    type?: EnumShopItemTypeWithAggregatesFilter<"ShopItem"> | $Enums.ShopItemType
    name?: StringWithAggregatesFilter<"ShopItem"> | string
    description?: StringWithAggregatesFilter<"ShopItem"> | string
    price?: IntWithAggregatesFilter<"ShopItem"> | number
    available?: BoolWithAggregatesFilter<"ShopItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ShopItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopItem"> | Date | string
  }

  export type LivesWhereInput = {
    AND?: LivesWhereInput | LivesWhereInput[]
    OR?: LivesWhereInput[]
    NOT?: LivesWhereInput | LivesWhereInput[]
    id?: StringFilter<"Lives"> | string
    userId?: StringFilter<"Lives"> | string
    currentLives?: IntFilter<"Lives"> | number
    maxLives?: IntFilter<"Lives"> | number
    lastRegenAt?: DateTimeNullableFilter<"Lives"> | Date | string | null
    createdAt?: DateTimeFilter<"Lives"> | Date | string
    updatedAt?: DateTimeFilter<"Lives"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LivesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLives?: SortOrder
    maxLives?: SortOrder
    lastRegenAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LivesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: LivesWhereInput | LivesWhereInput[]
    OR?: LivesWhereInput[]
    NOT?: LivesWhereInput | LivesWhereInput[]
    currentLives?: IntFilter<"Lives"> | number
    maxLives?: IntFilter<"Lives"> | number
    lastRegenAt?: DateTimeNullableFilter<"Lives"> | Date | string | null
    createdAt?: DateTimeFilter<"Lives"> | Date | string
    updatedAt?: DateTimeFilter<"Lives"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type LivesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLives?: SortOrder
    maxLives?: SortOrder
    lastRegenAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LivesCountOrderByAggregateInput
    _avg?: LivesAvgOrderByAggregateInput
    _max?: LivesMaxOrderByAggregateInput
    _min?: LivesMinOrderByAggregateInput
    _sum?: LivesSumOrderByAggregateInput
  }

  export type LivesScalarWhereWithAggregatesInput = {
    AND?: LivesScalarWhereWithAggregatesInput | LivesScalarWhereWithAggregatesInput[]
    OR?: LivesScalarWhereWithAggregatesInput[]
    NOT?: LivesScalarWhereWithAggregatesInput | LivesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lives"> | string
    userId?: StringWithAggregatesFilter<"Lives"> | string
    currentLives?: IntWithAggregatesFilter<"Lives"> | number
    maxLives?: IntWithAggregatesFilter<"Lives"> | number
    lastRegenAt?: DateTimeNullableWithAggregatesFilter<"Lives"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lives"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lives"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DifficultyCreateInput = {
    id?: string
    level: string
    name: string
    timePerQuestion: number
    xpMultiplier: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionCreateNestedManyWithoutDifficultyInput
    quizSessions?: QuizSessionCreateNestedManyWithoutDifficultyInput
  }

  export type DifficultyUncheckedCreateInput = {
    id?: string
    level: string
    name: string
    timePerQuestion: number
    xpMultiplier: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutDifficultyInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutDifficultyInput
  }

  export type DifficultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timePerQuestion?: IntFieldUpdateOperationsInput | number
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutDifficultyNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutDifficultyNestedInput
  }

  export type DifficultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timePerQuestion?: IntFieldUpdateOperationsInput | number
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutDifficultyNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutDifficultyNestedInput
  }

  export type DifficultyCreateManyInput = {
    id?: string
    level: string
    name: string
    timePerQuestion: number
    xpMultiplier: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DifficultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timePerQuestion?: IntFieldUpdateOperationsInput | number
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DifficultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timePerQuestion?: IntFieldUpdateOperationsInput | number
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    status?: $Enums.QuestionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutQuestionsInput
    difficulty: DifficultyCreateNestedOneWithoutQuestionsInput
    createdBy: UserCreateNestedOneWithoutCreatedQuestionsInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    sessionAnswers?: SessionAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    categoryId: string
    difficultyId: string
    status?: $Enums.QuestionStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    sessionAnswers?: SessionAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutQuestionsNestedInput
    difficulty?: DifficultyUpdateOneRequiredWithoutQuestionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    sessionAnswers?: SessionAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    sessionAnswers?: SessionAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    categoryId: string
    difficultyId: string
    status?: $Enums.QuestionStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerCreateInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutAnswersInput
    sessionAnswers?: SessionAnswerCreateNestedManyWithoutAnswerInput
  }

  export type AnswerUncheckedCreateInput = {
    id?: string
    questionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionAnswers?: SessionAnswerUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type AnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    sessionAnswers?: SessionAnswerUpdateManyWithoutAnswerNestedInput
  }

  export type AnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionAnswers?: SessionAnswerUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type AnswerCreateManyInput = {
    id?: string
    questionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSessionCreateInput = {
    id?: string
    categoryId?: string | null
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutQuizSessionsInput
    difficulty: DifficultyCreateNestedOneWithoutQuizSessionsInput
    answers?: SessionAnswerCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionUncheckedCreateInput = {
    id?: string
    userId: string
    categoryId?: string | null
    difficultyId: string
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: SessionAnswerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutQuizSessionsNestedInput
    difficulty?: DifficultyUpdateOneRequiredWithoutQuizSessionsNestedInput
    answers?: SessionAnswerUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: SessionAnswerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionCreateManyInput = {
    id?: string
    userId: string
    categoryId?: string | null
    difficultyId: string
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionAnswerCreateInput = {
    id?: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
    session: QuizSessionCreateNestedOneWithoutAnswersInput
    question: QuestionCreateNestedOneWithoutSessionAnswersInput
    answer: AnswerCreateNestedOneWithoutSessionAnswersInput
  }

  export type SessionAnswerUncheckedCreateInput = {
    id?: string
    sessionId: string
    questionId: string
    answerId: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
  }

  export type SessionAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: QuizSessionUpdateOneRequiredWithoutAnswersNestedInput
    question?: QuestionUpdateOneRequiredWithoutSessionAnswersNestedInput
    answer?: AnswerUpdateOneRequiredWithoutSessionAnswersNestedInput
  }

  export type SessionAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionAnswerCreateManyInput = {
    id?: string
    sessionId: string
    questionId: string
    answerId: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
  }

  export type SessionAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerProgressCreateInput = {
    id?: string
    currentXP?: number
    currentLevel?: number
    currentStreak?: number
    longestStreak?: number
    totalQuizzes?: number
    perfectQuizzes?: number
    totalCorrect?: number
    totalAnswers?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerProgressInput
  }

  export type PlayerProgressUncheckedCreateInput = {
    id?: string
    userId: string
    currentXP?: number
    currentLevel?: number
    currentStreak?: number
    longestStreak?: number
    totalQuizzes?: number
    perfectQuizzes?: number
    totalCorrect?: number
    totalAnswers?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalQuizzes?: IntFieldUpdateOperationsInput | number
    perfectQuizzes?: IntFieldUpdateOperationsInput | number
    totalCorrect?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerProgressNestedInput
  }

  export type PlayerProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalQuizzes?: IntFieldUpdateOperationsInput | number
    perfectQuizzes?: IntFieldUpdateOperationsInput | number
    totalCorrect?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerProgressCreateManyInput = {
    id?: string
    userId: string
    currentXP?: number
    currentLevel?: number
    currentStreak?: number
    longestStreak?: number
    totalQuizzes?: number
    perfectQuizzes?: number
    totalCorrect?: number
    totalAnswers?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalQuizzes?: IntFieldUpdateOperationsInput | number
    perfectQuizzes?: IntFieldUpdateOperationsInput | number
    totalCorrect?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalQuizzes?: IntFieldUpdateOperationsInput | number
    perfectQuizzes?: IntFieldUpdateOperationsInput | number
    totalCorrect?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateInput = {
    id?: string
    name: string
    description: string
    imageUrl: string
    rarity: $Enums.BadgeRarity
    condition: string
    coinReward?: number
    conditionData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    playerBadges?: PlayerBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    imageUrl: string
    rarity: $Enums.BadgeRarity
    condition: string
    coinReward?: number
    conditionData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    condition?: StringFieldUpdateOperationsInput | string
    coinReward?: IntFieldUpdateOperationsInput | number
    conditionData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerBadges?: PlayerBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    condition?: StringFieldUpdateOperationsInput | string
    coinReward?: IntFieldUpdateOperationsInput | number
    conditionData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    name: string
    description: string
    imageUrl: string
    rarity: $Enums.BadgeRarity
    condition: string
    coinReward?: number
    conditionData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    condition?: StringFieldUpdateOperationsInput | string
    coinReward?: IntFieldUpdateOperationsInput | number
    conditionData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    condition?: StringFieldUpdateOperationsInput | string
    coinReward?: IntFieldUpdateOperationsInput | number
    conditionData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBadgeCreateInput = {
    id?: string
    unlockedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerBadgesInput
    badge: BadgeCreateNestedOneWithoutPlayerBadgesInput
  }

  export type PlayerBadgeUncheckedCreateInput = {
    id?: string
    userId: string
    badgeId: string
    unlockedAt?: Date | string
  }

  export type PlayerBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerBadgesNestedInput
    badge?: BadgeUpdateOneRequiredWithoutPlayerBadgesNestedInput
  }

  export type PlayerBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBadgeCreateManyInput = {
    id?: string
    userId: string
    badgeId: string
    unlockedAt?: Date | string
  }

  export type PlayerBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryStatCreateInput = {
    id?: string
    categoryName: string
    quizzesPlayed?: number
    correctAnswers?: number
    totalAnswers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCategoryStatsInput
  }

  export type CategoryStatUncheckedCreateInput = {
    id?: string
    userId: string
    categoryName: string
    quizzesPlayed?: number
    correctAnswers?: number
    totalAnswers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryStatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    quizzesPlayed?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCategoryStatsNestedInput
  }

  export type CategoryStatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    quizzesPlayed?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryStatCreateManyInput = {
    id?: string
    userId: string
    categoryName: string
    quizzesPlayed?: number
    correctAnswers?: number
    totalAnswers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryStatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    quizzesPlayed?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryStatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    quizzesPlayed?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakProtectionCreateInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStreakProtectionsInput
  }

  export type StreakProtectionUncheckedCreateInput = {
    id?: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type StreakProtectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStreakProtectionsNestedInput
  }

  export type StreakProtectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakProtectionCreateManyInput = {
    id?: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type StreakProtectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakProtectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerRankingCreateInput = {
    id?: string
    globalScore?: number
    weeklyScore?: number
    globalRank?: number | null
    weeklyRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerRankingInput
  }

  export type PlayerRankingUncheckedCreateInput = {
    id?: string
    userId: string
    globalScore?: number
    weeklyScore?: number
    globalRank?: number | null
    weeklyRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerRankingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    globalScore?: IntFieldUpdateOperationsInput | number
    weeklyScore?: IntFieldUpdateOperationsInput | number
    globalRank?: NullableIntFieldUpdateOperationsInput | number | null
    weeklyRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerRankingNestedInput
  }

  export type PlayerRankingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    globalScore?: IntFieldUpdateOperationsInput | number
    weeklyScore?: IntFieldUpdateOperationsInput | number
    globalRank?: NullableIntFieldUpdateOperationsInput | number | null
    weeklyRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerRankingCreateManyInput = {
    id?: string
    userId: string
    globalScore?: number
    weeklyScore?: number
    globalRank?: number | null
    weeklyRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerRankingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    globalScore?: IntFieldUpdateOperationsInput | number
    weeklyScore?: IntFieldUpdateOperationsInput | number
    globalRank?: NullableIntFieldUpdateOperationsInput | number | null
    weeklyRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerRankingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    globalScore?: IntFieldUpdateOperationsInput | number
    weeklyScore?: IntFieldUpdateOperationsInput | number
    globalRank?: NullableIntFieldUpdateOperationsInput | number | null
    weeklyRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    balance?: number
    lifetimeEarned?: number
    lifetimeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    userId: string
    balance?: number
    lifetimeEarned?: number
    lifetimeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    lifetimeEarned?: IntFieldUpdateOperationsInput | number
    lifetimeSpent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    lifetimeEarned?: IntFieldUpdateOperationsInput | number
    lifetimeSpent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateManyInput = {
    id?: string
    userId: string
    balance?: number
    lifetimeEarned?: number
    lifetimeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    lifetimeEarned?: IntFieldUpdateOperationsInput | number
    lifetimeSpent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    lifetimeEarned?: IntFieldUpdateOperationsInput | number
    lifetimeSpent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    source: string
    description?: string | null
    balanceAfter: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.TransactionType
    amount: number
    source: string
    description?: string | null
    balanceAfter: number
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.TransactionType
    amount: number
    source: string
    description?: string | null
    balanceAfter: number
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemCreateInput = {
    id?: string
    type: $Enums.ShopItemType
    name: string
    description: string
    price: number
    available?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopItemUncheckedCreateInput = {
    id?: string
    type: $Enums.ShopItemType
    name: string
    description: string
    price: number
    available?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShopItemTypeFieldUpdateOperationsInput | $Enums.ShopItemType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShopItemTypeFieldUpdateOperationsInput | $Enums.ShopItemType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemCreateManyInput = {
    id?: string
    type: $Enums.ShopItemType
    name: string
    description: string
    price: number
    available?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShopItemTypeFieldUpdateOperationsInput | $Enums.ShopItemType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShopItemTypeFieldUpdateOperationsInput | $Enums.ShopItemType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivesCreateInput = {
    id?: string
    currentLives?: number
    maxLives?: number
    lastRegenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLivesInput
  }

  export type LivesUncheckedCreateInput = {
    id?: string
    userId: string
    currentLives?: number
    maxLives?: number
    lastRegenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LivesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLives?: IntFieldUpdateOperationsInput | number
    maxLives?: IntFieldUpdateOperationsInput | number
    lastRegenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLivesNestedInput
  }

  export type LivesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentLives?: IntFieldUpdateOperationsInput | number
    maxLives?: IntFieldUpdateOperationsInput | number
    lastRegenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivesCreateManyInput = {
    id?: string
    userId: string
    currentLives?: number
    maxLives?: number
    lastRegenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LivesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLives?: IntFieldUpdateOperationsInput | number
    maxLives?: IntFieldUpdateOperationsInput | number
    lastRegenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentLives?: IntFieldUpdateOperationsInput | number
    maxLives?: IntFieldUpdateOperationsInput | number
    lastRegenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type QuizSessionListRelationFilter = {
    every?: QuizSessionWhereInput
    some?: QuizSessionWhereInput
    none?: QuizSessionWhereInput
  }

  export type PlayerProgressNullableScalarRelationFilter = {
    is?: PlayerProgressWhereInput | null
    isNot?: PlayerProgressWhereInput | null
  }

  export type WalletNullableScalarRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type LivesNullableScalarRelationFilter = {
    is?: LivesWhereInput | null
    isNot?: LivesWhereInput | null
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type PlayerRankingNullableScalarRelationFilter = {
    is?: PlayerRankingWhereInput | null
    isNot?: PlayerRankingWhereInput | null
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type PlayerBadgeListRelationFilter = {
    every?: PlayerBadgeWhereInput
    some?: PlayerBadgeWhereInput
    none?: PlayerBadgeWhereInput
  }

  export type StreakProtectionListRelationFilter = {
    every?: StreakProtectionWhereInput
    some?: StreakProtectionWhereInput
    none?: StreakProtectionWhereInput
  }

  export type CategoryStatListRelationFilter = {
    every?: CategoryStatWhereInput
    some?: CategoryStatWhereInput
    none?: CategoryStatWhereInput
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StreakProtectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryStatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DifficultyCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    name?: SortOrder
    timePerQuestion?: SortOrder
    xpMultiplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DifficultyAvgOrderByAggregateInput = {
    timePerQuestion?: SortOrder
    xpMultiplier?: SortOrder
  }

  export type DifficultyMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    name?: SortOrder
    timePerQuestion?: SortOrder
    xpMultiplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DifficultyMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    name?: SortOrder
    timePerQuestion?: SortOrder
    xpMultiplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DifficultySumOrderByAggregateInput = {
    timePerQuestion?: SortOrder
    xpMultiplier?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumQuestionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusFilter<$PrismaModel> | $Enums.QuestionStatus
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type DifficultyScalarRelationFilter = {
    is?: DifficultyWhereInput
    isNot?: DifficultyWhereInput
  }

  export type AnswerListRelationFilter = {
    every?: AnswerWhereInput
    some?: AnswerWhereInput
    none?: AnswerWhereInput
  }

  export type SessionAnswerListRelationFilter = {
    every?: SessionAnswerWhereInput
    some?: SessionAnswerWhereInput
    none?: SessionAnswerWhereInput
  }

  export type AnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    explanation?: SortOrder
    imageUrl?: SortOrder
    categoryId?: SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    explanation?: SortOrder
    imageUrl?: SortOrder
    categoryId?: SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    explanation?: SortOrder
    imageUrl?: SortOrder
    categoryId?: SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumQuestionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestionStatusFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type QuestionScalarRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type AnswerCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnswerMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type QuizSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSessionAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type QuizSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSessionSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type QuizSessionScalarRelationFilter = {
    is?: QuizSessionWhereInput
    isNot?: QuizSessionWhereInput
  }

  export type AnswerScalarRelationFilter = {
    is?: AnswerWhereInput
    isNot?: AnswerWhereInput
  }

  export type SessionAnswerSessionIdQuestionIdCompoundUniqueInput = {
    sessionId: string
    questionId: string
  }

  export type SessionAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    questionId?: SortOrder
    answerId?: SortOrder
    isCorrect?: SortOrder
    timeSpent?: SortOrder
    pointsEarned?: SortOrder
    timeBonus?: SortOrder
    answeredAt?: SortOrder
  }

  export type SessionAnswerAvgOrderByAggregateInput = {
    timeSpent?: SortOrder
    pointsEarned?: SortOrder
    timeBonus?: SortOrder
  }

  export type SessionAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    questionId?: SortOrder
    answerId?: SortOrder
    isCorrect?: SortOrder
    timeSpent?: SortOrder
    pointsEarned?: SortOrder
    timeBonus?: SortOrder
    answeredAt?: SortOrder
  }

  export type SessionAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    questionId?: SortOrder
    answerId?: SortOrder
    isCorrect?: SortOrder
    timeSpent?: SortOrder
    pointsEarned?: SortOrder
    timeBonus?: SortOrder
    answeredAt?: SortOrder
  }

  export type SessionAnswerSumOrderByAggregateInput = {
    timeSpent?: SortOrder
    pointsEarned?: SortOrder
    timeBonus?: SortOrder
  }

  export type PlayerProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentXP?: SortOrder
    currentLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalQuizzes?: SortOrder
    perfectQuizzes?: SortOrder
    totalCorrect?: SortOrder
    totalAnswers?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerProgressAvgOrderByAggregateInput = {
    currentXP?: SortOrder
    currentLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalQuizzes?: SortOrder
    perfectQuizzes?: SortOrder
    totalCorrect?: SortOrder
    totalAnswers?: SortOrder
  }

  export type PlayerProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentXP?: SortOrder
    currentLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalQuizzes?: SortOrder
    perfectQuizzes?: SortOrder
    totalCorrect?: SortOrder
    totalAnswers?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentXP?: SortOrder
    currentLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalQuizzes?: SortOrder
    perfectQuizzes?: SortOrder
    totalCorrect?: SortOrder
    totalAnswers?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerProgressSumOrderByAggregateInput = {
    currentXP?: SortOrder
    currentLevel?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalQuizzes?: SortOrder
    perfectQuizzes?: SortOrder
    totalCorrect?: SortOrder
    totalAnswers?: SortOrder
  }

  export type EnumBadgeRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeRarity | EnumBadgeRarityFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeRarityFilter<$PrismaModel> | $Enums.BadgeRarity
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    rarity?: SortOrder
    condition?: SortOrder
    coinReward?: SortOrder
    conditionData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    coinReward?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    rarity?: SortOrder
    condition?: SortOrder
    coinReward?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    rarity?: SortOrder
    condition?: SortOrder
    coinReward?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    coinReward?: SortOrder
  }

  export type EnumBadgeRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeRarity | EnumBadgeRarityFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeRarityWithAggregatesFilter<$PrismaModel> | $Enums.BadgeRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBadgeRarityFilter<$PrismaModel>
    _max?: NestedEnumBadgeRarityFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BadgeScalarRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type PlayerBadgeUserIdBadgeIdCompoundUniqueInput = {
    userId: string
    badgeId: string
  }

  export type PlayerBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type PlayerBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type PlayerBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type CategoryStatUserIdCategoryNameCompoundUniqueInput = {
    userId: string
    categoryName: string
  }

  export type CategoryStatCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryName?: SortOrder
    quizzesPlayed?: SortOrder
    correctAnswers?: SortOrder
    totalAnswers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryStatAvgOrderByAggregateInput = {
    quizzesPlayed?: SortOrder
    correctAnswers?: SortOrder
    totalAnswers?: SortOrder
  }

  export type CategoryStatMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryName?: SortOrder
    quizzesPlayed?: SortOrder
    correctAnswers?: SortOrder
    totalAnswers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryStatMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryName?: SortOrder
    quizzesPlayed?: SortOrder
    correctAnswers?: SortOrder
    totalAnswers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryStatSumOrderByAggregateInput = {
    quizzesPlayed?: SortOrder
    correctAnswers?: SortOrder
    totalAnswers?: SortOrder
  }

  export type StreakProtectionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StreakProtectionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StreakProtectionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PlayerRankingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    globalScore?: SortOrder
    weeklyScore?: SortOrder
    globalRank?: SortOrder
    weeklyRank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerRankingAvgOrderByAggregateInput = {
    globalScore?: SortOrder
    weeklyScore?: SortOrder
    globalRank?: SortOrder
    weeklyRank?: SortOrder
  }

  export type PlayerRankingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    globalScore?: SortOrder
    weeklyScore?: SortOrder
    globalRank?: SortOrder
    weeklyRank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerRankingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    globalScore?: SortOrder
    weeklyScore?: SortOrder
    globalRank?: SortOrder
    weeklyRank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerRankingSumOrderByAggregateInput = {
    globalScore?: SortOrder
    weeklyScore?: SortOrder
    globalRank?: SortOrder
    weeklyRank?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    lifetimeEarned?: SortOrder
    lifetimeSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balance?: SortOrder
    lifetimeEarned?: SortOrder
    lifetimeSpent?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    lifetimeEarned?: SortOrder
    lifetimeSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    lifetimeEarned?: SortOrder
    lifetimeSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balance?: SortOrder
    lifetimeEarned?: SortOrder
    lifetimeSpent?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    description?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    balanceAfter?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    description?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    description?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    balanceAfter?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumShopItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopItemType | EnumShopItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShopItemType[] | ListEnumShopItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopItemType[] | ListEnumShopItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShopItemTypeFilter<$PrismaModel> | $Enums.ShopItemType
  }

  export type ShopItemCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ShopItemMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumShopItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopItemType | EnumShopItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShopItemType[] | ListEnumShopItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopItemType[] | ListEnumShopItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShopItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShopItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShopItemTypeFilter<$PrismaModel>
    _max?: NestedEnumShopItemTypeFilter<$PrismaModel>
  }

  export type LivesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLives?: SortOrder
    maxLives?: SortOrder
    lastRegenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LivesAvgOrderByAggregateInput = {
    currentLives?: SortOrder
    maxLives?: SortOrder
  }

  export type LivesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLives?: SortOrder
    maxLives?: SortOrder
    lastRegenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LivesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLives?: SortOrder
    maxLives?: SortOrder
    lastRegenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LivesSumOrderByAggregateInput = {
    currentLives?: SortOrder
    maxLives?: SortOrder
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type QuizSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizSessionCreateWithoutUserInput, QuizSessionUncheckedCreateWithoutUserInput> | QuizSessionCreateWithoutUserInput[] | QuizSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutUserInput | QuizSessionCreateOrConnectWithoutUserInput[]
    createMany?: QuizSessionCreateManyUserInputEnvelope
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
  }

  export type PlayerProgressCreateNestedOneWithoutUserInput = {
    create?: XOR<PlayerProgressCreateWithoutUserInput, PlayerProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerProgressCreateOrConnectWithoutUserInput
    connect?: PlayerProgressWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type LivesCreateNestedOneWithoutUserInput = {
    create?: XOR<LivesCreateWithoutUserInput, LivesUncheckedCreateWithoutUserInput>
    connectOrCreate?: LivesCreateOrConnectWithoutUserInput
    connect?: LivesWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PlayerRankingCreateNestedOneWithoutUserInput = {
    create?: XOR<PlayerRankingCreateWithoutUserInput, PlayerRankingUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerRankingCreateOrConnectWithoutUserInput
    connect?: PlayerRankingWhereUniqueInput
  }

  export type QuestionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<QuestionCreateWithoutCreatedByInput, QuestionUncheckedCreateWithoutCreatedByInput> | QuestionCreateWithoutCreatedByInput[] | QuestionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCreatedByInput | QuestionCreateOrConnectWithoutCreatedByInput[]
    createMany?: QuestionCreateManyCreatedByInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type PlayerBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerBadgeCreateWithoutUserInput, PlayerBadgeUncheckedCreateWithoutUserInput> | PlayerBadgeCreateWithoutUserInput[] | PlayerBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerBadgeCreateOrConnectWithoutUserInput | PlayerBadgeCreateOrConnectWithoutUserInput[]
    createMany?: PlayerBadgeCreateManyUserInputEnvelope
    connect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
  }

  export type StreakProtectionCreateNestedManyWithoutUserInput = {
    create?: XOR<StreakProtectionCreateWithoutUserInput, StreakProtectionUncheckedCreateWithoutUserInput> | StreakProtectionCreateWithoutUserInput[] | StreakProtectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StreakProtectionCreateOrConnectWithoutUserInput | StreakProtectionCreateOrConnectWithoutUserInput[]
    createMany?: StreakProtectionCreateManyUserInputEnvelope
    connect?: StreakProtectionWhereUniqueInput | StreakProtectionWhereUniqueInput[]
  }

  export type CategoryStatCreateNestedManyWithoutUserInput = {
    create?: XOR<CategoryStatCreateWithoutUserInput, CategoryStatUncheckedCreateWithoutUserInput> | CategoryStatCreateWithoutUserInput[] | CategoryStatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryStatCreateOrConnectWithoutUserInput | CategoryStatCreateOrConnectWithoutUserInput[]
    createMany?: CategoryStatCreateManyUserInputEnvelope
    connect?: CategoryStatWhereUniqueInput | CategoryStatWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type QuizSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizSessionCreateWithoutUserInput, QuizSessionUncheckedCreateWithoutUserInput> | QuizSessionCreateWithoutUserInput[] | QuizSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutUserInput | QuizSessionCreateOrConnectWithoutUserInput[]
    createMany?: QuizSessionCreateManyUserInputEnvelope
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
  }

  export type PlayerProgressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PlayerProgressCreateWithoutUserInput, PlayerProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerProgressCreateOrConnectWithoutUserInput
    connect?: PlayerProgressWhereUniqueInput
  }

  export type WalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type LivesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LivesCreateWithoutUserInput, LivesUncheckedCreateWithoutUserInput>
    connectOrCreate?: LivesCreateOrConnectWithoutUserInput
    connect?: LivesWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PlayerRankingUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PlayerRankingCreateWithoutUserInput, PlayerRankingUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerRankingCreateOrConnectWithoutUserInput
    connect?: PlayerRankingWhereUniqueInput
  }

  export type QuestionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<QuestionCreateWithoutCreatedByInput, QuestionUncheckedCreateWithoutCreatedByInput> | QuestionCreateWithoutCreatedByInput[] | QuestionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCreatedByInput | QuestionCreateOrConnectWithoutCreatedByInput[]
    createMany?: QuestionCreateManyCreatedByInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type PlayerBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerBadgeCreateWithoutUserInput, PlayerBadgeUncheckedCreateWithoutUserInput> | PlayerBadgeCreateWithoutUserInput[] | PlayerBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerBadgeCreateOrConnectWithoutUserInput | PlayerBadgeCreateOrConnectWithoutUserInput[]
    createMany?: PlayerBadgeCreateManyUserInputEnvelope
    connect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
  }

  export type StreakProtectionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StreakProtectionCreateWithoutUserInput, StreakProtectionUncheckedCreateWithoutUserInput> | StreakProtectionCreateWithoutUserInput[] | StreakProtectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StreakProtectionCreateOrConnectWithoutUserInput | StreakProtectionCreateOrConnectWithoutUserInput[]
    createMany?: StreakProtectionCreateManyUserInputEnvelope
    connect?: StreakProtectionWhereUniqueInput | StreakProtectionWhereUniqueInput[]
  }

  export type CategoryStatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CategoryStatCreateWithoutUserInput, CategoryStatUncheckedCreateWithoutUserInput> | CategoryStatCreateWithoutUserInput[] | CategoryStatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryStatCreateOrConnectWithoutUserInput | CategoryStatCreateOrConnectWithoutUserInput[]
    createMany?: CategoryStatCreateManyUserInputEnvelope
    connect?: CategoryStatWhereUniqueInput | CategoryStatWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type QuizSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizSessionCreateWithoutUserInput, QuizSessionUncheckedCreateWithoutUserInput> | QuizSessionCreateWithoutUserInput[] | QuizSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutUserInput | QuizSessionCreateOrConnectWithoutUserInput[]
    upsert?: QuizSessionUpsertWithWhereUniqueWithoutUserInput | QuizSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizSessionCreateManyUserInputEnvelope
    set?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    disconnect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    delete?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    update?: QuizSessionUpdateWithWhereUniqueWithoutUserInput | QuizSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizSessionUpdateManyWithWhereWithoutUserInput | QuizSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizSessionScalarWhereInput | QuizSessionScalarWhereInput[]
  }

  export type PlayerProgressUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlayerProgressCreateWithoutUserInput, PlayerProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerProgressCreateOrConnectWithoutUserInput
    upsert?: PlayerProgressUpsertWithoutUserInput
    disconnect?: PlayerProgressWhereInput | boolean
    delete?: PlayerProgressWhereInput | boolean
    connect?: PlayerProgressWhereUniqueInput
    update?: XOR<XOR<PlayerProgressUpdateToOneWithWhereWithoutUserInput, PlayerProgressUpdateWithoutUserInput>, PlayerProgressUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type LivesUpdateOneWithoutUserNestedInput = {
    create?: XOR<LivesCreateWithoutUserInput, LivesUncheckedCreateWithoutUserInput>
    connectOrCreate?: LivesCreateOrConnectWithoutUserInput
    upsert?: LivesUpsertWithoutUserInput
    disconnect?: LivesWhereInput | boolean
    delete?: LivesWhereInput | boolean
    connect?: LivesWhereUniqueInput
    update?: XOR<XOR<LivesUpdateToOneWithWhereWithoutUserInput, LivesUpdateWithoutUserInput>, LivesUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PlayerRankingUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlayerRankingCreateWithoutUserInput, PlayerRankingUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerRankingCreateOrConnectWithoutUserInput
    upsert?: PlayerRankingUpsertWithoutUserInput
    disconnect?: PlayerRankingWhereInput | boolean
    delete?: PlayerRankingWhereInput | boolean
    connect?: PlayerRankingWhereUniqueInput
    update?: XOR<XOR<PlayerRankingUpdateToOneWithWhereWithoutUserInput, PlayerRankingUpdateWithoutUserInput>, PlayerRankingUncheckedUpdateWithoutUserInput>
  }

  export type QuestionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<QuestionCreateWithoutCreatedByInput, QuestionUncheckedCreateWithoutCreatedByInput> | QuestionCreateWithoutCreatedByInput[] | QuestionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCreatedByInput | QuestionCreateOrConnectWithoutCreatedByInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutCreatedByInput | QuestionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: QuestionCreateManyCreatedByInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutCreatedByInput | QuestionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutCreatedByInput | QuestionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type PlayerBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerBadgeCreateWithoutUserInput, PlayerBadgeUncheckedCreateWithoutUserInput> | PlayerBadgeCreateWithoutUserInput[] | PlayerBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerBadgeCreateOrConnectWithoutUserInput | PlayerBadgeCreateOrConnectWithoutUserInput[]
    upsert?: PlayerBadgeUpsertWithWhereUniqueWithoutUserInput | PlayerBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerBadgeCreateManyUserInputEnvelope
    set?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    disconnect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    delete?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    connect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    update?: PlayerBadgeUpdateWithWhereUniqueWithoutUserInput | PlayerBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerBadgeUpdateManyWithWhereWithoutUserInput | PlayerBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerBadgeScalarWhereInput | PlayerBadgeScalarWhereInput[]
  }

  export type StreakProtectionUpdateManyWithoutUserNestedInput = {
    create?: XOR<StreakProtectionCreateWithoutUserInput, StreakProtectionUncheckedCreateWithoutUserInput> | StreakProtectionCreateWithoutUserInput[] | StreakProtectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StreakProtectionCreateOrConnectWithoutUserInput | StreakProtectionCreateOrConnectWithoutUserInput[]
    upsert?: StreakProtectionUpsertWithWhereUniqueWithoutUserInput | StreakProtectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StreakProtectionCreateManyUserInputEnvelope
    set?: StreakProtectionWhereUniqueInput | StreakProtectionWhereUniqueInput[]
    disconnect?: StreakProtectionWhereUniqueInput | StreakProtectionWhereUniqueInput[]
    delete?: StreakProtectionWhereUniqueInput | StreakProtectionWhereUniqueInput[]
    connect?: StreakProtectionWhereUniqueInput | StreakProtectionWhereUniqueInput[]
    update?: StreakProtectionUpdateWithWhereUniqueWithoutUserInput | StreakProtectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StreakProtectionUpdateManyWithWhereWithoutUserInput | StreakProtectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StreakProtectionScalarWhereInput | StreakProtectionScalarWhereInput[]
  }

  export type CategoryStatUpdateManyWithoutUserNestedInput = {
    create?: XOR<CategoryStatCreateWithoutUserInput, CategoryStatUncheckedCreateWithoutUserInput> | CategoryStatCreateWithoutUserInput[] | CategoryStatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryStatCreateOrConnectWithoutUserInput | CategoryStatCreateOrConnectWithoutUserInput[]
    upsert?: CategoryStatUpsertWithWhereUniqueWithoutUserInput | CategoryStatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CategoryStatCreateManyUserInputEnvelope
    set?: CategoryStatWhereUniqueInput | CategoryStatWhereUniqueInput[]
    disconnect?: CategoryStatWhereUniqueInput | CategoryStatWhereUniqueInput[]
    delete?: CategoryStatWhereUniqueInput | CategoryStatWhereUniqueInput[]
    connect?: CategoryStatWhereUniqueInput | CategoryStatWhereUniqueInput[]
    update?: CategoryStatUpdateWithWhereUniqueWithoutUserInput | CategoryStatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CategoryStatUpdateManyWithWhereWithoutUserInput | CategoryStatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CategoryStatScalarWhereInput | CategoryStatScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type QuizSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizSessionCreateWithoutUserInput, QuizSessionUncheckedCreateWithoutUserInput> | QuizSessionCreateWithoutUserInput[] | QuizSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutUserInput | QuizSessionCreateOrConnectWithoutUserInput[]
    upsert?: QuizSessionUpsertWithWhereUniqueWithoutUserInput | QuizSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizSessionCreateManyUserInputEnvelope
    set?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    disconnect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    delete?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    update?: QuizSessionUpdateWithWhereUniqueWithoutUserInput | QuizSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizSessionUpdateManyWithWhereWithoutUserInput | QuizSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizSessionScalarWhereInput | QuizSessionScalarWhereInput[]
  }

  export type PlayerProgressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlayerProgressCreateWithoutUserInput, PlayerProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerProgressCreateOrConnectWithoutUserInput
    upsert?: PlayerProgressUpsertWithoutUserInput
    disconnect?: PlayerProgressWhereInput | boolean
    delete?: PlayerProgressWhereInput | boolean
    connect?: PlayerProgressWhereUniqueInput
    update?: XOR<XOR<PlayerProgressUpdateToOneWithWhereWithoutUserInput, PlayerProgressUpdateWithoutUserInput>, PlayerProgressUncheckedUpdateWithoutUserInput>
  }

  export type WalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type LivesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LivesCreateWithoutUserInput, LivesUncheckedCreateWithoutUserInput>
    connectOrCreate?: LivesCreateOrConnectWithoutUserInput
    upsert?: LivesUpsertWithoutUserInput
    disconnect?: LivesWhereInput | boolean
    delete?: LivesWhereInput | boolean
    connect?: LivesWhereUniqueInput
    update?: XOR<XOR<LivesUpdateToOneWithWhereWithoutUserInput, LivesUpdateWithoutUserInput>, LivesUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PlayerRankingUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlayerRankingCreateWithoutUserInput, PlayerRankingUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerRankingCreateOrConnectWithoutUserInput
    upsert?: PlayerRankingUpsertWithoutUserInput
    disconnect?: PlayerRankingWhereInput | boolean
    delete?: PlayerRankingWhereInput | boolean
    connect?: PlayerRankingWhereUniqueInput
    update?: XOR<XOR<PlayerRankingUpdateToOneWithWhereWithoutUserInput, PlayerRankingUpdateWithoutUserInput>, PlayerRankingUncheckedUpdateWithoutUserInput>
  }

  export type QuestionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<QuestionCreateWithoutCreatedByInput, QuestionUncheckedCreateWithoutCreatedByInput> | QuestionCreateWithoutCreatedByInput[] | QuestionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCreatedByInput | QuestionCreateOrConnectWithoutCreatedByInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutCreatedByInput | QuestionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: QuestionCreateManyCreatedByInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutCreatedByInput | QuestionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutCreatedByInput | QuestionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerBadgeCreateWithoutUserInput, PlayerBadgeUncheckedCreateWithoutUserInput> | PlayerBadgeCreateWithoutUserInput[] | PlayerBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerBadgeCreateOrConnectWithoutUserInput | PlayerBadgeCreateOrConnectWithoutUserInput[]
    upsert?: PlayerBadgeUpsertWithWhereUniqueWithoutUserInput | PlayerBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerBadgeCreateManyUserInputEnvelope
    set?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    disconnect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    delete?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    connect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    update?: PlayerBadgeUpdateWithWhereUniqueWithoutUserInput | PlayerBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerBadgeUpdateManyWithWhereWithoutUserInput | PlayerBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerBadgeScalarWhereInput | PlayerBadgeScalarWhereInput[]
  }

  export type StreakProtectionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StreakProtectionCreateWithoutUserInput, StreakProtectionUncheckedCreateWithoutUserInput> | StreakProtectionCreateWithoutUserInput[] | StreakProtectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StreakProtectionCreateOrConnectWithoutUserInput | StreakProtectionCreateOrConnectWithoutUserInput[]
    upsert?: StreakProtectionUpsertWithWhereUniqueWithoutUserInput | StreakProtectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StreakProtectionCreateManyUserInputEnvelope
    set?: StreakProtectionWhereUniqueInput | StreakProtectionWhereUniqueInput[]
    disconnect?: StreakProtectionWhereUniqueInput | StreakProtectionWhereUniqueInput[]
    delete?: StreakProtectionWhereUniqueInput | StreakProtectionWhereUniqueInput[]
    connect?: StreakProtectionWhereUniqueInput | StreakProtectionWhereUniqueInput[]
    update?: StreakProtectionUpdateWithWhereUniqueWithoutUserInput | StreakProtectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StreakProtectionUpdateManyWithWhereWithoutUserInput | StreakProtectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StreakProtectionScalarWhereInput | StreakProtectionScalarWhereInput[]
  }

  export type CategoryStatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CategoryStatCreateWithoutUserInput, CategoryStatUncheckedCreateWithoutUserInput> | CategoryStatCreateWithoutUserInput[] | CategoryStatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryStatCreateOrConnectWithoutUserInput | CategoryStatCreateOrConnectWithoutUserInput[]
    upsert?: CategoryStatUpsertWithWhereUniqueWithoutUserInput | CategoryStatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CategoryStatCreateManyUserInputEnvelope
    set?: CategoryStatWhereUniqueInput | CategoryStatWhereUniqueInput[]
    disconnect?: CategoryStatWhereUniqueInput | CategoryStatWhereUniqueInput[]
    delete?: CategoryStatWhereUniqueInput | CategoryStatWhereUniqueInput[]
    connect?: CategoryStatWhereUniqueInput | CategoryStatWhereUniqueInput[]
    update?: CategoryStatUpdateWithWhereUniqueWithoutUserInput | CategoryStatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CategoryStatUpdateManyWithWhereWithoutUserInput | CategoryStatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CategoryStatScalarWhereInput | CategoryStatScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type QuestionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput> | QuestionCreateWithoutCategoryInput[] | QuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCategoryInput | QuestionCreateOrConnectWithoutCategoryInput[]
    createMany?: QuestionCreateManyCategoryInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput> | QuestionCreateWithoutCategoryInput[] | QuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCategoryInput | QuestionCreateOrConnectWithoutCategoryInput[]
    createMany?: QuestionCreateManyCategoryInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type QuestionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput> | QuestionCreateWithoutCategoryInput[] | QuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCategoryInput | QuestionCreateOrConnectWithoutCategoryInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutCategoryInput | QuestionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: QuestionCreateManyCategoryInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutCategoryInput | QuestionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutCategoryInput | QuestionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput> | QuestionCreateWithoutCategoryInput[] | QuestionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCategoryInput | QuestionCreateOrConnectWithoutCategoryInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutCategoryInput | QuestionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: QuestionCreateManyCategoryInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutCategoryInput | QuestionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutCategoryInput | QuestionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type QuestionCreateNestedManyWithoutDifficultyInput = {
    create?: XOR<QuestionCreateWithoutDifficultyInput, QuestionUncheckedCreateWithoutDifficultyInput> | QuestionCreateWithoutDifficultyInput[] | QuestionUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutDifficultyInput | QuestionCreateOrConnectWithoutDifficultyInput[]
    createMany?: QuestionCreateManyDifficultyInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type QuizSessionCreateNestedManyWithoutDifficultyInput = {
    create?: XOR<QuizSessionCreateWithoutDifficultyInput, QuizSessionUncheckedCreateWithoutDifficultyInput> | QuizSessionCreateWithoutDifficultyInput[] | QuizSessionUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutDifficultyInput | QuizSessionCreateOrConnectWithoutDifficultyInput[]
    createMany?: QuizSessionCreateManyDifficultyInputEnvelope
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutDifficultyInput = {
    create?: XOR<QuestionCreateWithoutDifficultyInput, QuestionUncheckedCreateWithoutDifficultyInput> | QuestionCreateWithoutDifficultyInput[] | QuestionUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutDifficultyInput | QuestionCreateOrConnectWithoutDifficultyInput[]
    createMany?: QuestionCreateManyDifficultyInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type QuizSessionUncheckedCreateNestedManyWithoutDifficultyInput = {
    create?: XOR<QuizSessionCreateWithoutDifficultyInput, QuizSessionUncheckedCreateWithoutDifficultyInput> | QuizSessionCreateWithoutDifficultyInput[] | QuizSessionUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutDifficultyInput | QuizSessionCreateOrConnectWithoutDifficultyInput[]
    createMany?: QuizSessionCreateManyDifficultyInputEnvelope
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QuestionUpdateManyWithoutDifficultyNestedInput = {
    create?: XOR<QuestionCreateWithoutDifficultyInput, QuestionUncheckedCreateWithoutDifficultyInput> | QuestionCreateWithoutDifficultyInput[] | QuestionUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutDifficultyInput | QuestionCreateOrConnectWithoutDifficultyInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutDifficultyInput | QuestionUpsertWithWhereUniqueWithoutDifficultyInput[]
    createMany?: QuestionCreateManyDifficultyInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutDifficultyInput | QuestionUpdateWithWhereUniqueWithoutDifficultyInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutDifficultyInput | QuestionUpdateManyWithWhereWithoutDifficultyInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type QuizSessionUpdateManyWithoutDifficultyNestedInput = {
    create?: XOR<QuizSessionCreateWithoutDifficultyInput, QuizSessionUncheckedCreateWithoutDifficultyInput> | QuizSessionCreateWithoutDifficultyInput[] | QuizSessionUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutDifficultyInput | QuizSessionCreateOrConnectWithoutDifficultyInput[]
    upsert?: QuizSessionUpsertWithWhereUniqueWithoutDifficultyInput | QuizSessionUpsertWithWhereUniqueWithoutDifficultyInput[]
    createMany?: QuizSessionCreateManyDifficultyInputEnvelope
    set?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    disconnect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    delete?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    update?: QuizSessionUpdateWithWhereUniqueWithoutDifficultyInput | QuizSessionUpdateWithWhereUniqueWithoutDifficultyInput[]
    updateMany?: QuizSessionUpdateManyWithWhereWithoutDifficultyInput | QuizSessionUpdateManyWithWhereWithoutDifficultyInput[]
    deleteMany?: QuizSessionScalarWhereInput | QuizSessionScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutDifficultyNestedInput = {
    create?: XOR<QuestionCreateWithoutDifficultyInput, QuestionUncheckedCreateWithoutDifficultyInput> | QuestionCreateWithoutDifficultyInput[] | QuestionUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutDifficultyInput | QuestionCreateOrConnectWithoutDifficultyInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutDifficultyInput | QuestionUpsertWithWhereUniqueWithoutDifficultyInput[]
    createMany?: QuestionCreateManyDifficultyInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutDifficultyInput | QuestionUpdateWithWhereUniqueWithoutDifficultyInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutDifficultyInput | QuestionUpdateManyWithWhereWithoutDifficultyInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type QuizSessionUncheckedUpdateManyWithoutDifficultyNestedInput = {
    create?: XOR<QuizSessionCreateWithoutDifficultyInput, QuizSessionUncheckedCreateWithoutDifficultyInput> | QuizSessionCreateWithoutDifficultyInput[] | QuizSessionUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutDifficultyInput | QuizSessionCreateOrConnectWithoutDifficultyInput[]
    upsert?: QuizSessionUpsertWithWhereUniqueWithoutDifficultyInput | QuizSessionUpsertWithWhereUniqueWithoutDifficultyInput[]
    createMany?: QuizSessionCreateManyDifficultyInputEnvelope
    set?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    disconnect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    delete?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    update?: QuizSessionUpdateWithWhereUniqueWithoutDifficultyInput | QuizSessionUpdateWithWhereUniqueWithoutDifficultyInput[]
    updateMany?: QuizSessionUpdateManyWithWhereWithoutDifficultyInput | QuizSessionUpdateManyWithWhereWithoutDifficultyInput[]
    deleteMany?: QuizSessionScalarWhereInput | QuizSessionScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<CategoryCreateWithoutQuestionsInput, CategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutQuestionsInput
    connect?: CategoryWhereUniqueInput
  }

  export type DifficultyCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<DifficultyCreateWithoutQuestionsInput, DifficultyUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: DifficultyCreateOrConnectWithoutQuestionsInput
    connect?: DifficultyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedQuestionsInput = {
    create?: XOR<UserCreateWithoutCreatedQuestionsInput, UserUncheckedCreateWithoutCreatedQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type AnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type SessionAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<SessionAnswerCreateWithoutQuestionInput, SessionAnswerUncheckedCreateWithoutQuestionInput> | SessionAnswerCreateWithoutQuestionInput[] | SessionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutQuestionInput | SessionAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: SessionAnswerCreateManyQuestionInputEnvelope
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
  }

  export type AnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type SessionAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<SessionAnswerCreateWithoutQuestionInput, SessionAnswerUncheckedCreateWithoutQuestionInput> | SessionAnswerCreateWithoutQuestionInput[] | SessionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutQuestionInput | SessionAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: SessionAnswerCreateManyQuestionInputEnvelope
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
  }

  export type EnumQuestionStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuestionStatus
  }

  export type CategoryUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<CategoryCreateWithoutQuestionsInput, CategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutQuestionsInput
    upsert?: CategoryUpsertWithoutQuestionsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutQuestionsInput, CategoryUpdateWithoutQuestionsInput>, CategoryUncheckedUpdateWithoutQuestionsInput>
  }

  export type DifficultyUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<DifficultyCreateWithoutQuestionsInput, DifficultyUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: DifficultyCreateOrConnectWithoutQuestionsInput
    upsert?: DifficultyUpsertWithoutQuestionsInput
    connect?: DifficultyWhereUniqueInput
    update?: XOR<XOR<DifficultyUpdateToOneWithWhereWithoutQuestionsInput, DifficultyUpdateWithoutQuestionsInput>, DifficultyUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedQuestionsInput, UserUncheckedCreateWithoutCreatedQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedQuestionsInput
    upsert?: UserUpsertWithoutCreatedQuestionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedQuestionsInput, UserUpdateWithoutCreatedQuestionsInput>, UserUncheckedUpdateWithoutCreatedQuestionsInput>
  }

  export type AnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutQuestionInput | AnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutQuestionInput | AnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutQuestionInput | AnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type SessionAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<SessionAnswerCreateWithoutQuestionInput, SessionAnswerUncheckedCreateWithoutQuestionInput> | SessionAnswerCreateWithoutQuestionInput[] | SessionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutQuestionInput | SessionAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: SessionAnswerUpsertWithWhereUniqueWithoutQuestionInput | SessionAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: SessionAnswerCreateManyQuestionInputEnvelope
    set?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    disconnect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    delete?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    update?: SessionAnswerUpdateWithWhereUniqueWithoutQuestionInput | SessionAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: SessionAnswerUpdateManyWithWhereWithoutQuestionInput | SessionAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: SessionAnswerScalarWhereInput | SessionAnswerScalarWhereInput[]
  }

  export type AnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutQuestionInput | AnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutQuestionInput | AnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutQuestionInput | AnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type SessionAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<SessionAnswerCreateWithoutQuestionInput, SessionAnswerUncheckedCreateWithoutQuestionInput> | SessionAnswerCreateWithoutQuestionInput[] | SessionAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutQuestionInput | SessionAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: SessionAnswerUpsertWithWhereUniqueWithoutQuestionInput | SessionAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: SessionAnswerCreateManyQuestionInputEnvelope
    set?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    disconnect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    delete?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    update?: SessionAnswerUpdateWithWhereUniqueWithoutQuestionInput | SessionAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: SessionAnswerUpdateManyWithWhereWithoutQuestionInput | SessionAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: SessionAnswerScalarWhereInput | SessionAnswerScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
  }

  export type SessionAnswerCreateNestedManyWithoutAnswerInput = {
    create?: XOR<SessionAnswerCreateWithoutAnswerInput, SessionAnswerUncheckedCreateWithoutAnswerInput> | SessionAnswerCreateWithoutAnswerInput[] | SessionAnswerUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutAnswerInput | SessionAnswerCreateOrConnectWithoutAnswerInput[]
    createMany?: SessionAnswerCreateManyAnswerInputEnvelope
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
  }

  export type SessionAnswerUncheckedCreateNestedManyWithoutAnswerInput = {
    create?: XOR<SessionAnswerCreateWithoutAnswerInput, SessionAnswerUncheckedCreateWithoutAnswerInput> | SessionAnswerCreateWithoutAnswerInput[] | SessionAnswerUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutAnswerInput | SessionAnswerCreateOrConnectWithoutAnswerInput[]
    createMany?: SessionAnswerCreateManyAnswerInputEnvelope
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type QuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuestionUpsertWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutAnswersInput, QuestionUpdateWithoutAnswersInput>, QuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type SessionAnswerUpdateManyWithoutAnswerNestedInput = {
    create?: XOR<SessionAnswerCreateWithoutAnswerInput, SessionAnswerUncheckedCreateWithoutAnswerInput> | SessionAnswerCreateWithoutAnswerInput[] | SessionAnswerUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutAnswerInput | SessionAnswerCreateOrConnectWithoutAnswerInput[]
    upsert?: SessionAnswerUpsertWithWhereUniqueWithoutAnswerInput | SessionAnswerUpsertWithWhereUniqueWithoutAnswerInput[]
    createMany?: SessionAnswerCreateManyAnswerInputEnvelope
    set?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    disconnect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    delete?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    update?: SessionAnswerUpdateWithWhereUniqueWithoutAnswerInput | SessionAnswerUpdateWithWhereUniqueWithoutAnswerInput[]
    updateMany?: SessionAnswerUpdateManyWithWhereWithoutAnswerInput | SessionAnswerUpdateManyWithWhereWithoutAnswerInput[]
    deleteMany?: SessionAnswerScalarWhereInput | SessionAnswerScalarWhereInput[]
  }

  export type SessionAnswerUncheckedUpdateManyWithoutAnswerNestedInput = {
    create?: XOR<SessionAnswerCreateWithoutAnswerInput, SessionAnswerUncheckedCreateWithoutAnswerInput> | SessionAnswerCreateWithoutAnswerInput[] | SessionAnswerUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutAnswerInput | SessionAnswerCreateOrConnectWithoutAnswerInput[]
    upsert?: SessionAnswerUpsertWithWhereUniqueWithoutAnswerInput | SessionAnswerUpsertWithWhereUniqueWithoutAnswerInput[]
    createMany?: SessionAnswerCreateManyAnswerInputEnvelope
    set?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    disconnect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    delete?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    update?: SessionAnswerUpdateWithWhereUniqueWithoutAnswerInput | SessionAnswerUpdateWithWhereUniqueWithoutAnswerInput[]
    updateMany?: SessionAnswerUpdateManyWithWhereWithoutAnswerInput | SessionAnswerUpdateManyWithWhereWithoutAnswerInput[]
    deleteMany?: SessionAnswerScalarWhereInput | SessionAnswerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutQuizSessionsInput = {
    create?: XOR<UserCreateWithoutQuizSessionsInput, UserUncheckedCreateWithoutQuizSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DifficultyCreateNestedOneWithoutQuizSessionsInput = {
    create?: XOR<DifficultyCreateWithoutQuizSessionsInput, DifficultyUncheckedCreateWithoutQuizSessionsInput>
    connectOrCreate?: DifficultyCreateOrConnectWithoutQuizSessionsInput
    connect?: DifficultyWhereUniqueInput
  }

  export type SessionAnswerCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionAnswerCreateWithoutSessionInput, SessionAnswerUncheckedCreateWithoutSessionInput> | SessionAnswerCreateWithoutSessionInput[] | SessionAnswerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutSessionInput | SessionAnswerCreateOrConnectWithoutSessionInput[]
    createMany?: SessionAnswerCreateManySessionInputEnvelope
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
  }

  export type SessionAnswerUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionAnswerCreateWithoutSessionInput, SessionAnswerUncheckedCreateWithoutSessionInput> | SessionAnswerCreateWithoutSessionInput[] | SessionAnswerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutSessionInput | SessionAnswerCreateOrConnectWithoutSessionInput[]
    createMany?: SessionAnswerCreateManySessionInputEnvelope
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutQuizSessionsNestedInput = {
    create?: XOR<UserCreateWithoutQuizSessionsInput, UserUncheckedCreateWithoutQuizSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizSessionsInput
    upsert?: UserUpsertWithoutQuizSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizSessionsInput, UserUpdateWithoutQuizSessionsInput>, UserUncheckedUpdateWithoutQuizSessionsInput>
  }

  export type DifficultyUpdateOneRequiredWithoutQuizSessionsNestedInput = {
    create?: XOR<DifficultyCreateWithoutQuizSessionsInput, DifficultyUncheckedCreateWithoutQuizSessionsInput>
    connectOrCreate?: DifficultyCreateOrConnectWithoutQuizSessionsInput
    upsert?: DifficultyUpsertWithoutQuizSessionsInput
    connect?: DifficultyWhereUniqueInput
    update?: XOR<XOR<DifficultyUpdateToOneWithWhereWithoutQuizSessionsInput, DifficultyUpdateWithoutQuizSessionsInput>, DifficultyUncheckedUpdateWithoutQuizSessionsInput>
  }

  export type SessionAnswerUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionAnswerCreateWithoutSessionInput, SessionAnswerUncheckedCreateWithoutSessionInput> | SessionAnswerCreateWithoutSessionInput[] | SessionAnswerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutSessionInput | SessionAnswerCreateOrConnectWithoutSessionInput[]
    upsert?: SessionAnswerUpsertWithWhereUniqueWithoutSessionInput | SessionAnswerUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionAnswerCreateManySessionInputEnvelope
    set?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    disconnect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    delete?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    update?: SessionAnswerUpdateWithWhereUniqueWithoutSessionInput | SessionAnswerUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionAnswerUpdateManyWithWhereWithoutSessionInput | SessionAnswerUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionAnswerScalarWhereInput | SessionAnswerScalarWhereInput[]
  }

  export type SessionAnswerUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionAnswerCreateWithoutSessionInput, SessionAnswerUncheckedCreateWithoutSessionInput> | SessionAnswerCreateWithoutSessionInput[] | SessionAnswerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionAnswerCreateOrConnectWithoutSessionInput | SessionAnswerCreateOrConnectWithoutSessionInput[]
    upsert?: SessionAnswerUpsertWithWhereUniqueWithoutSessionInput | SessionAnswerUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionAnswerCreateManySessionInputEnvelope
    set?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    disconnect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    delete?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    connect?: SessionAnswerWhereUniqueInput | SessionAnswerWhereUniqueInput[]
    update?: SessionAnswerUpdateWithWhereUniqueWithoutSessionInput | SessionAnswerUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionAnswerUpdateManyWithWhereWithoutSessionInput | SessionAnswerUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionAnswerScalarWhereInput | SessionAnswerScalarWhereInput[]
  }

  export type QuizSessionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuizSessionCreateWithoutAnswersInput, QuizSessionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizSessionCreateOrConnectWithoutAnswersInput
    connect?: QuizSessionWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutSessionAnswersInput = {
    create?: XOR<QuestionCreateWithoutSessionAnswersInput, QuestionUncheckedCreateWithoutSessionAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutSessionAnswersInput
    connect?: QuestionWhereUniqueInput
  }

  export type AnswerCreateNestedOneWithoutSessionAnswersInput = {
    create?: XOR<AnswerCreateWithoutSessionAnswersInput, AnswerUncheckedCreateWithoutSessionAnswersInput>
    connectOrCreate?: AnswerCreateOrConnectWithoutSessionAnswersInput
    connect?: AnswerWhereUniqueInput
  }

  export type QuizSessionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuizSessionCreateWithoutAnswersInput, QuizSessionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizSessionCreateOrConnectWithoutAnswersInput
    upsert?: QuizSessionUpsertWithoutAnswersInput
    connect?: QuizSessionWhereUniqueInput
    update?: XOR<XOR<QuizSessionUpdateToOneWithWhereWithoutAnswersInput, QuizSessionUpdateWithoutAnswersInput>, QuizSessionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionUpdateOneRequiredWithoutSessionAnswersNestedInput = {
    create?: XOR<QuestionCreateWithoutSessionAnswersInput, QuestionUncheckedCreateWithoutSessionAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutSessionAnswersInput
    upsert?: QuestionUpsertWithoutSessionAnswersInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutSessionAnswersInput, QuestionUpdateWithoutSessionAnswersInput>, QuestionUncheckedUpdateWithoutSessionAnswersInput>
  }

  export type AnswerUpdateOneRequiredWithoutSessionAnswersNestedInput = {
    create?: XOR<AnswerCreateWithoutSessionAnswersInput, AnswerUncheckedCreateWithoutSessionAnswersInput>
    connectOrCreate?: AnswerCreateOrConnectWithoutSessionAnswersInput
    upsert?: AnswerUpsertWithoutSessionAnswersInput
    connect?: AnswerWhereUniqueInput
    update?: XOR<XOR<AnswerUpdateToOneWithWhereWithoutSessionAnswersInput, AnswerUpdateWithoutSessionAnswersInput>, AnswerUncheckedUpdateWithoutSessionAnswersInput>
  }

  export type UserCreateNestedOneWithoutPlayerProgressInput = {
    create?: XOR<UserCreateWithoutPlayerProgressInput, UserUncheckedCreateWithoutPlayerProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerProgressInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlayerProgressNestedInput = {
    create?: XOR<UserCreateWithoutPlayerProgressInput, UserUncheckedCreateWithoutPlayerProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerProgressInput
    upsert?: UserUpsertWithoutPlayerProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayerProgressInput, UserUpdateWithoutPlayerProgressInput>, UserUncheckedUpdateWithoutPlayerProgressInput>
  }

  export type PlayerBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<PlayerBadgeCreateWithoutBadgeInput, PlayerBadgeUncheckedCreateWithoutBadgeInput> | PlayerBadgeCreateWithoutBadgeInput[] | PlayerBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: PlayerBadgeCreateOrConnectWithoutBadgeInput | PlayerBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: PlayerBadgeCreateManyBadgeInputEnvelope
    connect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
  }

  export type PlayerBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<PlayerBadgeCreateWithoutBadgeInput, PlayerBadgeUncheckedCreateWithoutBadgeInput> | PlayerBadgeCreateWithoutBadgeInput[] | PlayerBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: PlayerBadgeCreateOrConnectWithoutBadgeInput | PlayerBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: PlayerBadgeCreateManyBadgeInputEnvelope
    connect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
  }

  export type EnumBadgeRarityFieldUpdateOperationsInput = {
    set?: $Enums.BadgeRarity
  }

  export type PlayerBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<PlayerBadgeCreateWithoutBadgeInput, PlayerBadgeUncheckedCreateWithoutBadgeInput> | PlayerBadgeCreateWithoutBadgeInput[] | PlayerBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: PlayerBadgeCreateOrConnectWithoutBadgeInput | PlayerBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: PlayerBadgeUpsertWithWhereUniqueWithoutBadgeInput | PlayerBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: PlayerBadgeCreateManyBadgeInputEnvelope
    set?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    disconnect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    delete?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    connect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    update?: PlayerBadgeUpdateWithWhereUniqueWithoutBadgeInput | PlayerBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: PlayerBadgeUpdateManyWithWhereWithoutBadgeInput | PlayerBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: PlayerBadgeScalarWhereInput | PlayerBadgeScalarWhereInput[]
  }

  export type PlayerBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<PlayerBadgeCreateWithoutBadgeInput, PlayerBadgeUncheckedCreateWithoutBadgeInput> | PlayerBadgeCreateWithoutBadgeInput[] | PlayerBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: PlayerBadgeCreateOrConnectWithoutBadgeInput | PlayerBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: PlayerBadgeUpsertWithWhereUniqueWithoutBadgeInput | PlayerBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: PlayerBadgeCreateManyBadgeInputEnvelope
    set?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    disconnect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    delete?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    connect?: PlayerBadgeWhereUniqueInput | PlayerBadgeWhereUniqueInput[]
    update?: PlayerBadgeUpdateWithWhereUniqueWithoutBadgeInput | PlayerBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: PlayerBadgeUpdateManyWithWhereWithoutBadgeInput | PlayerBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: PlayerBadgeScalarWhereInput | PlayerBadgeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPlayerBadgesInput = {
    create?: XOR<UserCreateWithoutPlayerBadgesInput, UserUncheckedCreateWithoutPlayerBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutPlayerBadgesInput = {
    create?: XOR<BadgeCreateWithoutPlayerBadgesInput, BadgeUncheckedCreateWithoutPlayerBadgesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutPlayerBadgesInput
    connect?: BadgeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlayerBadgesNestedInput = {
    create?: XOR<UserCreateWithoutPlayerBadgesInput, UserUncheckedCreateWithoutPlayerBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerBadgesInput
    upsert?: UserUpsertWithoutPlayerBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayerBadgesInput, UserUpdateWithoutPlayerBadgesInput>, UserUncheckedUpdateWithoutPlayerBadgesInput>
  }

  export type BadgeUpdateOneRequiredWithoutPlayerBadgesNestedInput = {
    create?: XOR<BadgeCreateWithoutPlayerBadgesInput, BadgeUncheckedCreateWithoutPlayerBadgesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutPlayerBadgesInput
    upsert?: BadgeUpsertWithoutPlayerBadgesInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutPlayerBadgesInput, BadgeUpdateWithoutPlayerBadgesInput>, BadgeUncheckedUpdateWithoutPlayerBadgesInput>
  }

  export type UserCreateNestedOneWithoutCategoryStatsInput = {
    create?: XOR<UserCreateWithoutCategoryStatsInput, UserUncheckedCreateWithoutCategoryStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoryStatsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCategoryStatsNestedInput = {
    create?: XOR<UserCreateWithoutCategoryStatsInput, UserUncheckedCreateWithoutCategoryStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoryStatsInput
    upsert?: UserUpsertWithoutCategoryStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCategoryStatsInput, UserUpdateWithoutCategoryStatsInput>, UserUncheckedUpdateWithoutCategoryStatsInput>
  }

  export type UserCreateNestedOneWithoutStreakProtectionsInput = {
    create?: XOR<UserCreateWithoutStreakProtectionsInput, UserUncheckedCreateWithoutStreakProtectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStreakProtectionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStreakProtectionsNestedInput = {
    create?: XOR<UserCreateWithoutStreakProtectionsInput, UserUncheckedCreateWithoutStreakProtectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStreakProtectionsInput
    upsert?: UserUpsertWithoutStreakProtectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStreakProtectionsInput, UserUpdateWithoutStreakProtectionsInput>, UserUncheckedUpdateWithoutStreakProtectionsInput>
  }

  export type UserCreateNestedOneWithoutPlayerRankingInput = {
    create?: XOR<UserCreateWithoutPlayerRankingInput, UserUncheckedCreateWithoutPlayerRankingInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerRankingInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPlayerRankingNestedInput = {
    create?: XOR<UserCreateWithoutPlayerRankingInput, UserUncheckedCreateWithoutPlayerRankingInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerRankingInput
    upsert?: UserUpsertWithoutPlayerRankingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayerRankingInput, UserUpdateWithoutPlayerRankingInput>, UserUncheckedUpdateWithoutPlayerRankingInput>
  }

  export type UserCreateNestedOneWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    upsert?: UserUpsertWithoutWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletInput, UserUpdateWithoutWalletInput>, UserUncheckedUpdateWithoutWalletInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type EnumShopItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ShopItemType
  }

  export type UserCreateNestedOneWithoutLivesInput = {
    create?: XOR<UserCreateWithoutLivesInput, UserUncheckedCreateWithoutLivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLivesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLivesNestedInput = {
    create?: XOR<UserCreateWithoutLivesInput, UserUncheckedCreateWithoutLivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLivesInput
    upsert?: UserUpsertWithoutLivesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLivesInput, UserUpdateWithoutLivesInput>, UserUncheckedUpdateWithoutLivesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumQuestionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusFilter<$PrismaModel> | $Enums.QuestionStatus
  }

  export type NestedEnumQuestionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestionStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBadgeRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeRarity | EnumBadgeRarityFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeRarityFilter<$PrismaModel> | $Enums.BadgeRarity
  }

  export type NestedEnumBadgeRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeRarity | EnumBadgeRarityFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeRarityWithAggregatesFilter<$PrismaModel> | $Enums.BadgeRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBadgeRarityFilter<$PrismaModel>
    _max?: NestedEnumBadgeRarityFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumShopItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopItemType | EnumShopItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShopItemType[] | ListEnumShopItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopItemType[] | ListEnumShopItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShopItemTypeFilter<$PrismaModel> | $Enums.ShopItemType
  }

  export type NestedEnumShopItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopItemType | EnumShopItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShopItemType[] | ListEnumShopItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopItemType[] | ListEnumShopItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShopItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShopItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShopItemTypeFilter<$PrismaModel>
    _max?: NestedEnumShopItemTypeFilter<$PrismaModel>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuizSessionCreateWithoutUserInput = {
    id?: string
    categoryId?: string | null
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    difficulty: DifficultyCreateNestedOneWithoutQuizSessionsInput
    answers?: SessionAnswerCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionUncheckedCreateWithoutUserInput = {
    id?: string
    categoryId?: string | null
    difficultyId: string
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: SessionAnswerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionCreateOrConnectWithoutUserInput = {
    where: QuizSessionWhereUniqueInput
    create: XOR<QuizSessionCreateWithoutUserInput, QuizSessionUncheckedCreateWithoutUserInput>
  }

  export type QuizSessionCreateManyUserInputEnvelope = {
    data: QuizSessionCreateManyUserInput | QuizSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlayerProgressCreateWithoutUserInput = {
    id?: string
    currentXP?: number
    currentLevel?: number
    currentStreak?: number
    longestStreak?: number
    totalQuizzes?: number
    perfectQuizzes?: number
    totalCorrect?: number
    totalAnswers?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerProgressUncheckedCreateWithoutUserInput = {
    id?: string
    currentXP?: number
    currentLevel?: number
    currentStreak?: number
    longestStreak?: number
    totalQuizzes?: number
    perfectQuizzes?: number
    totalCorrect?: number
    totalAnswers?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerProgressCreateOrConnectWithoutUserInput = {
    where: PlayerProgressWhereUniqueInput
    create: XOR<PlayerProgressCreateWithoutUserInput, PlayerProgressUncheckedCreateWithoutUserInput>
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    balance?: number
    lifetimeEarned?: number
    lifetimeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    balance?: number
    lifetimeEarned?: number
    lifetimeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type LivesCreateWithoutUserInput = {
    id?: string
    currentLives?: number
    maxLives?: number
    lastRegenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LivesUncheckedCreateWithoutUserInput = {
    id?: string
    currentLives?: number
    maxLives?: number
    lastRegenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LivesCreateOrConnectWithoutUserInput = {
    where: LivesWhereUniqueInput
    create: XOR<LivesCreateWithoutUserInput, LivesUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    source: string
    description?: string | null
    balanceAfter: number
    createdAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    source: string
    description?: string | null
    balanceAfter: number
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlayerRankingCreateWithoutUserInput = {
    id?: string
    globalScore?: number
    weeklyScore?: number
    globalRank?: number | null
    weeklyRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerRankingUncheckedCreateWithoutUserInput = {
    id?: string
    globalScore?: number
    weeklyScore?: number
    globalRank?: number | null
    weeklyRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerRankingCreateOrConnectWithoutUserInput = {
    where: PlayerRankingWhereUniqueInput
    create: XOR<PlayerRankingCreateWithoutUserInput, PlayerRankingUncheckedCreateWithoutUserInput>
  }

  export type QuestionCreateWithoutCreatedByInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    status?: $Enums.QuestionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutQuestionsInput
    difficulty: DifficultyCreateNestedOneWithoutQuestionsInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    sessionAnswers?: SessionAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutCreatedByInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    categoryId: string
    difficultyId: string
    status?: $Enums.QuestionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    sessionAnswers?: SessionAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutCreatedByInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutCreatedByInput, QuestionUncheckedCreateWithoutCreatedByInput>
  }

  export type QuestionCreateManyCreatedByInputEnvelope = {
    data: QuestionCreateManyCreatedByInput | QuestionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PlayerBadgeCreateWithoutUserInput = {
    id?: string
    unlockedAt?: Date | string
    badge: BadgeCreateNestedOneWithoutPlayerBadgesInput
  }

  export type PlayerBadgeUncheckedCreateWithoutUserInput = {
    id?: string
    badgeId: string
    unlockedAt?: Date | string
  }

  export type PlayerBadgeCreateOrConnectWithoutUserInput = {
    where: PlayerBadgeWhereUniqueInput
    create: XOR<PlayerBadgeCreateWithoutUserInput, PlayerBadgeUncheckedCreateWithoutUserInput>
  }

  export type PlayerBadgeCreateManyUserInputEnvelope = {
    data: PlayerBadgeCreateManyUserInput | PlayerBadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StreakProtectionCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type StreakProtectionUncheckedCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type StreakProtectionCreateOrConnectWithoutUserInput = {
    where: StreakProtectionWhereUniqueInput
    create: XOR<StreakProtectionCreateWithoutUserInput, StreakProtectionUncheckedCreateWithoutUserInput>
  }

  export type StreakProtectionCreateManyUserInputEnvelope = {
    data: StreakProtectionCreateManyUserInput | StreakProtectionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CategoryStatCreateWithoutUserInput = {
    id?: string
    categoryName: string
    quizzesPlayed?: number
    correctAnswers?: number
    totalAnswers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryStatUncheckedCreateWithoutUserInput = {
    id?: string
    categoryName: string
    quizzesPlayed?: number
    correctAnswers?: number
    totalAnswers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryStatCreateOrConnectWithoutUserInput = {
    where: CategoryStatWhereUniqueInput
    create: XOR<CategoryStatCreateWithoutUserInput, CategoryStatUncheckedCreateWithoutUserInput>
  }

  export type CategoryStatCreateManyUserInputEnvelope = {
    data: CategoryStatCreateManyUserInput | CategoryStatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type QuizSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: QuizSessionWhereUniqueInput
    update: XOR<QuizSessionUpdateWithoutUserInput, QuizSessionUncheckedUpdateWithoutUserInput>
    create: XOR<QuizSessionCreateWithoutUserInput, QuizSessionUncheckedCreateWithoutUserInput>
  }

  export type QuizSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: QuizSessionWhereUniqueInput
    data: XOR<QuizSessionUpdateWithoutUserInput, QuizSessionUncheckedUpdateWithoutUserInput>
  }

  export type QuizSessionUpdateManyWithWhereWithoutUserInput = {
    where: QuizSessionScalarWhereInput
    data: XOR<QuizSessionUpdateManyMutationInput, QuizSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type QuizSessionScalarWhereInput = {
    AND?: QuizSessionScalarWhereInput | QuizSessionScalarWhereInput[]
    OR?: QuizSessionScalarWhereInput[]
    NOT?: QuizSessionScalarWhereInput | QuizSessionScalarWhereInput[]
    id?: StringFilter<"QuizSession"> | string
    userId?: StringFilter<"QuizSession"> | string
    categoryId?: StringNullableFilter<"QuizSession"> | string | null
    difficultyId?: StringFilter<"QuizSession"> | string
    status?: EnumSessionStatusFilter<"QuizSession"> | $Enums.SessionStatus
    score?: IntFilter<"QuizSession"> | number
    startedAt?: DateTimeFilter<"QuizSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"QuizSession"> | Date | string | null
    expiresAt?: DateTimeFilter<"QuizSession"> | Date | string
    createdAt?: DateTimeFilter<"QuizSession"> | Date | string
    updatedAt?: DateTimeFilter<"QuizSession"> | Date | string
  }

  export type PlayerProgressUpsertWithoutUserInput = {
    update: XOR<PlayerProgressUpdateWithoutUserInput, PlayerProgressUncheckedUpdateWithoutUserInput>
    create: XOR<PlayerProgressCreateWithoutUserInput, PlayerProgressUncheckedCreateWithoutUserInput>
    where?: PlayerProgressWhereInput
  }

  export type PlayerProgressUpdateToOneWithWhereWithoutUserInput = {
    where?: PlayerProgressWhereInput
    data: XOR<PlayerProgressUpdateWithoutUserInput, PlayerProgressUncheckedUpdateWithoutUserInput>
  }

  export type PlayerProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalQuizzes?: IntFieldUpdateOperationsInput | number
    perfectQuizzes?: IntFieldUpdateOperationsInput | number
    totalCorrect?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    totalQuizzes?: IntFieldUpdateOperationsInput | number
    perfectQuizzes?: IntFieldUpdateOperationsInput | number
    totalCorrect?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUpsertWithoutUserInput = {
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutUserInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    lifetimeEarned?: IntFieldUpdateOperationsInput | number
    lifetimeSpent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    lifetimeEarned?: IntFieldUpdateOperationsInput | number
    lifetimeSpent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivesUpsertWithoutUserInput = {
    update: XOR<LivesUpdateWithoutUserInput, LivesUncheckedUpdateWithoutUserInput>
    create: XOR<LivesCreateWithoutUserInput, LivesUncheckedCreateWithoutUserInput>
    where?: LivesWhereInput
  }

  export type LivesUpdateToOneWithWhereWithoutUserInput = {
    where?: LivesWhereInput
    data: XOR<LivesUpdateWithoutUserInput, LivesUncheckedUpdateWithoutUserInput>
  }

  export type LivesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLives?: IntFieldUpdateOperationsInput | number
    maxLives?: IntFieldUpdateOperationsInput | number
    lastRegenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LivesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLives?: IntFieldUpdateOperationsInput | number
    maxLives?: IntFieldUpdateOperationsInput | number
    lastRegenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntFilter<"Transaction"> | number
    source?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    balanceAfter?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type PlayerRankingUpsertWithoutUserInput = {
    update: XOR<PlayerRankingUpdateWithoutUserInput, PlayerRankingUncheckedUpdateWithoutUserInput>
    create: XOR<PlayerRankingCreateWithoutUserInput, PlayerRankingUncheckedCreateWithoutUserInput>
    where?: PlayerRankingWhereInput
  }

  export type PlayerRankingUpdateToOneWithWhereWithoutUserInput = {
    where?: PlayerRankingWhereInput
    data: XOR<PlayerRankingUpdateWithoutUserInput, PlayerRankingUncheckedUpdateWithoutUserInput>
  }

  export type PlayerRankingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    globalScore?: IntFieldUpdateOperationsInput | number
    weeklyScore?: IntFieldUpdateOperationsInput | number
    globalRank?: NullableIntFieldUpdateOperationsInput | number | null
    weeklyRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerRankingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    globalScore?: IntFieldUpdateOperationsInput | number
    weeklyScore?: IntFieldUpdateOperationsInput | number
    globalRank?: NullableIntFieldUpdateOperationsInput | number | null
    weeklyRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutCreatedByInput, QuestionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<QuestionCreateWithoutCreatedByInput, QuestionUncheckedCreateWithoutCreatedByInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutCreatedByInput, QuestionUncheckedUpdateWithoutCreatedByInput>
  }

  export type QuestionUpdateManyWithWhereWithoutCreatedByInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    explanation?: StringFilter<"Question"> | string
    imageUrl?: StringNullableFilter<"Question"> | string | null
    categoryId?: StringFilter<"Question"> | string
    difficultyId?: StringFilter<"Question"> | string
    status?: EnumQuestionStatusFilter<"Question"> | $Enums.QuestionStatus
    createdById?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
  }

  export type PlayerBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: PlayerBadgeWhereUniqueInput
    update: XOR<PlayerBadgeUpdateWithoutUserInput, PlayerBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<PlayerBadgeCreateWithoutUserInput, PlayerBadgeUncheckedCreateWithoutUserInput>
  }

  export type PlayerBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: PlayerBadgeWhereUniqueInput
    data: XOR<PlayerBadgeUpdateWithoutUserInput, PlayerBadgeUncheckedUpdateWithoutUserInput>
  }

  export type PlayerBadgeUpdateManyWithWhereWithoutUserInput = {
    where: PlayerBadgeScalarWhereInput
    data: XOR<PlayerBadgeUpdateManyMutationInput, PlayerBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type PlayerBadgeScalarWhereInput = {
    AND?: PlayerBadgeScalarWhereInput | PlayerBadgeScalarWhereInput[]
    OR?: PlayerBadgeScalarWhereInput[]
    NOT?: PlayerBadgeScalarWhereInput | PlayerBadgeScalarWhereInput[]
    id?: StringFilter<"PlayerBadge"> | string
    userId?: StringFilter<"PlayerBadge"> | string
    badgeId?: StringFilter<"PlayerBadge"> | string
    unlockedAt?: DateTimeFilter<"PlayerBadge"> | Date | string
  }

  export type StreakProtectionUpsertWithWhereUniqueWithoutUserInput = {
    where: StreakProtectionWhereUniqueInput
    update: XOR<StreakProtectionUpdateWithoutUserInput, StreakProtectionUncheckedUpdateWithoutUserInput>
    create: XOR<StreakProtectionCreateWithoutUserInput, StreakProtectionUncheckedCreateWithoutUserInput>
  }

  export type StreakProtectionUpdateWithWhereUniqueWithoutUserInput = {
    where: StreakProtectionWhereUniqueInput
    data: XOR<StreakProtectionUpdateWithoutUserInput, StreakProtectionUncheckedUpdateWithoutUserInput>
  }

  export type StreakProtectionUpdateManyWithWhereWithoutUserInput = {
    where: StreakProtectionScalarWhereInput
    data: XOR<StreakProtectionUpdateManyMutationInput, StreakProtectionUncheckedUpdateManyWithoutUserInput>
  }

  export type StreakProtectionScalarWhereInput = {
    AND?: StreakProtectionScalarWhereInput | StreakProtectionScalarWhereInput[]
    OR?: StreakProtectionScalarWhereInput[]
    NOT?: StreakProtectionScalarWhereInput | StreakProtectionScalarWhereInput[]
    id?: StringFilter<"StreakProtection"> | string
    userId?: StringFilter<"StreakProtection"> | string
    expiresAt?: DateTimeFilter<"StreakProtection"> | Date | string
    createdAt?: DateTimeFilter<"StreakProtection"> | Date | string
  }

  export type CategoryStatUpsertWithWhereUniqueWithoutUserInput = {
    where: CategoryStatWhereUniqueInput
    update: XOR<CategoryStatUpdateWithoutUserInput, CategoryStatUncheckedUpdateWithoutUserInput>
    create: XOR<CategoryStatCreateWithoutUserInput, CategoryStatUncheckedCreateWithoutUserInput>
  }

  export type CategoryStatUpdateWithWhereUniqueWithoutUserInput = {
    where: CategoryStatWhereUniqueInput
    data: XOR<CategoryStatUpdateWithoutUserInput, CategoryStatUncheckedUpdateWithoutUserInput>
  }

  export type CategoryStatUpdateManyWithWhereWithoutUserInput = {
    where: CategoryStatScalarWhereInput
    data: XOR<CategoryStatUpdateManyMutationInput, CategoryStatUncheckedUpdateManyWithoutUserInput>
  }

  export type CategoryStatScalarWhereInput = {
    AND?: CategoryStatScalarWhereInput | CategoryStatScalarWhereInput[]
    OR?: CategoryStatScalarWhereInput[]
    NOT?: CategoryStatScalarWhereInput | CategoryStatScalarWhereInput[]
    id?: StringFilter<"CategoryStat"> | string
    userId?: StringFilter<"CategoryStat"> | string
    categoryName?: StringFilter<"CategoryStat"> | string
    quizzesPlayed?: IntFilter<"CategoryStat"> | number
    correctAnswers?: IntFilter<"CategoryStat"> | number
    totalAnswers?: IntFilter<"CategoryStat"> | number
    createdAt?: DateTimeFilter<"CategoryStat"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryStat"> | Date | string
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuestionCreateWithoutCategoryInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    status?: $Enums.QuestionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    difficulty: DifficultyCreateNestedOneWithoutQuestionsInput
    createdBy: UserCreateNestedOneWithoutCreatedQuestionsInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    sessionAnswers?: SessionAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutCategoryInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    difficultyId: string
    status?: $Enums.QuestionStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    sessionAnswers?: SessionAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutCategoryInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput>
  }

  export type QuestionCreateManyCategoryInputEnvelope = {
    data: QuestionCreateManyCategoryInput | QuestionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type QuestionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutCategoryInput, QuestionUncheckedUpdateWithoutCategoryInput>
    create: XOR<QuestionCreateWithoutCategoryInput, QuestionUncheckedCreateWithoutCategoryInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutCategoryInput, QuestionUncheckedUpdateWithoutCategoryInput>
  }

  export type QuestionUpdateManyWithWhereWithoutCategoryInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type QuestionCreateWithoutDifficultyInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    status?: $Enums.QuestionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutQuestionsInput
    createdBy: UserCreateNestedOneWithoutCreatedQuestionsInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    sessionAnswers?: SessionAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutDifficultyInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    categoryId: string
    status?: $Enums.QuestionStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    sessionAnswers?: SessionAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutDifficultyInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutDifficultyInput, QuestionUncheckedCreateWithoutDifficultyInput>
  }

  export type QuestionCreateManyDifficultyInputEnvelope = {
    data: QuestionCreateManyDifficultyInput | QuestionCreateManyDifficultyInput[]
    skipDuplicates?: boolean
  }

  export type QuizSessionCreateWithoutDifficultyInput = {
    id?: string
    categoryId?: string | null
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutQuizSessionsInput
    answers?: SessionAnswerCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionUncheckedCreateWithoutDifficultyInput = {
    id?: string
    userId: string
    categoryId?: string | null
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: SessionAnswerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionCreateOrConnectWithoutDifficultyInput = {
    where: QuizSessionWhereUniqueInput
    create: XOR<QuizSessionCreateWithoutDifficultyInput, QuizSessionUncheckedCreateWithoutDifficultyInput>
  }

  export type QuizSessionCreateManyDifficultyInputEnvelope = {
    data: QuizSessionCreateManyDifficultyInput | QuizSessionCreateManyDifficultyInput[]
    skipDuplicates?: boolean
  }

  export type QuestionUpsertWithWhereUniqueWithoutDifficultyInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutDifficultyInput, QuestionUncheckedUpdateWithoutDifficultyInput>
    create: XOR<QuestionCreateWithoutDifficultyInput, QuestionUncheckedCreateWithoutDifficultyInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutDifficultyInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutDifficultyInput, QuestionUncheckedUpdateWithoutDifficultyInput>
  }

  export type QuestionUpdateManyWithWhereWithoutDifficultyInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutDifficultyInput>
  }

  export type QuizSessionUpsertWithWhereUniqueWithoutDifficultyInput = {
    where: QuizSessionWhereUniqueInput
    update: XOR<QuizSessionUpdateWithoutDifficultyInput, QuizSessionUncheckedUpdateWithoutDifficultyInput>
    create: XOR<QuizSessionCreateWithoutDifficultyInput, QuizSessionUncheckedCreateWithoutDifficultyInput>
  }

  export type QuizSessionUpdateWithWhereUniqueWithoutDifficultyInput = {
    where: QuizSessionWhereUniqueInput
    data: XOR<QuizSessionUpdateWithoutDifficultyInput, QuizSessionUncheckedUpdateWithoutDifficultyInput>
  }

  export type QuizSessionUpdateManyWithWhereWithoutDifficultyInput = {
    where: QuizSessionScalarWhereInput
    data: XOR<QuizSessionUpdateManyMutationInput, QuizSessionUncheckedUpdateManyWithoutDifficultyInput>
  }

  export type CategoryCreateWithoutQuestionsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutQuestionsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutQuestionsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutQuestionsInput, CategoryUncheckedCreateWithoutQuestionsInput>
  }

  export type DifficultyCreateWithoutQuestionsInput = {
    id?: string
    level: string
    name: string
    timePerQuestion: number
    xpMultiplier: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quizSessions?: QuizSessionCreateNestedManyWithoutDifficultyInput
  }

  export type DifficultyUncheckedCreateWithoutQuestionsInput = {
    id?: string
    level: string
    name: string
    timePerQuestion: number
    xpMultiplier: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutDifficultyInput
  }

  export type DifficultyCreateOrConnectWithoutQuestionsInput = {
    where: DifficultyWhereUniqueInput
    create: XOR<DifficultyCreateWithoutQuestionsInput, DifficultyUncheckedCreateWithoutQuestionsInput>
  }

  export type UserCreateWithoutCreatedQuestionsInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedQuestionsInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedQuestionsInput, UserUncheckedCreateWithoutCreatedQuestionsInput>
  }

  export type AnswerCreateWithoutQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionAnswers?: SessionAnswerCreateNestedManyWithoutAnswerInput
  }

  export type AnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionAnswers?: SessionAnswerUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type AnswerCreateOrConnectWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerCreateManyQuestionInputEnvelope = {
    data: AnswerCreateManyQuestionInput | AnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type SessionAnswerCreateWithoutQuestionInput = {
    id?: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
    session: QuizSessionCreateNestedOneWithoutAnswersInput
    answer: AnswerCreateNestedOneWithoutSessionAnswersInput
  }

  export type SessionAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    sessionId: string
    answerId: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
  }

  export type SessionAnswerCreateOrConnectWithoutQuestionInput = {
    where: SessionAnswerWhereUniqueInput
    create: XOR<SessionAnswerCreateWithoutQuestionInput, SessionAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type SessionAnswerCreateManyQuestionInputEnvelope = {
    data: SessionAnswerCreateManyQuestionInput | SessionAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutQuestionsInput = {
    update: XOR<CategoryUpdateWithoutQuestionsInput, CategoryUncheckedUpdateWithoutQuestionsInput>
    create: XOR<CategoryCreateWithoutQuestionsInput, CategoryUncheckedCreateWithoutQuestionsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutQuestionsInput, CategoryUncheckedUpdateWithoutQuestionsInput>
  }

  export type CategoryUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DifficultyUpsertWithoutQuestionsInput = {
    update: XOR<DifficultyUpdateWithoutQuestionsInput, DifficultyUncheckedUpdateWithoutQuestionsInput>
    create: XOR<DifficultyCreateWithoutQuestionsInput, DifficultyUncheckedCreateWithoutQuestionsInput>
    where?: DifficultyWhereInput
  }

  export type DifficultyUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: DifficultyWhereInput
    data: XOR<DifficultyUpdateWithoutQuestionsInput, DifficultyUncheckedUpdateWithoutQuestionsInput>
  }

  export type DifficultyUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timePerQuestion?: IntFieldUpdateOperationsInput | number
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizSessions?: QuizSessionUpdateManyWithoutDifficultyNestedInput
  }

  export type DifficultyUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timePerQuestion?: IntFieldUpdateOperationsInput | number
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutDifficultyNestedInput
  }

  export type UserUpsertWithoutCreatedQuestionsInput = {
    update: XOR<UserUpdateWithoutCreatedQuestionsInput, UserUncheckedUpdateWithoutCreatedQuestionsInput>
    create: XOR<UserCreateWithoutCreatedQuestionsInput, UserUncheckedCreateWithoutCreatedQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedQuestionsInput, UserUncheckedUpdateWithoutCreatedQuestionsInput>
  }

  export type UserUpdateWithoutCreatedQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type AnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type AnswerScalarWhereInput = {
    AND?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
    OR?: AnswerScalarWhereInput[]
    NOT?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
    id?: StringFilter<"Answer"> | string
    questionId?: StringFilter<"Answer"> | string
    text?: StringFilter<"Answer"> | string
    isCorrect?: BoolFilter<"Answer"> | boolean
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    updatedAt?: DateTimeFilter<"Answer"> | Date | string
  }

  export type SessionAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: SessionAnswerWhereUniqueInput
    update: XOR<SessionAnswerUpdateWithoutQuestionInput, SessionAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<SessionAnswerCreateWithoutQuestionInput, SessionAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type SessionAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: SessionAnswerWhereUniqueInput
    data: XOR<SessionAnswerUpdateWithoutQuestionInput, SessionAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type SessionAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: SessionAnswerScalarWhereInput
    data: XOR<SessionAnswerUpdateManyMutationInput, SessionAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type SessionAnswerScalarWhereInput = {
    AND?: SessionAnswerScalarWhereInput | SessionAnswerScalarWhereInput[]
    OR?: SessionAnswerScalarWhereInput[]
    NOT?: SessionAnswerScalarWhereInput | SessionAnswerScalarWhereInput[]
    id?: StringFilter<"SessionAnswer"> | string
    sessionId?: StringFilter<"SessionAnswer"> | string
    questionId?: StringFilter<"SessionAnswer"> | string
    answerId?: StringFilter<"SessionAnswer"> | string
    isCorrect?: BoolFilter<"SessionAnswer"> | boolean
    timeSpent?: IntFilter<"SessionAnswer"> | number
    pointsEarned?: IntFilter<"SessionAnswer"> | number
    timeBonus?: IntFilter<"SessionAnswer"> | number
    answeredAt?: DateTimeFilter<"SessionAnswer"> | Date | string
  }

  export type QuestionCreateWithoutAnswersInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    status?: $Enums.QuestionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutQuestionsInput
    difficulty: DifficultyCreateNestedOneWithoutQuestionsInput
    createdBy: UserCreateNestedOneWithoutCreatedQuestionsInput
    sessionAnswers?: SessionAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    categoryId: string
    difficultyId: string
    status?: $Enums.QuestionStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionAnswers?: SessionAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutAnswersInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
  }

  export type SessionAnswerCreateWithoutAnswerInput = {
    id?: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
    session: QuizSessionCreateNestedOneWithoutAnswersInput
    question: QuestionCreateNestedOneWithoutSessionAnswersInput
  }

  export type SessionAnswerUncheckedCreateWithoutAnswerInput = {
    id?: string
    sessionId: string
    questionId: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
  }

  export type SessionAnswerCreateOrConnectWithoutAnswerInput = {
    where: SessionAnswerWhereUniqueInput
    create: XOR<SessionAnswerCreateWithoutAnswerInput, SessionAnswerUncheckedCreateWithoutAnswerInput>
  }

  export type SessionAnswerCreateManyAnswerInputEnvelope = {
    data: SessionAnswerCreateManyAnswerInput | SessionAnswerCreateManyAnswerInput[]
    skipDuplicates?: boolean
  }

  export type QuestionUpsertWithoutAnswersInput = {
    update: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutQuestionsNestedInput
    difficulty?: DifficultyUpdateOneRequiredWithoutQuestionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    sessionAnswers?: SessionAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionAnswers?: SessionAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type SessionAnswerUpsertWithWhereUniqueWithoutAnswerInput = {
    where: SessionAnswerWhereUniqueInput
    update: XOR<SessionAnswerUpdateWithoutAnswerInput, SessionAnswerUncheckedUpdateWithoutAnswerInput>
    create: XOR<SessionAnswerCreateWithoutAnswerInput, SessionAnswerUncheckedCreateWithoutAnswerInput>
  }

  export type SessionAnswerUpdateWithWhereUniqueWithoutAnswerInput = {
    where: SessionAnswerWhereUniqueInput
    data: XOR<SessionAnswerUpdateWithoutAnswerInput, SessionAnswerUncheckedUpdateWithoutAnswerInput>
  }

  export type SessionAnswerUpdateManyWithWhereWithoutAnswerInput = {
    where: SessionAnswerScalarWhereInput
    data: XOR<SessionAnswerUpdateManyMutationInput, SessionAnswerUncheckedUpdateManyWithoutAnswerInput>
  }

  export type UserCreateWithoutQuizSessionsInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuizSessionsInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuizSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizSessionsInput, UserUncheckedCreateWithoutQuizSessionsInput>
  }

  export type DifficultyCreateWithoutQuizSessionsInput = {
    id?: string
    level: string
    name: string
    timePerQuestion: number
    xpMultiplier: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionCreateNestedManyWithoutDifficultyInput
  }

  export type DifficultyUncheckedCreateWithoutQuizSessionsInput = {
    id?: string
    level: string
    name: string
    timePerQuestion: number
    xpMultiplier: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutDifficultyInput
  }

  export type DifficultyCreateOrConnectWithoutQuizSessionsInput = {
    where: DifficultyWhereUniqueInput
    create: XOR<DifficultyCreateWithoutQuizSessionsInput, DifficultyUncheckedCreateWithoutQuizSessionsInput>
  }

  export type SessionAnswerCreateWithoutSessionInput = {
    id?: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
    question: QuestionCreateNestedOneWithoutSessionAnswersInput
    answer: AnswerCreateNestedOneWithoutSessionAnswersInput
  }

  export type SessionAnswerUncheckedCreateWithoutSessionInput = {
    id?: string
    questionId: string
    answerId: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
  }

  export type SessionAnswerCreateOrConnectWithoutSessionInput = {
    where: SessionAnswerWhereUniqueInput
    create: XOR<SessionAnswerCreateWithoutSessionInput, SessionAnswerUncheckedCreateWithoutSessionInput>
  }

  export type SessionAnswerCreateManySessionInputEnvelope = {
    data: SessionAnswerCreateManySessionInput | SessionAnswerCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuizSessionsInput = {
    update: XOR<UserUpdateWithoutQuizSessionsInput, UserUncheckedUpdateWithoutQuizSessionsInput>
    create: XOR<UserCreateWithoutQuizSessionsInput, UserUncheckedCreateWithoutQuizSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizSessionsInput, UserUncheckedUpdateWithoutQuizSessionsInput>
  }

  export type UserUpdateWithoutQuizSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DifficultyUpsertWithoutQuizSessionsInput = {
    update: XOR<DifficultyUpdateWithoutQuizSessionsInput, DifficultyUncheckedUpdateWithoutQuizSessionsInput>
    create: XOR<DifficultyCreateWithoutQuizSessionsInput, DifficultyUncheckedCreateWithoutQuizSessionsInput>
    where?: DifficultyWhereInput
  }

  export type DifficultyUpdateToOneWithWhereWithoutQuizSessionsInput = {
    where?: DifficultyWhereInput
    data: XOR<DifficultyUpdateWithoutQuizSessionsInput, DifficultyUncheckedUpdateWithoutQuizSessionsInput>
  }

  export type DifficultyUpdateWithoutQuizSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timePerQuestion?: IntFieldUpdateOperationsInput | number
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutDifficultyNestedInput
  }

  export type DifficultyUncheckedUpdateWithoutQuizSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    timePerQuestion?: IntFieldUpdateOperationsInput | number
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutDifficultyNestedInput
  }

  export type SessionAnswerUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionAnswerWhereUniqueInput
    update: XOR<SessionAnswerUpdateWithoutSessionInput, SessionAnswerUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionAnswerCreateWithoutSessionInput, SessionAnswerUncheckedCreateWithoutSessionInput>
  }

  export type SessionAnswerUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionAnswerWhereUniqueInput
    data: XOR<SessionAnswerUpdateWithoutSessionInput, SessionAnswerUncheckedUpdateWithoutSessionInput>
  }

  export type SessionAnswerUpdateManyWithWhereWithoutSessionInput = {
    where: SessionAnswerScalarWhereInput
    data: XOR<SessionAnswerUpdateManyMutationInput, SessionAnswerUncheckedUpdateManyWithoutSessionInput>
  }

  export type QuizSessionCreateWithoutAnswersInput = {
    id?: string
    categoryId?: string | null
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutQuizSessionsInput
    difficulty: DifficultyCreateNestedOneWithoutQuizSessionsInput
  }

  export type QuizSessionUncheckedCreateWithoutAnswersInput = {
    id?: string
    userId: string
    categoryId?: string | null
    difficultyId: string
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizSessionCreateOrConnectWithoutAnswersInput = {
    where: QuizSessionWhereUniqueInput
    create: XOR<QuizSessionCreateWithoutAnswersInput, QuizSessionUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionCreateWithoutSessionAnswersInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    status?: $Enums.QuestionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutQuestionsInput
    difficulty: DifficultyCreateNestedOneWithoutQuestionsInput
    createdBy: UserCreateNestedOneWithoutCreatedQuestionsInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutSessionAnswersInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    categoryId: string
    difficultyId: string
    status?: $Enums.QuestionStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutSessionAnswersInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutSessionAnswersInput, QuestionUncheckedCreateWithoutSessionAnswersInput>
  }

  export type AnswerCreateWithoutSessionAnswersInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutSessionAnswersInput = {
    id?: string
    questionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnswerCreateOrConnectWithoutSessionAnswersInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutSessionAnswersInput, AnswerUncheckedCreateWithoutSessionAnswersInput>
  }

  export type QuizSessionUpsertWithoutAnswersInput = {
    update: XOR<QuizSessionUpdateWithoutAnswersInput, QuizSessionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuizSessionCreateWithoutAnswersInput, QuizSessionUncheckedCreateWithoutAnswersInput>
    where?: QuizSessionWhereInput
  }

  export type QuizSessionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuizSessionWhereInput
    data: XOR<QuizSessionUpdateWithoutAnswersInput, QuizSessionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizSessionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutQuizSessionsNestedInput
    difficulty?: DifficultyUpdateOneRequiredWithoutQuizSessionsNestedInput
  }

  export type QuizSessionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUpsertWithoutSessionAnswersInput = {
    update: XOR<QuestionUpdateWithoutSessionAnswersInput, QuestionUncheckedUpdateWithoutSessionAnswersInput>
    create: XOR<QuestionCreateWithoutSessionAnswersInput, QuestionUncheckedCreateWithoutSessionAnswersInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutSessionAnswersInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutSessionAnswersInput, QuestionUncheckedUpdateWithoutSessionAnswersInput>
  }

  export type QuestionUpdateWithoutSessionAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutQuestionsNestedInput
    difficulty?: DifficultyUpdateOneRequiredWithoutQuestionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutSessionAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type AnswerUpsertWithoutSessionAnswersInput = {
    update: XOR<AnswerUpdateWithoutSessionAnswersInput, AnswerUncheckedUpdateWithoutSessionAnswersInput>
    create: XOR<AnswerCreateWithoutSessionAnswersInput, AnswerUncheckedCreateWithoutSessionAnswersInput>
    where?: AnswerWhereInput
  }

  export type AnswerUpdateToOneWithWhereWithoutSessionAnswersInput = {
    where?: AnswerWhereInput
    data: XOR<AnswerUpdateWithoutSessionAnswersInput, AnswerUncheckedUpdateWithoutSessionAnswersInput>
  }

  export type AnswerUpdateWithoutSessionAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateWithoutSessionAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutPlayerProgressInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlayerProgressInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlayerProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayerProgressInput, UserUncheckedCreateWithoutPlayerProgressInput>
  }

  export type UserUpsertWithoutPlayerProgressInput = {
    update: XOR<UserUpdateWithoutPlayerProgressInput, UserUncheckedUpdateWithoutPlayerProgressInput>
    create: XOR<UserCreateWithoutPlayerProgressInput, UserUncheckedCreateWithoutPlayerProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayerProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayerProgressInput, UserUncheckedUpdateWithoutPlayerProgressInput>
  }

  export type UserUpdateWithoutPlayerProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayerProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlayerBadgeCreateWithoutBadgeInput = {
    id?: string
    unlockedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerBadgesInput
  }

  export type PlayerBadgeUncheckedCreateWithoutBadgeInput = {
    id?: string
    userId: string
    unlockedAt?: Date | string
  }

  export type PlayerBadgeCreateOrConnectWithoutBadgeInput = {
    where: PlayerBadgeWhereUniqueInput
    create: XOR<PlayerBadgeCreateWithoutBadgeInput, PlayerBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type PlayerBadgeCreateManyBadgeInputEnvelope = {
    data: PlayerBadgeCreateManyBadgeInput | PlayerBadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type PlayerBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: PlayerBadgeWhereUniqueInput
    update: XOR<PlayerBadgeUpdateWithoutBadgeInput, PlayerBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<PlayerBadgeCreateWithoutBadgeInput, PlayerBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type PlayerBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: PlayerBadgeWhereUniqueInput
    data: XOR<PlayerBadgeUpdateWithoutBadgeInput, PlayerBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type PlayerBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: PlayerBadgeScalarWhereInput
    data: XOR<PlayerBadgeUpdateManyMutationInput, PlayerBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type UserCreateWithoutPlayerBadgesInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlayerBadgesInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlayerBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayerBadgesInput, UserUncheckedCreateWithoutPlayerBadgesInput>
  }

  export type BadgeCreateWithoutPlayerBadgesInput = {
    id?: string
    name: string
    description: string
    imageUrl: string
    rarity: $Enums.BadgeRarity
    condition: string
    coinReward?: number
    conditionData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeUncheckedCreateWithoutPlayerBadgesInput = {
    id?: string
    name: string
    description: string
    imageUrl: string
    rarity: $Enums.BadgeRarity
    condition: string
    coinReward?: number
    conditionData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutPlayerBadgesInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutPlayerBadgesInput, BadgeUncheckedCreateWithoutPlayerBadgesInput>
  }

  export type UserUpsertWithoutPlayerBadgesInput = {
    update: XOR<UserUpdateWithoutPlayerBadgesInput, UserUncheckedUpdateWithoutPlayerBadgesInput>
    create: XOR<UserCreateWithoutPlayerBadgesInput, UserUncheckedCreateWithoutPlayerBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayerBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayerBadgesInput, UserUncheckedUpdateWithoutPlayerBadgesInput>
  }

  export type UserUpdateWithoutPlayerBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayerBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BadgeUpsertWithoutPlayerBadgesInput = {
    update: XOR<BadgeUpdateWithoutPlayerBadgesInput, BadgeUncheckedUpdateWithoutPlayerBadgesInput>
    create: XOR<BadgeCreateWithoutPlayerBadgesInput, BadgeUncheckedCreateWithoutPlayerBadgesInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutPlayerBadgesInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutPlayerBadgesInput, BadgeUncheckedUpdateWithoutPlayerBadgesInput>
  }

  export type BadgeUpdateWithoutPlayerBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    condition?: StringFieldUpdateOperationsInput | string
    coinReward?: IntFieldUpdateOperationsInput | number
    conditionData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateWithoutPlayerBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    condition?: StringFieldUpdateOperationsInput | string
    coinReward?: IntFieldUpdateOperationsInput | number
    conditionData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCategoryStatsInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCategoryStatsInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCategoryStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCategoryStatsInput, UserUncheckedCreateWithoutCategoryStatsInput>
  }

  export type UserUpsertWithoutCategoryStatsInput = {
    update: XOR<UserUpdateWithoutCategoryStatsInput, UserUncheckedUpdateWithoutCategoryStatsInput>
    create: XOR<UserCreateWithoutCategoryStatsInput, UserUncheckedCreateWithoutCategoryStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCategoryStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCategoryStatsInput, UserUncheckedUpdateWithoutCategoryStatsInput>
  }

  export type UserUpdateWithoutCategoryStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCategoryStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutStreakProtectionsInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStreakProtectionsInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStreakProtectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStreakProtectionsInput, UserUncheckedCreateWithoutStreakProtectionsInput>
  }

  export type UserUpsertWithoutStreakProtectionsInput = {
    update: XOR<UserUpdateWithoutStreakProtectionsInput, UserUncheckedUpdateWithoutStreakProtectionsInput>
    create: XOR<UserCreateWithoutStreakProtectionsInput, UserUncheckedCreateWithoutStreakProtectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStreakProtectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStreakProtectionsInput, UserUncheckedUpdateWithoutStreakProtectionsInput>
  }

  export type UserUpdateWithoutStreakProtectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStreakProtectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPlayerRankingInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlayerRankingInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlayerRankingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayerRankingInput, UserUncheckedCreateWithoutPlayerRankingInput>
  }

  export type UserUpsertWithoutPlayerRankingInput = {
    update: XOR<UserUpdateWithoutPlayerRankingInput, UserUncheckedUpdateWithoutPlayerRankingInput>
    create: XOR<UserCreateWithoutPlayerRankingInput, UserUncheckedCreateWithoutPlayerRankingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayerRankingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayerRankingInput, UserUncheckedUpdateWithoutPlayerRankingInput>
  }

  export type UserUpdateWithoutPlayerRankingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayerRankingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWalletInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type UserUpsertWithoutWalletInput = {
    update: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
  }

  export type UserUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    lives?: LivesCreateNestedOneWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    lives?: LivesUncheckedCreateNestedOneWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    lives?: LivesUpdateOneWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    lives?: LivesUncheckedUpdateOneWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLivesInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLivesInput = {
    id?: string
    email: string
    password: string
    username: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutUserInput
    playerProgress?: PlayerProgressUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    playerRanking?: PlayerRankingUncheckedCreateNestedOneWithoutUserInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatedByInput
    playerBadges?: PlayerBadgeUncheckedCreateNestedManyWithoutUserInput
    streakProtections?: StreakProtectionUncheckedCreateNestedManyWithoutUserInput
    categoryStats?: CategoryStatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLivesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLivesInput, UserUncheckedCreateWithoutLivesInput>
  }

  export type UserUpsertWithoutLivesInput = {
    update: XOR<UserUpdateWithoutLivesInput, UserUncheckedUpdateWithoutLivesInput>
    create: XOR<UserCreateWithoutLivesInput, UserUncheckedCreateWithoutLivesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLivesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLivesInput, UserUncheckedUpdateWithoutLivesInput>
  }

  export type UserUpdateWithoutLivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutUserNestedInput
    playerProgress?: PlayerProgressUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    playerRanking?: PlayerRankingUncheckedUpdateOneWithoutUserNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatedByNestedInput
    playerBadges?: PlayerBadgeUncheckedUpdateManyWithoutUserNestedInput
    streakProtections?: StreakProtectionUncheckedUpdateManyWithoutUserNestedInput
    categoryStats?: CategoryStatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type QuizSessionCreateManyUserInput = {
    id?: string
    categoryId?: string | null
    difficultyId: string
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    source: string
    description?: string | null
    balanceAfter: number
    createdAt?: Date | string
  }

  export type QuestionCreateManyCreatedByInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    categoryId: string
    difficultyId: string
    status?: $Enums.QuestionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerBadgeCreateManyUserInput = {
    id?: string
    badgeId: string
    unlockedAt?: Date | string
  }

  export type StreakProtectionCreateManyUserInput = {
    id?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type CategoryStatCreateManyUserInput = {
    id?: string
    categoryName: string
    quizzesPlayed?: number
    correctAnswers?: number
    totalAnswers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: DifficultyUpdateOneRequiredWithoutQuizSessionsNestedInput
    answers?: SessionAnswerUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: SessionAnswerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutQuestionsNestedInput
    difficulty?: DifficultyUpdateOneRequiredWithoutQuestionsNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    sessionAnswers?: SessionAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    sessionAnswers?: SessionAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badge?: BadgeUpdateOneRequiredWithoutPlayerBadgesNestedInput
  }

  export type PlayerBadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakProtectionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakProtectionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakProtectionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryStatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    quizzesPlayed?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryStatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    quizzesPlayed?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryStatUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryName?: StringFieldUpdateOperationsInput | string
    quizzesPlayed?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateManyCategoryInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    difficultyId: string
    status?: $Enums.QuestionStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: DifficultyUpdateOneRequiredWithoutQuestionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    sessionAnswers?: SessionAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    sessionAnswers?: SessionAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateManyDifficultyInput = {
    id?: string
    text: string
    explanation: string
    imageUrl?: string | null
    categoryId: string
    status?: $Enums.QuestionStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizSessionCreateManyDifficultyInput = {
    id?: string
    userId: string
    categoryId?: string | null
    status?: $Enums.SessionStatus
    score?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateWithoutDifficultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutQuestionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    sessionAnswers?: SessionAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutDifficultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    sessionAnswers?: SessionAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutDifficultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSessionUpdateWithoutDifficultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutQuizSessionsNestedInput
    answers?: SessionAnswerUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateWithoutDifficultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: SessionAnswerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateManyWithoutDifficultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    score?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerCreateManyQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionAnswerCreateManyQuestionInput = {
    id?: string
    sessionId: string
    answerId: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
  }

  export type AnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionAnswers?: SessionAnswerUpdateManyWithoutAnswerNestedInput
  }

  export type AnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionAnswers?: SessionAnswerUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type AnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: QuizSessionUpdateOneRequiredWithoutAnswersNestedInput
    answer?: AnswerUpdateOneRequiredWithoutSessionAnswersNestedInput
  }

  export type SessionAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionAnswerCreateManyAnswerInput = {
    id?: string
    sessionId: string
    questionId: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
  }

  export type SessionAnswerUpdateWithoutAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: QuizSessionUpdateOneRequiredWithoutAnswersNestedInput
    question?: QuestionUpdateOneRequiredWithoutSessionAnswersNestedInput
  }

  export type SessionAnswerUncheckedUpdateWithoutAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionAnswerUncheckedUpdateManyWithoutAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionAnswerCreateManySessionInput = {
    id?: string
    questionId: string
    answerId: string
    isCorrect: boolean
    timeSpent: number
    pointsEarned: number
    timeBonus?: number
    answeredAt?: Date | string
  }

  export type SessionAnswerUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutSessionAnswersNestedInput
    answer?: AnswerUpdateOneRequiredWithoutSessionAnswersNestedInput
  }

  export type SessionAnswerUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionAnswerUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: IntFieldUpdateOperationsInput | number
    pointsEarned?: IntFieldUpdateOperationsInput | number
    timeBonus?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBadgeCreateManyBadgeInput = {
    id?: string
    userId: string
    unlockedAt?: Date | string
  }

  export type PlayerBadgeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerBadgesNestedInput
  }

  export type PlayerBadgeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerBadgeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}